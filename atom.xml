<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>轩箫的博客</title>
  <subtitle>不要懒惰</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://sunyang.xyz/"/>
  <updated>2019-11-13T09:13:05.560Z</updated>
  <id>http://sunyang.xyz/</id>
  
  <author>
    <name>轩箫</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>208. 实现 Trie (前缀树)</title>
    <link href="http://sunyang.xyz/2019/11/13/LeetCode-Java/208.%20%E5%AE%9E%E7%8E%B0%20Trie%20(%E5%89%8D%E7%BC%80%E6%A0%91)/"/>
    <id>http://sunyang.xyz/2019/11/13/LeetCode-Java/208. 实现 Trie (前缀树)/</id>
    <published>2019-11-13T09:12:20.000Z</published>
    <updated>2019-11-13T09:13:05.560Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述 ***"></a>题目描述 ***</h2><p>实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。</p>
<p>示例:</p>
<pre><code>Trie trie = new Trie();

trie.insert(&quot;apple&quot;);
trie.search(&quot;apple&quot;);   // 返回 true
trie.search(&quot;app&quot;);     // 返回 false
trie.startsWith(&quot;app&quot;); // 返回 true
trie.insert(&quot;app&quot;);   
trie.search(&quot;app&quot;);     // 返回 true
</code></pre><p>说明:</p>
<ul>
<li>你可以假设所有的输入都是由小写字母 a-z 构成的。</li>
<li>保证所有输入均为非空字符串。</li>
</ul>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><pre><code class="Java">class Trie {
    boolean value;
    Trie[] next;

    /** Initialize your data structure here. */
    public Trie() {
        value = false;
        next = new Trie[26];
    }

    /** Inserts a word into the trie. */
    public void insert(String word) {
        Trie cur = this;
        for(int d = 0; d&lt;word.length(); d++) {
            int i = word.charAt(d) - &#39;a&#39;;
            if(cur.next[i] == null) cur.next[i] = new Trie();
            cur = cur.next[i];
        }
        cur.value = true;
    }

    /** Returns if the word is in the trie. */
    public boolean search(String word) {
        Trie cur = this;
        for(int d = 0; d &lt; word.length(); d++) {
            int i = word.charAt(d) - &#39;a&#39;;
            if(cur.next[i] == null) return false;
            cur = cur.next[i];
        }
        if(cur.value) return true;
        return false;
    }

    /** Returns if there is any word in the trie that starts with the given prefix. */
    public boolean startsWith(String prefix) {
        Trie cur = this;
        for(int d = 0; d &lt; prefix.length(); d++) {
            int i = prefix.charAt(d) - &#39;a&#39;;
            if(cur.next[i] == null) return false;
            cur = cur.next[i];
        }
        return true;
    }
}

/**
 * Your Trie object will be instantiated and called as such:
 * Trie obj = new Trie();
 * obj.insert(word);
 * boolean param_2 = obj.search(word);
 * boolean param_3 = obj.startsWith(prefix);
 */
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述 ***&quot;&gt;&lt;/a&gt;题目描述 ***&lt;/h2&gt;&lt;p&gt;实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。
    
    </summary>
    
      <category term="LeetCode-Java" scheme="http://sunyang.xyz/categories/LeetCode-Java/"/>
    
    
      <category term="Java" scheme="http://sunyang.xyz/tags/Java/"/>
    
      <category term="LeetCode" scheme="http://sunyang.xyz/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>207. 课程表</title>
    <link href="http://sunyang.xyz/2019/11/13/LeetCode-Java/207.%20%E8%AF%BE%E7%A8%8B%E8%A1%A8/"/>
    <id>http://sunyang.xyz/2019/11/13/LeetCode-Java/207. 课程表/</id>
    <published>2019-11-13T01:12:20.000Z</published>
    <updated>2019-11-13T09:13:16.470Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述 ****"></a>题目描述 ****</h2><p>现在你总共有 n 门课需要选，记为 0 到 n-1。</p>
<p>在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]</p>
<p>给定课程总量以及它们的先决条件，判断是否可能完成所有课程的学习？</p>
<p>示例 1:</p>
<pre><code>输入: 2, [[1,0]] 
输出: true
解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。
</code></pre><p>示例 2:</p>
<pre><code>输入: 2, [[1,0],[0,1]]
输出: false
解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。
</code></pre><p>说明:</p>
<ol>
<li>输入的先决条件是由边缘列表表示的图形，而不是邻接矩阵。详情请参见图的表示法。</li>
<li>你可以假定输入的先决条件中没有重复的边。  </li>
</ol>
<p>提示:</p>
<ol>
<li>这个问题相当于查找一个循环是否存在于有向图中。如果存在循环，则不存在拓扑排序，因此不可能选取所有课程进行学习。</li>
<li>通过 DFS 进行拓扑排序</li>
<li>一个关于Coursera的精彩视频教程（21分钟），介绍拓扑排序的基本概念。<br>拓扑排序也可以通过 BFS 完成。</li>
</ol>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h4 id="方法一-深度优先搜索dfs"><a href="#方法一-深度优先搜索dfs" class="headerlink" title="方法一 深度优先搜索dfs"></a>方法一 深度优先搜索dfs</h4><pre><code class="Java">class Solution {
    boolean[] marked;
    boolean[] onStack;
    boolean hasCycle;

    public boolean canFinish(int numCourses, int[][] prerequisites) {
        LinkedList&lt;Integer&gt;[] graph = new LinkedList[numCourses];  // 注意链表数组的写法，new后面不带&lt;&gt;
        for(int i=0; i&lt;graph.length; i++) graph[i] = new LinkedList&lt;Integer&gt;(); // 数组元素要挨个初始化
        for(int[] edge : prerequisites) {
            graph[edge[0]].add(edge[1]);
        }
        return !hasCycle(graph);
    }

    public boolean hasCycle(LinkedList&lt;Integer&gt;[] graph) {
        int n = graph.length;
        marked = new boolean[n];
        onStack = new boolean[n];
        for(int i=0; i&lt;n; i++) {
            if(marked[i]) continue;
            dfs(graph, i);
            if(hasCycle) return true;
        }
        return false;
    }

    public void dfs(LinkedList&lt;Integer&gt;[] graph, int i) {
        marked[i] = true;
        onStack[i] = true;
        for(int v : graph[i]) {
            if(onStack[v]) {hasCycle = true; return;}; // onStack 则一定 marked，这一句不需要额外判断marked
            if(marked[v]) continue;
            dfs(graph, v);
        }
        onStack[i] = false;
        return;
    }
}
</code></pre>
<p>时间复杂度 O(m+n)</p>
<h4 id="方法二-入度表-bfs"><a href="#方法二-入度表-bfs" class="headerlink" title="方法二 入度表 bfs"></a>方法二 入度表 bfs</h4><pre><code class="Java">class Solution {
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        int[] indegrees = new int[numCourses];
        for(int[] cp : prerequisites) indegrees[cp[0]]++;
        LinkedList&lt;Integer&gt; queue = new LinkedList&lt;&gt;();
        for(int i = 0; i &lt; numCourses; i++){
            if(indegrees[i] == 0) queue.addLast(i);
        }
        while(!queue.isEmpty()) {
            Integer pre = queue.removeFirst();
            numCourses--;
            for(int[] req : prerequisites) {
                if(req[1] != pre) continue;
                if(--indegrees[req[0]] == 0) queue.add(req[0]);
            }
        }
        return numCourses == 0;
    }
}
</code></pre>
<p>时间复杂度O(m*n)</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述 ****&quot;&gt;&lt;/a&gt;题目描述 ****&lt;/h2&gt;&lt;p&gt;现在你总共有 n 门课需要选，记为 0 到 n-1。&lt;/p&gt;
&lt;p&gt;在选修某些课程之前需要一些先修课程。
    
    </summary>
    
      <category term="LeetCode-Java" scheme="http://sunyang.xyz/categories/LeetCode-Java/"/>
    
    
      <category term="Java" scheme="http://sunyang.xyz/tags/Java/"/>
    
      <category term="LeetCode" scheme="http://sunyang.xyz/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>206. 反转链表</title>
    <link href="http://sunyang.xyz/2019/11/12/LeetCode-Java/206.%20%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <id>http://sunyang.xyz/2019/11/12/LeetCode-Java/206. 反转链表/</id>
    <published>2019-11-12T14:12:20.000Z</published>
    <updated>2019-11-13T09:13:23.823Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述 **"></a>题目描述 **</h2><p>反转一个单链表。</p>
<p>示例:</p>
<pre><code>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL
输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL
</code></pre><p>进阶:<br>你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><pre><code class="Java">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode pre = null;
        ListNode cur = head;
        while(cur != null) {
            ListNode next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    }
}
</code></pre>
<h4 id="递归"><a href="#递归" class="headerlink" title="递归 **"></a>递归 **</h4><pre><code class="Java">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
        if(head == null || head.next == null) return head;
        ListNode p = reverseList(head.next);
        head.next.next = head;  // head.next此时是链表尾结点
        head.next = null;
        return p;
    }
}
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述 **&quot;&gt;&lt;/a&gt;题目描述 **&lt;/h2&gt;&lt;p&gt;反转一个单链表。&lt;/p&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入: 1-&amp;gt;2-&amp;gt;3-&amp;gt
    
    </summary>
    
      <category term="LeetCode-Java" scheme="http://sunyang.xyz/categories/LeetCode-Java/"/>
    
    
      <category term="Java" scheme="http://sunyang.xyz/tags/Java/"/>
    
      <category term="LeetCode" scheme="http://sunyang.xyz/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>206. 反转链表</title>
    <link href="http://sunyang.xyz/2019/11/12/LeetCode-Java/200.%20%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/"/>
    <id>http://sunyang.xyz/2019/11/12/LeetCode-Java/200. 岛屿数量/</id>
    <published>2019-11-12T04:12:20.000Z</published>
    <updated>2019-11-13T09:13:20.433Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述 **"></a>题目描述 **</h2><p>给定一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。</p>
<p>示例 1:</p>
<pre><code>输入:
11110
11010
11000
00000

输出: 1
</code></pre><p>示例 2:</p>
<pre><code>输入:
11000
11000
00100
00011

输出: 3
</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><ul>
<li>深度优先搜索</li>
<li>广度优先搜索</li>
<li>并查集</li>
</ul>
<pre><code class="Java">class Solution {
    public int numIslands(char[][] grid) {
        if(grid.length == 0) return 0;
        int x = grid.length, y = grid[0].length;
        int count = 0;
        boolean[][] marked = new boolean[x][y];
        for(int i=0; i&lt;x; i++) {
            for(int j=0; j&lt;y; j++) {
                if(marked[i][j] == false &amp;&amp; grid[i][j] == &#39;1&#39;) {
                    count++;
                    dfs(marked, grid, i, j);
                }
            }
        }
        return count;
    }

    public void dfs(boolean[][] marked, char[][] grid, int i, int j) {
        if(i&lt;0 || i&gt;grid.length-1 || j&lt;0 || j&gt;grid[0].length-1) return;
        if(marked[i][j] == true || grid[i][j] == &#39;0&#39;) return;
        marked[i][j] = true;
        dfs(marked, grid, i-1, j);
        dfs(marked, grid, i, j-1);
        dfs(marked, grid, i, j+1);
        dfs(marked, grid, i+1, j);
        return;
    }
}
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述 **&quot;&gt;&lt;/a&gt;题目描述 **&lt;/h2&gt;&lt;p&gt;给定一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向
    
    </summary>
    
      <category term="LeetCode-Java" scheme="http://sunyang.xyz/categories/LeetCode-Java/"/>
    
    
      <category term="Java" scheme="http://sunyang.xyz/tags/Java/"/>
    
      <category term="LeetCode" scheme="http://sunyang.xyz/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>198. 打家劫舍</title>
    <link href="http://sunyang.xyz/2019/11/11/LeetCode-Java/198.%20%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/"/>
    <id>http://sunyang.xyz/2019/11/11/LeetCode-Java/198. 打家劫舍/</id>
    <published>2019-11-11T06:12:20.000Z</published>
    <updated>2019-11-13T09:13:27.380Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述 ***"></a>题目描述 ***</h2><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p>
<p>示例 1:</p>
<pre><code>输入: [1,2,3,1]
输出: 4
解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
</code></pre><p>示例 2:</p>
<pre><code>输入: [2,7,9,3,1]
输出: 12
解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><pre><code class="Java">class Solution {
    public int rob(int[] nums) {
        if(nums.length == 0) return 0;
        if(nums.length == 1) return nums[0];
        if(nums.length == 2) return Math.max(nums[0], nums[1]);
        int[] dp = new int[nums.length];
        dp[0] = nums[0];
        dp[1] = Math.max(nums[0], nums[1]);
        for(int i=2; i&lt;nums.length; i++) {
            dp[i] = Math.max(dp[i-1], dp[i-2]+nums[i]);
        }
        return dp[nums.length-1];
    }
}
</code></pre>
<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>由于每一步你只需要前两个最大值，两个变量就足够用了。 </p>
<pre><code class="Java">public int rob(int[] num) {
    int prevMax = 0;
    int currMax = 0;
    for (int x : num) {
        int temp = currMax;
        currMax = Math.max(prevMax + x, currMax);
        prevMax = temp;
    }
    return currMax;
}
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述 ***&quot;&gt;&lt;/a&gt;题目描述 ***&lt;/h2&gt;&lt;p&gt;你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有
    
    </summary>
    
      <category term="LeetCode-Java" scheme="http://sunyang.xyz/categories/LeetCode-Java/"/>
    
    
      <category term="Java" scheme="http://sunyang.xyz/tags/Java/"/>
    
      <category term="LeetCode" scheme="http://sunyang.xyz/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>169. 求众数</title>
    <link href="http://sunyang.xyz/2019/11/11/LeetCode-Java/169.%20%E6%B1%82%E4%BC%97%E6%95%B0/"/>
    <id>http://sunyang.xyz/2019/11/11/LeetCode-Java/169. 求众数/</id>
    <published>2019-11-11T06:12:20.000Z</published>
    <updated>2019-11-13T09:13:29.969Z</updated>
    
    <content type="html"><![CDATA[<h2 id="留坑！！！"><a href="#留坑！！！" class="headerlink" title="留坑！！！"></a>留坑！！！</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;留坑！！！&quot;&gt;&lt;a href=&quot;#留坑！！！&quot; class=&quot;headerlink&quot; title=&quot;留坑！！！&quot;&gt;&lt;/a&gt;留坑！！！&lt;/h2&gt;
    
    </summary>
    
      <category term="LeetCode-Java" scheme="http://sunyang.xyz/categories/LeetCode-Java/"/>
    
    
      <category term="Java" scheme="http://sunyang.xyz/tags/Java/"/>
    
      <category term="LeetCode" scheme="http://sunyang.xyz/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>155. 最小栈</title>
    <link href="http://sunyang.xyz/2019/11/10/LeetCode-Java/160.%20%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/"/>
    <id>http://sunyang.xyz/2019/11/10/LeetCode-Java/160. 相交链表/</id>
    <published>2019-11-10T11:12:20.000Z</published>
    <updated>2019-11-13T09:13:47.766Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述 **"></a>题目描述 **</h2><p>编写一个程序，找到两个单链表相交的起始节点。<br>图见<a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="external">leetcode</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h4 id="方法一-HashSet"><a href="#方法一-HashSet" class="headerlink" title="方法一 HashSet"></a>方法一 HashSet</h4><pre><code class="Java">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode temp = headA;
        HashSet&lt;ListNode&gt; set = new HashSet&lt;&gt;();
        while(temp != null) {
            set.add(temp);
            temp = temp.next;
        }
        temp = headB;
        while(temp != null) {
            if(set.contains(temp)) return temp;
            temp = temp.next;
        }
        return null;
    }
}
</code></pre>
<h5 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ul>
<li>时间复杂度 : O(m+n)。</li>
<li>空间复杂度 : O(m) 或 O(n)。</li>
</ul>
<h4 id="方法二-双指针"><a href="#方法二-双指针" class="headerlink" title="方法二 双指针"></a>方法二 双指针</h4><p>两个指针分别遍历两个链表，计算链表总长度。<br>让长链表先走完差，剩下的长度与短链表相等。这是两指针同时走，相交时两指针相等。  </p>
<pre><code class="Java">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        int numA = 0, numB = 0;
        ListNode tempA = headA;
        while(tempA != null) {
            tempA = tempA.next;
            numA ++;
        }
        ListNode tempB = headB;
        while(tempB != null) {
            tempB = tempB.next;
            numB ++;
        }

        tempA = headA;
        tempB = headB;
        if(numA &gt; numB) {
            for(int i=0; i&lt; numA - numB; i++) tempA = tempA.next;
        }
        else{
            for(int i=0; i&lt; numB - numA; i++) tempB = tempB.next;
        }
        while(tempA != null) {
            if(tempA == tempB) return tempA;
            tempA = tempA.next;
            tempB = tempB.next;
        }

        return null;
    }
}
</code></pre>
<h5 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ul>
<li>时间复杂度： O(m+n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h4 id="方法三-双指针优化"><a href="#方法三-双指针优化" class="headerlink" title="方法三 双指针优化"></a>方法三 双指针优化</h4><p>方法二需要两个链表分别走一遍，然后再走差值，然后合起来走。<br>其实两指针可以一起走，在短链表走完之后移到长链表，长链表走完之后移到短链表。  </p>
<pre><code class="Java">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode tempA = headA, tempB = headB;

        while(tempA != null || tempB != null) {
            if(tempA == null) {
                tempA = headB;
                tempB = tempB.next;
                continue;
            }

            if(tempB == null) {
                tempB = headA;
                tempA = tempA.next;
                continue;
            }
            if(tempA == tempB) return tempA;
            tempA = tempA.next;
            tempB = tempB.next;
        }

        return null;
    }
}
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述 **&quot;&gt;&lt;/a&gt;题目描述 **&lt;/h2&gt;&lt;p&gt;编写一个程序，找到两个单链表相交的起始节点。&lt;br&gt;图见&lt;a href=&quot;https://leetcode-cn
    
    </summary>
    
      <category term="LeetCode-Java" scheme="http://sunyang.xyz/categories/LeetCode-Java/"/>
    
    
      <category term="Java" scheme="http://sunyang.xyz/tags/Java/"/>
    
      <category term="LeetCode" scheme="http://sunyang.xyz/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>155. 最小栈</title>
    <link href="http://sunyang.xyz/2019/11/10/LeetCode-Java/155.%20%E6%9C%80%E5%B0%8F%E6%A0%88/"/>
    <id>http://sunyang.xyz/2019/11/10/LeetCode-Java/155. 最小栈/</id>
    <published>2019-11-10T11:12:20.000Z</published>
    <updated>2019-11-13T09:13:51.107Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述 **"></a>题目描述 **</h2><p>设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。</p>
<p>push(x) – 将元素 x 推入栈中。<br>pop() – 删除栈顶的元素。<br>top() – 获取栈顶元素。<br>getMin() – 检索栈中的最小元素。<br>示例:</p>
<pre><code>MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --&gt; 返回 -3.
minStack.pop();
minStack.top();      --&gt; 返回 0.
minStack.getMin();   --&gt; 返回 -2.
</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>辅助栈和数据栈同步</p>
<pre><code class="Java">class MinStack {
    Deque&lt;Integer&gt; stack1;
    Deque&lt;Integer&gt; stack2;


    /** initialize your data structure here. */
    public MinStack() {
        stack1 = new ArrayDeque&lt;&gt;();
        stack2 = new ArrayDeque&lt;&gt;();
    }

    public void push(int x) {
        stack1.push(x);
        if(stack2.isEmpty() || stack2.peek() &gt;= x) stack2.push(x);
        else stack2.push(stack2.peek());
    }

    public void pop() {
        stack1.pop();
        stack2.pop();
    }

    public int top() {
        return stack1.peek();
    }

    public int getMin() {
        return stack2.peek();
    }
}

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack obj = new MinStack();
 * obj.push(x);
 * obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.getMin();
 */
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述 **&quot;&gt;&lt;/a&gt;题目描述 **&lt;/h2&gt;&lt;p&gt;设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。&lt;/p&gt;
&lt;p&gt;push(x)
    
    </summary>
    
      <category term="LeetCode-Java" scheme="http://sunyang.xyz/categories/LeetCode-Java/"/>
    
    
      <category term="Java" scheme="http://sunyang.xyz/tags/Java/"/>
    
      <category term="LeetCode" scheme="http://sunyang.xyz/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>152. 乘积最大子序列</title>
    <link href="http://sunyang.xyz/2019/11/07/LeetCode-Java/152.%20%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>http://sunyang.xyz/2019/11/07/LeetCode-Java/152. 乘积最大子序列/</id>
    <published>2019-11-07T12:12:20.000Z</published>
    <updated>2019-11-13T09:13:53.933Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述 ***"></a>题目描述 ***</h2><p>给定一个整数数组 nums ，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。</p>
<p>示例 1:</p>
<pre><code>输入: [2,3,-2,4]
输出: 6
解释: 子数组 [2,3] 有最大乘积 6。
</code></pre><p>示例 2:</p>
<pre><code>输入: [-2,0,-1]
输出: 0
解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。
</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>相关问题 <a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="external">53. 最大子序和</a></p>
<h4 id="方法一-维护最大最小值"><a href="#方法一-维护最大最小值" class="headerlink" title="方法一  维护最大最小值"></a>方法一  维护最大最小值</h4><ul>
<li>遍历数组时计算当前最大值，不断更新</li>
<li>令imax为当前最大值，则当前最大值为 imax = max(imax * nums[i], nums[i])</li>
<li><strong>由于存在负数，那么会导致最大的变最小的，最小的变最大的。因此还需要维护当前最小值imin，imin = min(imin * nums[i], nums[i])</strong></li>
<li><strong>当负数出现时则imax与imin进行交换再进行下一步计算</strong>  </li>
<li>时间复杂度：O(n)</li>
</ul>
<p>imax表示以当前节点为终结节点的最大连续子序列乘积 imin表示以当前节点为终结节点的最小连续子序列乘积</p>
<pre><code class="Java">class Solution {
    public int maxProduct(int[] nums) {
        int max = Integer.MIN_VALUE, imax = 1, imin = 1;
        for(int i=0; i&lt;nums.length; i++){
            if(nums[i] &lt; 0){ 
              int tmp = imax;
              imax = imin;
              imin = tmp;
            }
            imax = Math.max(imax*nums[i], nums[i]);
            imin = Math.min(imin*nums[i], nums[i]);

            max = Math.max(max, imax);
        }
        return max;
    }
}
</code></pre>
<h4 id="方法二-奇数个负值-偶数个负值"><a href="#方法二-奇数个负值-偶数个负值" class="headerlink" title="方法二  奇数个负值 偶数个负值"></a>方法二  奇数个负值 偶数个负值</h4><p>正反各遍历一遍，以防奇数个负值的情况。<br>分析详见<a href="https://leetcode-cn.com/problems/maximum-product-subarray/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by--36/" target="_blank" rel="external">leetcode</a></p>
<pre><code class="Java">public int maxProduct(int[] nums) {
    if (nums.length == 0) {
        return 0;
    }

    int max = 1;
    int res = nums[0];
    for (int i = 0; i &lt; nums.length; i++) {
        max *= nums[i];
        res = Math.max(res, max);
        if (max == 0) {
            max = 1;
        }

    }
    max = 1;
    for (int i = nums.length - 1; i &gt;= 0; i--) {
        max *= nums[i];
        res = Math.max(res, max);
        if (max == 0) {
            max = 1;
        }
    }

    return res;
}
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述 ***&quot;&gt;&lt;/a&gt;题目描述 ***&lt;/h2&gt;&lt;p&gt;给定一个整数数组 nums ，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。&lt;/p&gt;
&lt;p&gt;示
    
    </summary>
    
      <category term="LeetCode-Java" scheme="http://sunyang.xyz/categories/LeetCode-Java/"/>
    
    
      <category term="Java" scheme="http://sunyang.xyz/tags/Java/"/>
    
      <category term="LeetCode" scheme="http://sunyang.xyz/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>148. 排序链表</title>
    <link href="http://sunyang.xyz/2019/11/07/LeetCode-Java/148.%20%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <id>http://sunyang.xyz/2019/11/07/LeetCode-Java/148. 排序链表/</id>
    <published>2019-11-07T07:12:20.000Z</published>
    <updated>2019-11-13T09:13:56.913Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述 ***"></a>题目描述 ***</h2><p>在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。</p>
<p>示例 1:</p>
<pre><code>输入: 4-&gt;2-&gt;1-&gt;3
输出: 1-&gt;2-&gt;3-&gt;4
</code></pre><p>示例 2:</p>
<pre><code>输入: -1-&gt;5-&gt;3-&gt;4-&gt;0
输出: -1-&gt;0-&gt;3-&gt;4-&gt;5
</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h4 id="方法一-自顶向下归并排序（递归）"><a href="#方法一-自顶向下归并排序（递归）" class="headerlink" title="方法一 自顶向下归并排序（递归）"></a>方法一 自顶向下归并排序（递归）</h4><p>用快慢指针找到中间节点，然后切分链表，两部分分别排序，然后合并。</p>
<pre><code class="Java">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode sortList(ListNode head) {
        if(head == null || head.next == null) return head;
        ListNode slow = head;
        ListNode fast = head.next;
        while(fast != null &amp;&amp; fast.next != null) {
            fast = fast.next.next;
            slow = slow.next;
        }
        ListNode right = sortList(slow.next);
        slow.next = null;
        ListNode left = sortList(head);
        return merge(left, right);
    }

    public ListNode merge(ListNode left, ListNode right) {
        ListNode temp = new ListNode(0);
        ListNode p = temp;
        while(left != null &amp;&amp; right != null) {
            if(left.val &lt; right.val) {
                p.next = left;
                left = left.next;
                p = p.next;
            }
            else {
                p.next = right;
                right = right.next;
                p = p.next;
            }
        }
        if(left != null) p.next = left;
        else if(right != null) p.next = right;
        return temp.next;
    }
}
</code></pre>
<h4 id="方法二-自底向上的归并排序（迭代）"><a href="#方法二-自底向上的归并排序（迭代）" class="headerlink" title="方法二 自底向上的归并排序（迭代）"></a>方法二 自底向上的归并排序（迭代）</h4><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h4 id="链表的快速排序"><a href="#链表的快速排序" class="headerlink" title="链表的快速排序"></a>链表的快速排序</h4><pre><code class="Java">class Solution {
public ListNode sortList(ListNode head) {
        if(head==null||head.next==null) return head;
        // 没有条件，创造条件。自己添加头节点，最后返回时去掉即可。
        ListNode newHead=new ListNode(-1);
        newHead.next=head;
        return quickSort(newHead,null);
    }
    // 带头结点的链表快速排序
    private ListNode quickSort(ListNode head,ListNode end){
        if (head==end||head.next==end||head.next.next==end) return head;
        // 将小于划分点的值存储在临时链表中
        ListNode tmpHead=new ListNode(-1);
        // partition为划分点，p为链表指针，tp为临时链表指针
        ListNode partition=head.next,p=partition,tp=tmpHead;
        // 将小于划分点的结点放到临时链表中
        while (p.next!=end){
            if (p.next.val&lt;partition.val){
                tp.next=p.next;
                tp=tp.next;
                p.next=p.next.next;
            }else {
                p=p.next;
            }
        }
        // 合并临时链表和原链表，将原链表接到临时链表后面即可
        tp.next=head.next;
        // 将临时链表插回原链表，注意是插回！（不做这一步在对右半部分处理时就断链了）
        head.next=tmpHead.next;
        quickSort(head,partition);
        quickSort(partition,end);
        // 题目要求不带头节点，返回结果时去除
        return head.next;
    }
}
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述 ***&quot;&gt;&lt;/a&gt;题目描述 ***&lt;/h2&gt;&lt;p&gt;在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode-Java" scheme="http://sunyang.xyz/categories/LeetCode-Java/"/>
    
    
      <category term="Java" scheme="http://sunyang.xyz/tags/Java/"/>
    
      <category term="LeetCode" scheme="http://sunyang.xyz/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>146. LRU缓存机制</title>
    <link href="http://sunyang.xyz/2019/11/04/LeetCode-Java/146.%20LRU%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
    <id>http://sunyang.xyz/2019/11/04/LeetCode-Java/146. LRU缓存机制/</id>
    <published>2019-11-04T13:12:20.000Z</published>
    <updated>2019-11-13T09:14:01.659Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述 ***"></a>题目描述 ***</h2><p>运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。</p>
<p>获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。<br>写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。</p>
<p>进阶:</p>
<p>你是否可以在 O(1) 时间复杂度内完成这两种操作？</p>
<p>示例:</p>
<pre><code>LRUCache cache = new LRUCache( 2 /* 缓存容量 */ );

cache.put(1, 1);
cache.put(2, 2);
cache.get(1);       // 返回  1
cache.put(3, 3);    // 该操作会使得密钥 2 作废
cache.get(2);       // 返回 -1 (未找到)
cache.put(4, 4);    // 该操作会使得密钥 1 作废
cache.get(1);       // 返回 -1 (未找到)
cache.get(3);       // 返回  3
cache.get(4);       // 返回  4
</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h4 id="自己实现双向链表-HashMap"><a href="#自己实现双向链表-HashMap" class="headerlink" title="自己实现双向链表+HashMap"></a>自己实现双向链表+HashMap</h4><p>每个节点存前后节点指针，同时将节点存入HashMap以便在O(1)时间内完成访问。</p>
<pre><code class="Java">class LRUCache {
    class Node {
        int key;
        int value;
        Node pre;
        Node next;
        Node(int k, int v) {
            key = k;
            value = v;
            pre = null;
            next = null;
        }
    }

    Map&lt;Integer, Node&gt; map;
    int capacity;
    Node head;
    Node tail;

    public LRUCache(int capacity) {
        this.map = new HashMap&lt;Integer, Node&gt;();
        this.capacity = capacity;
    }

    public int get(int key) {
        if(!map.containsKey(key)) return -1;
        Node cur = map.get(key);
        if(cur != head) {
            cur.pre.next = cur.next;
            if(cur != tail) {
                cur.next.pre = cur.pre;
            }
            else tail = cur.pre;
            cur.pre = null;
            cur.next = head;
            head.pre = cur;
            head = cur;
        }

        return cur.value;
    }

    public void put(int key, int value) {
        if(map.containsKey(key)) {
            this.get(key);
            map.get(key).value = value;
            return;
        }
        Node cur = new Node(key, value);
        cur.next = head;
        head = cur;
        if(map.size() == 0) {
            tail = cur;
        }
        else {
            cur.next.pre = cur;
            if(map.size() &gt;= capacity) {
                map.remove(tail.key);
                tail = tail.pre;
                tail.next = null;
            }
        }

        map.put(key, cur);
        return;
    }
}

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache obj = new LRUCache(capacity);
 * int param_1 = obj.get(key);
 * obj.put(key,value);
 */
</code></pre>
<p>代码中要考虑首尾节点情况，显得有些啰嗦。可以先加入首尾两个节点，之后就无需判断了。</p>
<pre><code class="Java"> import java.util.Hashtable;
public class LRUCache {

  class DLinkedNode {
    int key;
    int value;
    DLinkedNode prev;
    DLinkedNode next;
  }

  private void addNode(DLinkedNode node) {
    /**
     * Always add the new node right after head.
     */
    node.prev = head;
    node.next = head.next;

    head.next.prev = node;
    head.next = node;
  }

  private void removeNode(DLinkedNode node){
    /**
     * Remove an existing node from the linked list.
     */
    DLinkedNode prev = node.prev;
    DLinkedNode next = node.next;

    prev.next = next;
    next.prev = prev;
  }

  private void moveToHead(DLinkedNode node){
    /**
     * Move certain node in between to the head.
     */
    removeNode(node);
    addNode(node);
  }

  private DLinkedNode popTail() {
    /**
     * Pop the current tail.
     */
    DLinkedNode res = tail.prev;
    removeNode(res);
    return res;
  }

  private Hashtable&lt;Integer, DLinkedNode&gt; cache =
          new Hashtable&lt;Integer, DLinkedNode&gt;();
  private int size;
  private int capacity;
  private DLinkedNode head, tail;

  public LRUCache(int capacity) {
    this.size = 0;
    this.capacity = capacity;

    head = new DLinkedNode();
    // head.prev = null;

    tail = new DLinkedNode();
    // tail.next = null;

    head.next = tail;
    tail.prev = head;
  }

  public int get(int key) {
    DLinkedNode node = cache.get(key);
    if (node == null) return -1;

    // move the accessed node to the head;
    moveToHead(node);

    return node.value;
  }

  public void put(int key, int value) {
    DLinkedNode node = cache.get(key);

    if(node == null) {
      DLinkedNode newNode = new DLinkedNode();
      newNode.key = key;
      newNode.value = value;

      cache.put(key, newNode);
      addNode(newNode);

      ++size;

      if(size &gt; capacity) {
        // pop the tail
        DLinkedNode tail = popTail();
        cache.remove(tail.key);
        --size;
      }
    } else {
      // update the value.
      node.value = value;
      moveToHead(node);
    }
  }
}

/**
 * LRUCache 对象会以如下语句构造和调用:
 * LRUCache obj = new LRUCache(capacity);
 * int param_1 = obj.get(key);
</code></pre>
<blockquote>
<p>LRU，最近最少使用，是一种页面置换算法，选择最近最久没有使用的页面予以淘汰。该算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 t，当须淘汰一个页面时，选择现有页面中其 t 值最大的，即最近最少使用的页面予以淘汰。<br>从程序运行的原理来看，最近最少使用算法是比较接近理想的一种页面置换算法，这种算法既充分利用了内存中页面调用的历史信息，又正确反映了程序的局部问题。  </p>
<p>硬件支持  </p>
<ul>
<li>寄存器<br>为了记录某进程在内存中各页的使用情况，须为每个在内存中的页面配置一个移位寄存器，可表示为<br>R = Rn-1 Rn-2 Rn-3 … R2 R1 R0<br>当进程访问某物理块时，要将相应寄存器的 R n -1 位置成 1。此时，定时信号将每隔一定时间(例如 100 ms)将寄存器右移一位。 如果我们把 n 位寄存器的数看做是一个整数， 那么，具有最小数值的寄存器所对应的页面，就是最近最久未使用的页面。</li>
<li>栈<br>可利用一个特殊的栈来保存当前使用的各个页面的页面号。每当进程访问某页面时，便将该页面的页面号从栈中移出，将它压入栈顶。因此，栈顶始终是最新被访问页面的编号，而栈底则是最近最久未使用页面的页面号。</li>
</ul>
<p>在进程运行过程中，若其所要访问的页面不在内存而需把它们调入内存，但内存已无空闲空间时，为了保证该进程能正常运行，系统必须从内存中调出一页程序或数据送磁盘的对换区中。但应将哪个页面调出，须根据一定的算法来确定。通常，把选择换出页面的算法称为页面置换算法(Page-Replacement Algorithms)。</p>
<p>其他页面置换算法</p>
<ul>
<li>最佳置换算法OPT<br>这个算法唯一的一个问题就是它无法实现。当缺页发生时，操作系统无法知道各个页面下一次是在什么时候被访问。虽然这个算法不可能实现，但是最佳页面置换算法可以用于对可实现算法的性能进行衡量比较。</li>
<li>先进先出置换算法FIFO<br>这种算法的实质是，总是选择在主存中停留时间最长（即最老）的一页置换，即先进入内存的页，先退出内存。理由是：最早调入内存的页，其不再被使用的可能性比刚调入内存的可能性大。建立一个FIFO队列，收容所有在内存中的页。被置换页面总是在队列头上进行。当一个页面被放入内存时，就把它插在队尾上。这种算法只是在按线性顺序访问地址空间时才是理想的，否则效率不高。因为那些常被访问的页，往往在主存中也停留得最久，结果它们因变“老”而不得不被置换出去。<br>FIFO的另一个缺点是，它有一种异常现象，即在增加存储块的情况下，反而使缺页中断率增加了。当然，导致这种异常现象的页面走向实际上是很少见的。</li>
<li>最少使用置换算法LFU<br>该置换算法选择在之前时期使用最少的页面作为淘汰页。由于存储器具有较高的访问速度，例如100 ns，在1 ms时间内可能对某页面连续访问成千上万次，因此，通常不能直接利用计数器来记录某页被访问的次数，而是采用移位寄存器方式。每次访问某页时，便将该移位寄存器的最高位置1，再每隔一定时间(例如100 ns)右移一次。这样，在最近一段时间使用最少的页面将是∑Ri最小的页。</li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述 ***&quot;&gt;&lt;/a&gt;题目描述 ***&lt;/h2&gt;&lt;p&gt;运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据
    
    </summary>
    
      <category term="LeetCode-Java" scheme="http://sunyang.xyz/categories/LeetCode-Java/"/>
    
    
      <category term="Java" scheme="http://sunyang.xyz/tags/Java/"/>
    
      <category term="LeetCode" scheme="http://sunyang.xyz/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>142. 环形链表 II</title>
    <link href="http://sunyang.xyz/2019/10/31/LeetCode-Java/142.%20%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%20II/"/>
    <id>http://sunyang.xyz/2019/10/31/LeetCode-Java/142. 环形链表 II/</id>
    <published>2019-10-31T03:12:20.000Z</published>
    <updated>2019-11-13T09:14:05.111Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述 ***"></a>题目描述 ***</h2><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>
<p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p>
<p>说明：不允许修改给定的链表。  </p>
<p>进阶：<br>你是否可以不用额外空间解决此题？</p>
<p>图见<a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/" target="_blank" rel="external">leetcode</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h4 id="方法一-哈希表"><a href="#方法一-哈希表" class="headerlink" title="方法一 哈希表"></a>方法一 哈希表</h4><pre><code class="Java">/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode detectCycle(ListNode head) {
        Set&lt;ListNode&gt; set = new HashSet&lt;&gt;();
        ListNode temp = head;
        while(temp != null) {
            if(set.contains(temp)) return temp;
            else {
                set.add(temp);
                temp = temp.next;
            }
        }
        return null;
    }
}
</code></pre>
<h4 id="方法二-快慢指针-双指针"><a href="#方法二-快慢指针-双指针" class="headerlink" title="方法二 快慢指针+双指针 ***"></a>方法二 快慢指针+双指针 ***</h4><p>有三个节点需要注意: 起始节点(head), 环的入口节点(输出结果), 相遇的节点(快慢指针求的)</p>
<p>我们要证明 : 初始点到环的入口的步数 等于 相遇点到环入口的步数</p>
<p>我们令, 初始点到入口为 s, 入口到相遇点 m, 环的周长为 r</p>
<p>我们只需证明: s == r - m</p>
<p>首先我们假设,慢指针走了 k 步到相遇点, 那么快指针就是 2k 步,所以我们有 2k - k = nr 即 k = nr(慢指针还没到环,快指针已经转了好几圈)</p>
<p>还有, s = k - m</p>
<p>得 : s = nr - m ==&gt; s == (n - 1) r + (r - m)</p>
<p>得证!</p>
<pre><code class="Java">public class Solution {
    public ListNode detectCycle(ListNode head) {
        if(head == null || head.next == null) return null;
        ListNode slow = head, fast = head;
        while(fast != null &amp;&amp; fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
            if(slow == fast) break;
        }
        if(fast == null || fast.next == null) return null;
        ListNode p = head, q = fast;
        while(p != q) {
            p = p.next;
            q = q.next;
        }
        return p;
    }
}
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述 ***&quot;&gt;&lt;/a&gt;题目描述 ***&lt;/h2&gt;&lt;p&gt;给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。&lt;/p&gt;
&lt;p&gt;为了表示给定链
    
    </summary>
    
      <category term="LeetCode-Java" scheme="http://sunyang.xyz/categories/LeetCode-Java/"/>
    
    
      <category term="Java" scheme="http://sunyang.xyz/tags/Java/"/>
    
      <category term="LeetCode" scheme="http://sunyang.xyz/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>141. 环形链表</title>
    <link href="http://sunyang.xyz/2019/10/31/LeetCode-Java/141.%20%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/"/>
    <id>http://sunyang.xyz/2019/10/31/LeetCode-Java/141. 环形链表/</id>
    <published>2019-10-31T03:12:20.000Z</published>
    <updated>2019-11-13T09:14:08.118Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述 ***"></a>题目描述 ***</h2><p>给定一个链表，判断链表中是否有环。</p>
<p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p>
<p>详见<a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="external">leetcode</a>  </p>
<p>进阶：</p>
<p>你能用 O(1)（即，常量）内存解决此问题吗？</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h4 id="方法一-哈希表"><a href="#方法一-哈希表" class="headerlink" title="方法一 哈希表"></a>方法一 哈希表</h4><pre><code class="Java">/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public boolean hasCycle(ListNode head) {
        Set&lt;ListNode&gt; set = new HashSet&lt;&gt;();
        while(head != null) {
            if(set.contains(head)) return true;
            set.add(head);
            head = head.next;
        }
        return false;
    }
}
</code></pre>
<h4 id="方法二-快慢指针"><a href="#方法二-快慢指针" class="headerlink" title="方法二 快慢指针 ***"></a>方法二 快慢指针 ***</h4><p>慢指针每次走一步，快指针每次走两步。如果有循环，就好像圆形跑道，快指针一定会追上慢指针。  </p>
<pre><code class="Java">/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public boolean hasCycle(ListNode head) {
        if(head == null || head.next == null) return false;
        ListNode slow = head, fast = head.next;
        while(slow != fast) {
            if(fast == null || fast.next == null) return false;
            fast = fast.next.next;
            slow = slow.next;
        }
        return true;
    }
}
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述 ***&quot;&gt;&lt;/a&gt;题目描述 ***&lt;/h2&gt;&lt;p&gt;给定一个链表，判断链表中是否有环。&lt;/p&gt;
&lt;p&gt;为了表示给定链表中的环，我们使用整数 pos 来表示链表尾
    
    </summary>
    
      <category term="LeetCode-Java" scheme="http://sunyang.xyz/categories/LeetCode-Java/"/>
    
    
      <category term="Java" scheme="http://sunyang.xyz/tags/Java/"/>
    
      <category term="LeetCode" scheme="http://sunyang.xyz/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>139. 单词拆分</title>
    <link href="http://sunyang.xyz/2019/10/31/LeetCode-Java/139.%20%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/"/>
    <id>http://sunyang.xyz/2019/10/31/LeetCode-Java/139. 单词拆分/</id>
    <published>2019-10-31T01:12:20.000Z</published>
    <updated>2019-11-13T09:14:11.480Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述 ***"></a>题目描述 ***</h2><p>给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。</p>
<p>说明：</p>
<ul>
<li>拆分时可以重复使用字典中的单词。</li>
<li>你可以假设字典中没有重复的单词。  </li>
</ul>
<p>示例 1：</p>
<pre><code>输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]
输出: true
解释: 返回 true 因为 &quot;leetcode&quot; 可以被拆分成 &quot;leet code&quot;。
</code></pre><p>示例 2：</p>
<pre><code>输入: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]
输出: true
解释: 返回 true 因为 &quot;applepenapple&quot; 可以被拆分成 &quot;apple pen apple&quot;。
     注意你可以重复使用字典中的单词。
</code></pre><p>示例 3：</p>
<pre><code>输入: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]
输出: false
</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h4 id="方法一-暴力"><a href="#方法一-暴力" class="headerlink" title="方法一  暴力"></a>方法一  暴力</h4><p>超时  </p>
<pre><code class="Java">class Solution {
    public boolean wordBreak(String s, List&lt;String&gt; wordDict) {
        if(s.length() == 0) return true;
        Set&lt;String&gt; set = new HashSet&lt;&gt;(wordDict);
        for(int i=1; i&lt;=s.length(); i++) {
            String sub = s.substring(0, i);
            if(set.contains(sub) &amp;&amp; wordBreak(s.substring(i), wordDict)) return true;
        }
        return false;
    }
}
</code></pre>
<h5 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ul>
<li>时间复杂度：O(n^n)。考虑最坏情况 ss = aaaaaaa 。每一个前缀都在字典中，此时回溯树的复杂度会达到 n^n。</li>
<li>空间复杂度：O(n)。回溯树的深度最深达到 n 。</li>
</ul>
<h4 id="方法二-记忆化回溯（剪枝）"><a href="#方法二-记忆化回溯（剪枝）" class="headerlink" title="方法二 记忆化回溯（剪枝）"></a>方法二 记忆化回溯（剪枝）</h4><p>在先前的方法中，我们看到许多函数调用都是冗余的，也就是我们会对相同的字符串调用多次回溯函数。为了避免这种情况，我们可以使用记忆化的方法，其中一个 memo 数组会被用来保存子问题的结果。每当访问到已经访问过的后缀串，直接用 memo 数组中的值返回而不需要继续调用函数。</p>
<p>通过记忆化，许多冗余的子问题可以极大被优化，回溯树得到了剪枝，因此极大减小了时间复杂度。</p>
<p>memo记录从i位置到结束的字符串能否满足条件<br>注意boolen[]默认为false，而Boolen[]默认为null</p>
<pre><code class="Java">class Solution {
    public boolean wordBreak(String s, List&lt;String&gt; wordDict) {
        Set&lt;String&gt; wordSet = new HashSet&lt;&gt;(wordDict);
        Boolean[] memo = new Boolean[s.length()];
        return helper(s, wordSet, memo, 0);
    }

    public boolean helper(String s, Set&lt;String&gt; wordSet, Boolean[] memo, int start) {
        if(start == s.length()) return true;
        if(memo[start] != null) return memo[start];
        for(int i=start; i&lt;s.length(); i++) {
            if(wordSet.contains(s.substring(start, i+1)) &amp;&amp; helper(s, wordSet, memo, i+1)) {
                memo[start] = true;
                return true;
            }
        }
        memo[start] = false;
        return false;
    }
}
</code></pre>
<h5 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ul>
<li><p>时间复杂度：O(n^2)。回溯树的大小最多达到 n^2。</p>
</li>
<li><p>空间复杂度：O(n)。回溯树的深度可以达到 n 级别。</p>
</li>
</ul>
<h4 id="方法三-动态规划"><a href="#方法三-动态规划" class="headerlink" title="方法三 动态规划"></a>方法三 动态规划</h4><pre><code class="Java">class Solution {
    public boolean wordBreak(String s, List&lt;String&gt; wordDict) {
        Set&lt;String&gt; set = new HashSet&lt;&gt;(wordDict);
        boolean[] dp = new boolean[s.length()+1];
        dp[0] = true;
        for(int i=1; i&lt;=s.length(); i++) {
            for(int j=0; j&lt;i; j++) {
                if(dp[j] &amp;&amp; set.contains(s.substring(j, i))) {
                    dp[i] = true;
                    break;
                }
            }
        }
        return dp[s.length()];
    }
}
</code></pre>
<h5 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ul>
<li><p>时间复杂度：O(n^2)。求出 dp 数组需要两重循环。</p>
</li>
<li><p>空间复杂度：O(n)。 dp 数组的长度是 n+1。</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述 ***&quot;&gt;&lt;/a&gt;题目描述 ***&lt;/h2&gt;&lt;p&gt;给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或
    
    </summary>
    
      <category term="LeetCode-Java" scheme="http://sunyang.xyz/categories/LeetCode-Java/"/>
    
    
      <category term="Java" scheme="http://sunyang.xyz/tags/Java/"/>
    
      <category term="LeetCode" scheme="http://sunyang.xyz/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>300. 最长上升子序列</title>
    <link href="http://sunyang.xyz/2019/10/30/LeetCode-Java/300.%20%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>http://sunyang.xyz/2019/10/30/LeetCode-Java/300. 最长上升子序列/</id>
    <published>2019-10-30T13:12:20.000Z</published>
    <updated>2019-11-13T09:14:15.436Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述 ****"></a>题目描述 ****</h2><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p>
<p>示例:</p>
<pre><code>输入: [10,9,2,5,3,7,101,18]
输出: 4 
解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。
</code></pre><p>说明:</p>
<ul>
<li>可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。</li>
<li>你算法的时间复杂度应该为 O(n^2) 。  </li>
</ul>
<p>进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗?</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h4 id="方法一-从后往前动态规划"><a href="#方法一-从后往前动态规划" class="headerlink" title="方法一  从后往前动态规划"></a>方法一  从后往前动态规划</h4><p>自己的方法，更容易理解<br>arr[]中存 以该点值作为起始元素，直到最后的最长递增序列的长度<br>[1, 2, 4, 3] 的arr为 [3, 2, 1, 1]</p>
<pre><code class="Java">class Solution {
    public int lengthOfLIS(int[] nums) {
        int res = 0;
        int[] arr = new int[nums.length];
        for(int i=nums.length-1; i&gt;=0; i--) {
            int curLen = 1;
            for(int j=i+1; j&lt;nums.length; j++) {
                if(nums[j] &gt; nums[i] &amp;&amp; arr[j]+1&gt; curLen) curLen = arr[j] + 1;
            }
            res = Math.max(res, curLen);
            arr[i] = curLen;
        }
        return res;
    }
}
</code></pre>
<h4 id="方法二-从前往后动态规划"><a href="#方法二-从前往后动态规划" class="headerlink" title="方法二  从前往后动态规划"></a>方法二  从前往后动态规划</h4><p>方法类似，dp[]中存 以该点为结尾元素的最长递增序列的长度。<br>[1, 2, 4, 3] 的dp为 [1, 2, 3, 3]</p>
<pre><code class="Java">class Solution {
    public int lengthOfLIS(int[] nums) {
        int[] dp = new int[nums.length];
        int res = 0;
        Arrays.fill(dp, 1);
        for(int i=0; i&lt;nums.length; i++) {
            for(int j=0; j&lt;i; j++) {
                if(nums[j] &lt; nums[i]) dp[i] = Math.max(dp[i], dp[j]+1);
            }
            res = Math.max(res, dp[i]);
        }
        return res;
    }
}
</code></pre>
<h4 id="方法三-动态规划-二分法"><a href="#方法三-动态规划-二分法" class="headerlink" title="方法三  动态规划+二分法 ****"></a>方法三  动态规划+二分法 ****</h4><p>题目要求时间复杂度O(nlogn)，联想二分法  </p>
<p>遍历数组，构造递增序列，每来一个新元素m，都要更新序列：二分法查找该递增序列，找出大于新元素m的第一个元素的位置，如果找到，则替换，此时并不会延长序列。只有在新元素大于序列中所有元素时，才会延长序列，将新元素插入序列尾部。</p>
<pre><code class="Java">class Solution {
    public int lengthOfLIS(int[] nums) {
        int[] dp = new int[nums.length];
        int res = 0;
        for(int num : nums) {
            int i=0, j=res;
            while(i &lt; j) {
                int m = (i+j)/2;
                if(dp[m] &lt; num) i = m+1;
                else j = m;
            }
            dp[i] = num;
            if(i == res) res++;
        }
        return res;
    }
}
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述 ****&quot;&gt;&lt;/a&gt;题目描述 ****&lt;/h2&gt;&lt;p&gt;给定一个无序的整数数组，找到其中最长上升子序列的长度。&lt;/p&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;pre&gt;&lt;cod
    
    </summary>
    
      <category term="LeetCode-Java" scheme="http://sunyang.xyz/categories/LeetCode-Java/"/>
    
    
      <category term="Java" scheme="http://sunyang.xyz/tags/Java/"/>
    
      <category term="LeetCode" scheme="http://sunyang.xyz/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>136. 只出现一次的数字</title>
    <link href="http://sunyang.xyz/2019/10/30/LeetCode-Java/136.%20%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>http://sunyang.xyz/2019/10/30/LeetCode-Java/136. 只出现一次的数字/</id>
    <published>2019-10-30T04:12:20.000Z</published>
    <updated>2019-11-13T09:14:18.821Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述 ***"></a>题目描述 ***</h2><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<p>说明：</p>
<p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>
<p>示例 1:</p>
<pre><code>输入: [2,2,1]
输出: 1
</code></pre><p>示例 2:</p>
<pre><code>输入: [4,1,2,1,2]
输出: 4
</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h4 id="方法一-HashMap"><a href="#方法一-HashMap" class="headerlink" title="方法一 HashMap"></a>方法一 HashMap</h4><p>要注意map的方法使用:<br>getOrDefault(), keySet(), values(), entrySet(), getKey(), getValue()  </p>
<pre><code class="Java">class Solution {
    public int singleNumber(int[] nums) {
        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();
        for(int i : nums) {
            map.put(i, map.getOrDefault(i, 0) + 1);
        }
        // for(Map.Entry&lt;Integer, Integer&gt; entry: map.entrySet()) {
        //     if(entry.getValue() == 1) return entry.getKey();
        // }
        for(int k : map.keySet()) {
            if(map.get(k) == 1) return k;
        }
        return -1;
    }
}
</code></pre>
<h4 id="方法二-HashSet"><a href="#方法二-HashSet" class="headerlink" title="方法二 HashSet"></a>方法二 HashSet</h4><p>set要比map方法用时短</p>
<pre><code class="Java">class Solution {
    public int singleNumber(int[] nums) {
        Set&lt;Integer&gt; set = new HashSet&lt;&gt;();
        for(int i:nums) {
            if(!set.contains(i)) set.add(i);
            else set.remove(i);
        }
        for(int i:set) return i;
        return -1;
    }
}
</code></pre>
<h4 id="方法三-异或"><a href="#方法三-异或" class="headerlink" title="方法三 异或 ***"></a>方法三 异或 ***</h4><p>唯一满足空间复杂度O(1)的方法<br>这种元素两两相同的题目，可以考虑异或！！！</p>
<pre><code class="Java">class Solution {
    public int singleNumber(int[] nums) {
        int res = 0;
        for(int i: nums) res ^= i;
        return res;
    }
}
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述 ***&quot;&gt;&lt;/a&gt;题目描述 ***&lt;/h2&gt;&lt;p&gt;给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。&lt;/p
    
    </summary>
    
      <category term="LeetCode-Java" scheme="http://sunyang.xyz/categories/LeetCode-Java/"/>
    
    
      <category term="Java" scheme="http://sunyang.xyz/tags/Java/"/>
    
      <category term="LeetCode" scheme="http://sunyang.xyz/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>128. 最长连续序列</title>
    <link href="http://sunyang.xyz/2019/10/30/LeetCode-Java/128.%20%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97/"/>
    <id>http://sunyang.xyz/2019/10/30/LeetCode-Java/128. 最长连续序列/</id>
    <published>2019-10-30T03:52:20.000Z</published>
    <updated>2019-11-13T09:14:23.922Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述 ***"></a>题目描述 ***</h2><p>给定一个未排序的整数数组，找出最长连续序列的长度。</p>
<p>要求算法的时间复杂度为 O(n)。</p>
<p>示例:</p>
<pre><code>输入: [100, 4, 200, 1, 3, 2]
输出: 4
解释: 最长连续序列是 [1, 2, 3, 4]。它的长度为 4。
</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这些数字用一个 HashSet 保存（或者用 Python 里的 Set），实现 O(1) 时间的查询，同时，我们只对 当前数字 - 1 不在哈希表里的数字，作为连续序列的第一个数字去找对应的最长序列，这是因为其他数字一定已经出现在了某个序列里。</p>
<pre><code class="Java">class Solution {
    public int longestConsecutive(int[] nums) {
        Set&lt;Integer&gt; set = new HashSet&lt;&gt;();
        int res = 0;
        for(int i : nums) set.add(i);
        for(int i : set) {
            if(!set.contains(i-1)) {
                int len = 1;
                while(set.contains(i+1)) {
                    i++;
                    len++;
                }
                res = Math.max(res, len);
            }
        }
        return res;
    }
}
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述 ***&quot;&gt;&lt;/a&gt;题目描述 ***&lt;/h2&gt;&lt;p&gt;给定一个未排序的整数数组，找出最长连续序列的长度。&lt;/p&gt;
&lt;p&gt;要求算法的时间复杂度为 O(n)。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode-Java" scheme="http://sunyang.xyz/categories/LeetCode-Java/"/>
    
    
      <category term="Java" scheme="http://sunyang.xyz/tags/Java/"/>
    
      <category term="LeetCode" scheme="http://sunyang.xyz/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>124. 二叉树中的最大路径和</title>
    <link href="http://sunyang.xyz/2019/10/28/LeetCode-Java/124.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/"/>
    <id>http://sunyang.xyz/2019/10/28/LeetCode-Java/124. 二叉树中的最大路径和/</id>
    <published>2019-10-28T07:52:20.000Z</published>
    <updated>2019-11-13T09:14:26.968Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述 ***"></a>题目描述 ***</h2><p>给定一个非空二叉树，返回其最大路径和。</p>
<p>本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。</p>
<p>示例 1:</p>
<pre><code>输入: [1,2,3]

       1
      / \
     2   3

输出: 6
</code></pre><p>示例 2:</p>
<pre><code>输入: [-10,9,20,null,null,15,7]

   -10
   / \
  9  20
    /  \
   15   7

输出: 42
</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h4 id="不够优雅"><a href="#不够优雅" class="headerlink" title="不够优雅"></a>不够优雅</h4><pre><code class="Java">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    int maxSum = Integer.MIN_VALUE;

    public int maxPathSum(TreeNode root) {
        helper(root);
        return maxSum;
    }

    // 返回包含根节点的单条路（直路）的最大值，并同时计算包含根节点的两条路（弯路）的最大值
    public int helper(TreeNode root) {
        int max = 0;
        if(root == null) return Integer.MIN_VALUE;
        int l = helper(root.left), r = helper(root.right);
        if(l &lt;= 0 &amp;&amp; r &lt;= 0) {
            max = root.val;
            maxSum = Math.max(maxSum, max);
            return root.val;
        }
        if(l &gt; 0 &amp;&amp; r &gt; 0) {
            max = root.val + l + r;
        }
        else {
            max = Math.max(l, r) + root.val;
        }
        maxSum = Math.max(maxSum, max);
        return Math.max(l, r) + root.val;
    }
}
</code></pre>
<h4 id="优雅"><a href="#优雅" class="headerlink" title="优雅"></a>优雅</h4><pre><code class="Java">class Solution {
    int res = Integer.MIN_VALUE;

    public int maxPathSum(TreeNode root) {
        helper(root);
        return res;
    }

    private int helper(TreeNode root) {
        if (root == null) return 0;
        int left = helper(root.left);
        int right = helper(root.right);
        res = Math.max(left + right + root.val, res);
        return Math.max(0, Math.max(left, right) + root.val);
    }
}
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述 ***&quot;&gt;&lt;/a&gt;题目描述 ***&lt;/h2&gt;&lt;p&gt;给定一个非空二叉树，返回其最大路径和。&lt;/p&gt;
&lt;p&gt;本题中，路径被定义为一条从树中任意节点出发，达到任意节
    
    </summary>
    
      <category term="LeetCode-Java" scheme="http://sunyang.xyz/categories/LeetCode-Java/"/>
    
    
      <category term="Java" scheme="http://sunyang.xyz/tags/Java/"/>
    
      <category term="LeetCode" scheme="http://sunyang.xyz/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>121. 买卖股票的最佳时机</title>
    <link href="http://sunyang.xyz/2019/10/24/LeetCode-Java/121.%20%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/"/>
    <id>http://sunyang.xyz/2019/10/24/LeetCode-Java/121. 买卖股票的最佳时机/</id>
    <published>2019-10-24T02:52:20.000Z</published>
    <updated>2019-11-13T09:14:29.986Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述 **"></a>题目描述 **</h2><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p>
<p>注意你不能在买入股票前卖出股票。</p>
<p>示例 1:</p>
<pre><code>输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。
</code></pre><p>示例 2:</p>
<pre><code>输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h4 id="两次遍历"><a href="#两次遍历" class="headerlink" title="两次遍历"></a>两次遍历</h4><pre><code class="Java">class Solution {
    public int maxProfit(int[] prices) {
        if(prices.length &lt;= 1) return 0;
        int[] profits = new int[prices.length];
        profits[0] = 0;
        for(int i = 1; i &lt; profits.length; i++) {
            profits[i] = prices[i] - prices[i-1];
        }
        int max = 0;
        int cur = 0;
        for(int i = 1; i &lt; profits.length; i++) {
            cur += profits[i];
            if(cur &lt;= 0) cur = 0;
            else max = Math.max(max, cur);
        }
        return max;
    }
}
</code></pre>
<h4 id="一次遍历"><a href="#一次遍历" class="headerlink" title="一次遍历"></a>一次遍历</h4><pre><code class="Java">class Solution {
    public int maxProfit(int[] prices) {
        if (prices == null || prices.length == 0) return 0;
        int cur_max = 0;
        int res = 0;
        for (int i = 1; i &lt; prices.length; i++) {
            cur_max += prices[i] - prices[i - 1];
            cur_max = Math.max(0, cur_max);
            res = Math.max(cur_max, res);
        }
        return res;
    }
}
</code></pre>
<h4 id="峰和谷"><a href="#峰和谷" class="headerlink" title="峰和谷"></a>峰和谷</h4><p>使我们感兴趣的点是上图中的峰和谷。我们需要找到最小的谷之后的最大的峰。<br>我们可以维持两个变量——minprice 和 maxprofit，它们分别对应迄今为止所得到的最小的谷值和最大的利润（卖出价格与最低价格之间的最大差值）。</p>
<pre><code class="Java">public class Solution {
    public int maxProfit(int prices[]) {
        int minprice = Integer.MAX_VALUE;
        int maxprofit = 0;
        for (int i = 0; i &lt; prices.length; i++) {
            if (prices[i] &lt; minprice)
                minprice = prices[i];
            else if (prices[i] - minprice &gt; maxprofit)
                maxprofit = prices[i] - minprice;
        }
        return maxprofit;
    }
}
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述 **&quot;&gt;&lt;/a&gt;题目描述 **&lt;/h2&gt;&lt;p&gt;给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。&lt;/p&gt;
&lt;p&gt;如果你最多只允许完成一笔交易（即
    
    </summary>
    
      <category term="LeetCode-Java" scheme="http://sunyang.xyz/categories/LeetCode-Java/"/>
    
    
      <category term="Java" scheme="http://sunyang.xyz/tags/Java/"/>
    
      <category term="LeetCode" scheme="http://sunyang.xyz/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>114. 二叉树展开为链表</title>
    <link href="http://sunyang.xyz/2019/10/24/LeetCode-Java/114.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/"/>
    <id>http://sunyang.xyz/2019/10/24/LeetCode-Java/114. 二叉树展开为链表/</id>
    <published>2019-10-24T01:52:20.000Z</published>
    <updated>2019-11-13T09:14:32.707Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述 ***"></a>题目描述 ***</h2><p>给定一个二叉树，原地将它展开为链表。</p>
<p>例如，给定二叉树</p>
<pre><code>    1
   / \
  2   5
 / \   \
3   4   6
</code></pre><p>将其展开为：</p>
<pre><code>1
 \
  2
   \
    3
     \
      4
       \
        5
         \
          6
</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h4 id="方法一-递归（自己的）"><a href="#方法一-递归（自己的）" class="headerlink" title="方法一 递归（自己的）"></a>方法一 递归（自己的）</h4><pre><code class="Java">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public void flatten(TreeNode root) {
        helper(root);
        return;
    }

    // 直接在root上展开，返回值是展开链表的最后一个节点
    public TreeNode helper(TreeNode root) {
        if(root == null) return null;
        if(root.left == null &amp;&amp; root.right == null) return root;
        TreeNode temp1 = helper(root.left);
        TreeNode temp2 = root.right;
        if(temp1 != null) {
            root.right = root.left;
            root.left = null;
            temp1.right = temp2;
        }
        if(temp2 == null) return temp1;
        else return helper(temp2);
    }
}
</code></pre>
<h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p>可以发现展开的顺序其实就是二叉树的先序遍历。算法和 94 题 中序遍历的 Morris 算法有些神似，我们需要两步完成这道题。</p>
<ol>
<li>将左子树插入到右子树的地方</li>
<li>将原来的右子树接到左子树的最右边节点</li>
<li>考虑新的右子树的根节点，一直重复上边的过程，直到新的右子树为 null  </li>
</ol>
<p>可以看图理解下这个过程。</p>
<pre><code>   1
   / \
  2   5
 / \   \
3   4   6

//将 1 的左子树插入到右子树的地方
    1
     \
      2         5
     / \         \
    3   4         6        
//将原来的右子树接到左子树的最右边节点
    1
     \
      2          
     / \          
    3   4  
         \
          5
           \
            6

 //将 2 的左子树插入到右子树的地方
    1
     \
      2          
       \          
        3       4  
                 \
                  5
                   \
                    6   

 //将原来的右子树接到左子树的最右边节点
    1
     \
      2          
       \          
        3      
         \
          4  
           \
            5
             \
              6
</code></pre><pre><code class="Java">public void flatten(TreeNode root) {
    while (root != null) { 
        //左子树为 null，直接考虑下一个节点
        if (root.left == null) {
            root = root.right;
        } else {
            // 找左子树最右边的节点
            TreeNode pre = root.left;
            while (pre.right != null) {
                pre = pre.right;
            } 
            //将原来的右子树接到左子树的最右边节点
            pre.right = root.right;
            // 将左子树插入到右子树的地方
            root.right = root.left;
            root.left = null;
            // 考虑下一个节点
            root = root.right;
        }
    }
}
</code></pre>
<h4 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h4><pre><code class="Java">private TreeNode pre = null;

public void flatten(TreeNode root) {
    if (root == null)
        return;
    flatten(root.right);
    flatten(root.left);
    root.right = pre;
    root.left = null;
    pre = root;
}
</code></pre>
<p>解析详见<a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by--26/" target="_blank" rel="external">leetcode</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述 ***&quot;&gt;&lt;/a&gt;题目描述 ***&lt;/h2&gt;&lt;p&gt;给定一个二叉树，原地将它展开为链表。&lt;/p&gt;
&lt;p&gt;例如，给定二叉树&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    
    
    </summary>
    
      <category term="LeetCode-Java" scheme="http://sunyang.xyz/categories/LeetCode-Java/"/>
    
    
      <category term="Java" scheme="http://sunyang.xyz/tags/Java/"/>
    
      <category term="LeetCode" scheme="http://sunyang.xyz/tags/LeetCode/"/>
    
  </entry>
  
</feed>
