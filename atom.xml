<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>轩箫的博客</title>
  <subtitle>不要懒惰</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://sunyang.xyz/"/>
  <updated>2019-10-07T13:50:18.686Z</updated>
  <id>http://sunyang.xyz/</id>
  
  <author>
    <name>轩箫</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>49. 字母异位词分组</title>
    <link href="http://sunyang.xyz/2019/10/06/LeetCode-Java/49.%20%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84/"/>
    <id>http://sunyang.xyz/2019/10/06/LeetCode-Java/49. 字母异位词分组/</id>
    <published>2019-10-06T06:51:20.000Z</published>
    <updated>2019-10-07T13:50:18.686Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述 **"></a>题目描述 <em>**</em></h2><p>给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。</p>
<p>示例:</p>
<pre><code>输入: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;],
输出:
[
  [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;],
  [&quot;nat&quot;,&quot;tan&quot;],
  [&quot;bat&quot;]
]
</code></pre><p>说明：</p>
<ul>
<li>所有输入均为小写字母。</li>
<li>不考虑答案输出的顺序。</li>
</ul>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h4 id="解法一-暴力"><a href="#解法一-暴力" class="headerlink" title="解法一 暴力"></a>解法一 暴力</h4><p>遍历每个字符串，判断与results中每组字符串是否异位。通过字符串中不同字母的个数来判断。</p>
<pre><code class="Java">class Solution {
    public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) {
        List&lt;List&lt;String&gt;&gt; results = new ArrayList&lt;&gt;();
        if(strs.length == 0) return results;
        List&lt;String&gt; l = new ArrayList&lt;String&gt;();
        l.add(strs[0]);
        results.add(l);
        for(int i=1; i&lt;strs.length; i++) {
            String s = strs[i];
            boolean exist = false;
            for(List&lt;String&gt; group : results) {
                if(isAnagrams(group.get(0), s)) {
                    group.add(s);
                    exist = true;
                    break;
                }
            }
            if(!exist) {
                List&lt;String&gt; list = new ArrayList&lt;String&gt;();
                list.add(s);
                results.add(list);
            }
        }
        return results;
    }
    public boolean isAnagrams(String a, String b) {
        if(a.length() != b.length()) return false;
        Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();
        for(int i = 0; i&lt;a.length(); i++) {
            char c = a.charAt(i);
            map.put(c, map.getOrDefault(c, 0) + 1);
        }
        for(int i=0; i&lt;b.length(); i++) {
            char c = b.charAt(i);
            if(map.containsKey(c) &amp;&amp; map.get(c) != 0) map.put(c, map.get(c)-1);
            else return false;
        }
        return true;
    }
}
</code></pre>
<h4 id="解法二-按排序字符串分类"><a href="#解法二-按排序字符串分类" class="headerlink" title="解法二 按排序字符串分类"></a>解法二 按排序字符串分类</h4><p><strong>当且仅当它们的排序字符串相等时，两个字符串是字母异位词。</strong><br>维护一个映射 ans : {String -&gt; List}，其中每个键ans是一个排序字符串，每个值是初始输入的字符串列表，排序后等于ans。</p>
<pre><code class="Java">class Solution {
    public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) {
        Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;&gt;();
        for(String s : strs) {
            char[] cs = s.toCharArray(); // (1) String to char[]
            Arrays.sort(cs); 
            String key = String.valueOf(cs); // (2) char[] to String
            if(map.containsKey(key)) map.get(key).add(s);
            else {
                List&lt;String&gt; list = new ArrayList&lt;&gt;();
                list.add(s);
                map.put(key, list);
            }
        }
        return new ArrayList(map.values());
    }
}
</code></pre>
<h5 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ul>
<li><p>时间复杂度：O(NKlogK)，其中 N 是 strs 的长度，而 K 是 strs 中字符串的最大长度。当我们遍历每个字符串时，外部循环具有的复杂度为 O(N)。然后，我们在 O(KlogK) 的时间内对每个字符串排序。</p>
</li>
<li><p>空间复杂度：O(NK)，排序存储在 ans 中的全部信息内容。</p>
</li>
</ul>
<h4 id="解法三-按字符计数分类"><a href="#解法三-按字符计数分类" class="headerlink" title="解法三 按字符计数分类"></a>解法三 按字符计数分类</h4><p><strong>当且仅当它们的字符计数（每个字符的出现次数）相同时，两个字符串是字母异位词。</strong><br>我们可以将每个字符串s 转换为字符数 count，由26个非负整数组成，表示 a，b，c 的数量等。我们使用这些计数作为哈希映射的基础。<br>在 Java 中，我们的字符数 count 的散列化表示将是一个用 <strong>＃</strong> 字符分隔的字符串。 例如，abbccc 将表示为 ＃1＃2＃3＃0＃0＃0 …＃0，其中总共有26个条目。</p>
<pre><code class="Java">class Solution {
    public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) {
        Map&lt;String, List&gt; map = new HashMap();
        for(String s : strs) {
            int[] count = new int[26];
            for(char c : s.toCharArray()) count[c-&#39;a&#39;]++;
            StringBuilder sb = new StringBuilder();
            for(int c : count) {
                sb.append(&#39;#&#39;);
                sb.append(c);
            }
            String newS = sb.toString();

            if(map.containsKey(newS)) map.get(newS).add(s);
            else {
                List&lt;String&gt; list = new ArrayList();
                list.add(s);
                map.put(newS, list);
            }
        }
        return new ArrayList(map.values());

    }
}
</code></pre>
<h5 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ul>
<li>时间复杂度：O(NK)，其中 N 是 strs 的长度，而 K 是 strs 中字符串的最大长度。计算每个字符串的字符串大小是线性的，我们统计每个字符串。</li>
<li>空间复杂度：O(NK)，排序存储在 ans 中的全部信息内容。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述 **&quot;&gt;&lt;/a&gt;题目描述 &lt;em&gt;**&lt;/em&gt;&lt;/h2&gt;&lt;p&gt;给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode-Java" scheme="http://sunyang.xyz/categories/LeetCode-Java/"/>
    
    
      <category term="Java" scheme="http://sunyang.xyz/tags/Java/"/>
    
      <category term="LeetCode" scheme="http://sunyang.xyz/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>48. 旋转图像</title>
    <link href="http://sunyang.xyz/2019/10/06/LeetCode-Java/48.%20%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/"/>
    <id>http://sunyang.xyz/2019/10/06/LeetCode-Java/48. 旋转图像/</id>
    <published>2019-10-06T02:51:20.000Z</published>
    <updated>2019-10-07T13:50:32.163Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述 *"></a>题目描述 <em>*</em></h2><p>给定一个 n × n 的二维矩阵表示一个图像。</p>
<p>将图像顺时针旋转 90 度。</p>
<p>说明：</p>
<p>你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。</p>
<p>示例 1:</p>
<pre><code>给定 matrix = 
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
],

原地旋转输入矩阵，使其变为:
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]
</code></pre><p>示例 2:</p>
<pre><code>给定 matrix =
[
  [ 5, 1, 9,11],
  [ 2, 4, 8,10],
  [13, 3, 6, 7],
  [15,14,12,16]
], 

原地旋转输入矩阵，使其变为:
[
  [15,13, 2, 5],
  [14, 3, 4, 1],
  [12, 6, 8, 9],
  [16, 7,10,11]
]
</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h4 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h4><p>一次转一步，分圈转，每圈转n次  </p>
<pre><code class="Java">class Solution {
    public void rotate(int[][] matrix) {
        int n = matrix.length;
        for(int round = 0; round &lt; n / 2; round++) {
            for(int step = 0; step &lt; n-2*round-1; step++) oneStep(matrix, round);
        }
        return;
    }
    public void oneStep(int[][] matrix, int round) {
        int n = matrix.length;
        int temp = matrix[round][round];
        for(int i1 = round; i1 &lt; n - round - 1; i1++) {
            matrix[i1][round] = matrix[i1+1][round];
        }
        for(int j2 = round; j2 &lt; n - round - 1; j2++) {
            matrix[n-round-1][j2] = matrix[n-round-1][j2+1];
        }
        for(int i3 = n-round-1; i3 &gt; round; i3--) {
            matrix[i3][n-round-1] = matrix[i3-1][n-round-1];
        }
        for(int j4 = n-round-1; j4 &gt; round+1; j4--) {
            matrix[round][j4] = matrix[round][j4-1];
        }
        matrix[round][round+1] = temp;
        return;
    }
}
</code></pre>
<h4 id="解法二-旋转四个矩形"><a href="#解法二-旋转四个矩形" class="headerlink" title="解法二 旋转四个矩形"></a>解法二 旋转四个矩形</h4><p>每圈转1次，一次转n步  </p>
<pre><code class="Java">class Solution {
    public void rotate(int[][] matrix) {
        if(matrix.length == 0 || matrix.length != matrix[0].length) {
            return;
        }
        int nums = matrix.length;
        int times = 0;
        while(times &lt;= (nums &gt;&gt; 1)){
            int len = nums - (times &lt;&lt; 1);
            for(int i = 0; i &lt; len - 1; ++i){
                int temp = matrix[times][times + i];
                matrix[times][times + i] = matrix[times + len - i - 1][times];
                matrix[times + len - i - 1][times] = matrix[times + len - 1][times + len - i - 1];
                matrix[times + len - 1][times + len - i - 1] = matrix[times + i][times + len - 1];
                matrix[times + i][times + len - 1] = temp;
            }
            ++times;
        }       
    }
}
</code></pre>
<h4 id="解法三-转置加翻转"><a href="#解法三-转置加翻转" class="headerlink" title="解法三 转置加翻转"></a>解法三 转置加翻转</h4><p>最直接的想法是先转置矩阵，然后翻转每一行。这个简单的方法已经能达到最优的时间复杂度O(N^2)。  </p>
<pre><code class="Java">class Solution {
  public void rotate(int[][] matrix) {
    int n = matrix.length;

    // transpose matrix
    for (int i = 0; i &lt; n; i++) {
      for (int j = i; j &lt; n; j++) {
        int tmp = matrix[j][i];
        matrix[j][i] = matrix[i][j];
        matrix[i][j] = tmp;
      }
    }
    // reverse each row
    for (int i = 0; i &lt; n; i++) {
      for (int j = 0; j &lt; n / 2; j++) {
        int tmp = matrix[i][j];
        matrix[i][j] = matrix[i][n - j - 1];
        matrix[i][n - j - 1] = tmp;
      }
    }
  }
}
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述 *&quot;&gt;&lt;/a&gt;题目描述 &lt;em&gt;*&lt;/em&gt;&lt;/h2&gt;&lt;p&gt;给定一个 n × n 的二维矩阵表示一个图像。&lt;/p&gt;
&lt;p&gt;将图像顺时针旋转 90 度。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode-Java" scheme="http://sunyang.xyz/categories/LeetCode-Java/"/>
    
    
      <category term="Java" scheme="http://sunyang.xyz/tags/Java/"/>
    
      <category term="LeetCode" scheme="http://sunyang.xyz/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>46. 全排列</title>
    <link href="http://sunyang.xyz/2019/10/05/LeetCode-Java/46.%20%E5%85%A8%E6%8E%92%E5%88%97/"/>
    <id>http://sunyang.xyz/2019/10/05/LeetCode-Java/46. 全排列/</id>
    <published>2019-10-05T14:51:20.000Z</published>
    <updated>2019-10-07T13:50:35.885Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述 **"></a>题目描述 **</h2><p>给定一个没有重复数字的序列，返回其所有可能的全排列。</p>
<p>示例:</p>
<pre><code>输入: [1,2,3]
输出:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>回溯法  </p>
<pre><code class="Java">class Solution {
    List&lt;List&lt;Integer&gt;&gt; results = new ArrayList&lt;&gt;();
    public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) {
        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
        for(int i:nums) list.add(i);
        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();
        backtrack(list, result);
        return results;
    }
    public void backtrack(List&lt;Integer&gt; list, List&lt;Integer&gt; result) {
        if(list.isEmpty()) {
            results.add(new ArrayList&lt;Integer&gt;(result)); //(1)
            return;
        }

        for(int i=0; i&lt;list.size(); i++) {
            // List&lt;Integer&gt; newList = new ArrayList&lt;&gt;(list);
            // List&lt;Integer&gt; newResult = new ArrayList&lt;&gt;(result);
            // newResult.add(newList.remove(i));
            // backtrack(newList, newResult);
            int temp = list.remove(i);
            result.add(temp);
            backtrack(list, result);
            list.add(i, temp);
            result.remove(result.size()-1);
        }
        return;
    }
}
</code></pre>
<p>两种方法，一是每次回溯函数传入的参数都重新生成（newList和newResult），这时最终的result不用重新生成，直接用参数就好（(1）处）。<br>二是不生成新list，移除之前要保存，执行完回溯函数再还原。这时，最终的result要新生成 。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述 **&quot;&gt;&lt;/a&gt;题目描述 **&lt;/h2&gt;&lt;p&gt;给定一个没有重复数字的序列，返回其所有可能的全排列。&lt;/p&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入:
    
    </summary>
    
      <category term="LeetCode-Java" scheme="http://sunyang.xyz/categories/LeetCode-Java/"/>
    
    
      <category term="Java" scheme="http://sunyang.xyz/tags/Java/"/>
    
      <category term="LeetCode" scheme="http://sunyang.xyz/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>42. 接雨水</title>
    <link href="http://sunyang.xyz/2019/10/05/LeetCode-Java/42.%20%E6%8E%A5%E9%9B%A8%E6%B0%B4/"/>
    <id>http://sunyang.xyz/2019/10/05/LeetCode-Java/42. 接雨水/</id>
    <published>2019-10-05T13:51:20.000Z</published>
    <updated>2019-10-07T13:50:38.964Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述 **"></a>题目描述 **</h2><p>图见 <a href="https://leetcode-cn.com/problems/trapping-rain-water" target="_blank" rel="external">链接</a><br>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。<br>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。</p>
<p>示例:</p>
<pre><code>输入: [0,1,0,2,1,0,1,3,2,1,2,1]
输出: 6
</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h4 id="解法一-动态规划"><a href="#解法一-动态规划" class="headerlink" title="解法一 动态规划"></a>解法一 动态规划</h4><p>我们注意到，解法二中。对于每一列，我们求它左边最高的墙和右边最高的墙，都是重新遍历一遍所有高度，这里我们可以优化一下。</p>
<p>首先用两个数组，max_left [i] 代表第 i 列左边最高的墙的高度，max_right[i] 代表第 i 列右边最高的墙的高度。（一定要注意下，第 i 列左（右）边最高的墙，是不包括自身的，和 leetcode 上边的讲的有些不同）</p>
<p>对于 max_left我们其实可以这样求。</p>
<p>max_left [i] = Max(max_left [i-1],height[i-1])。它前边的墙的左边的最高高度和它前边的墙的高度选一个较大的，就是当前列左边最高的墙了。</p>
<p>对于 max_right我们可以这样求。</p>
<p>max_right[i] = Max(max_right[i+1],height[i+1]) 。它后边的墙的右边的最高高度和它后边的墙的高度选一个较大的，就是当前列右边最高的墙了。</p>
<p>这样，我们再利用解法二的算法，就不用在 for 循环里每次重新遍历一次求 max_left 和 max_right 了。</p>
<pre><code class="Java">class Solution {
    public int trap(int[] height) {
        int n = height.length;
        int sum = 0;
        int[] maxLeft = new int[n];
        int[] maxRight = new int[n];
        for(int i=1; i&lt;n; i++) maxLeft[i] = Math.max(maxLeft[i-1], height[i-1]);
        for(int i=n-2; i&gt;=0; i--) maxRight[i] = Math.max(maxRight[i+1], height[i+1]);

        for(int i=1; i&lt;n-1; i++) {
            int h = Math.min(maxLeft[i], maxRight[i]);
            if(h &gt; height[i]) sum += h - height[i];
        }
        return sum;
    }
}
</code></pre>
<h4 id="解法二-双指针"><a href="#解法二-双指针" class="headerlink" title="解法二 双指针"></a>解法二 双指针</h4><p>类似于<a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="external">11. 盛最多水的容器</a></p>
<pre><code class="Java">class Solution {
    public int trap(int[] height) {
        if(height.length == 0) return 0;
        int l = 0, r = height.length-1;
        int maxL = height[l], maxR = height[r];
        int sum = 0;
        while(l &lt; r) {
            if(height[l] &lt;= height[r]) {
                // 此时height[r]是最大值，也一定比maxL大
                if(height[l] &lt; maxL) sum += maxL - height[l];
                else if(height[l] &gt; maxL) maxL = height[l];
                l++;
            }
            else {
                // 此时height[l]是最大值，也一定比maxR大
                if(height[r] &lt; maxR) sum += maxR - height[r];
                else if(height[r] &gt; maxR) maxR = height[r];
                r--;
            }
        }
        return sum;
    }
}
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述 **&quot;&gt;&lt;/a&gt;题目描述 **&lt;/h2&gt;&lt;p&gt;图见 &lt;a href=&quot;https://leetcode-cn.com/problems/trapping-ra
    
    </summary>
    
      <category term="LeetCode-Java" scheme="http://sunyang.xyz/categories/LeetCode-Java/"/>
    
    
      <category term="Java" scheme="http://sunyang.xyz/tags/Java/"/>
    
      <category term="LeetCode" scheme="http://sunyang.xyz/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>39. 组合总和</title>
    <link href="http://sunyang.xyz/2019/10/05/LeetCode-Java/39.%20%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/"/>
    <id>http://sunyang.xyz/2019/10/05/LeetCode-Java/39. 组合总和/</id>
    <published>2019-10-05T12:51:20.000Z</published>
    <updated>2019-10-07T13:50:41.852Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述 **"></a>题目描述 **</h2><p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。<br>candidates 中的数字可以无限制重复被选取。<br>说明：</p>
<ul>
<li>所有数字（包括 target）都是正整数。</li>
<li>解集不能包含重复的组合。  </li>
</ul>
<p>示例 1:</p>
<pre><code>输入: candidates = [2,3,6,7], target = 7,
所求解集为:
[
  [7],
  [2,2,3]
]
</code></pre><p>示例 2:</p>
<pre><code>输入: candidates = [2,3,5], target = 8,
所求解集为:
[
  [2,2,2,2],
  [2,3,3],
  [3,5]
]
</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><pre><code class="Java">class Solution {
    List&lt;List&lt;Integer&gt;&gt; results = new ArrayList&lt;&gt;();

    public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) {
        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();
        backtrack(candidates, 0, target, result);
        return results;
    }

    public void backtrack(int[] candidates, int p, int target, List&lt;Integer&gt; result) {
        if(target == 0) {
            results.add(result);
            return;
        }
        if(p &gt;= candidates.length) return;

        for(int i=0; i&lt;=target/candidates[p]; i++) {
            // 每次回溯都要建立新list！！！
            List&lt;Integer&gt; newResult = new ArrayList&lt;&gt;(result);
            for(int j=0; j&lt;i; j++) newResult.add(candidates[p]);
            backtrack(candidates, p+1, target-candidates[p]*i, newResult);
        }
        return;
    }
}
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述 **&quot;&gt;&lt;/a&gt;题目描述 **&lt;/h2&gt;&lt;p&gt;给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有
    
    </summary>
    
      <category term="LeetCode-Java" scheme="http://sunyang.xyz/categories/LeetCode-Java/"/>
    
    
      <category term="Java" scheme="http://sunyang.xyz/tags/Java/"/>
    
      <category term="LeetCode" scheme="http://sunyang.xyz/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>34. 在排序数组中查找元素的第一个和最后一个位置</title>
    <link href="http://sunyang.xyz/2019/10/05/LeetCode-Java/34.%20%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/"/>
    <id>http://sunyang.xyz/2019/10/05/LeetCode-Java/34. 在排序数组中查找元素的第一个和最后一个位置/</id>
    <published>2019-10-05T08:51:20.000Z</published>
    <updated>2019-10-07T13:50:45.381Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述 **"></a>题目描述 **</h2><p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p>
<p>你的算法时间复杂度必须是 O(log n) 级别。</p>
<p>如果数组中不存在目标值，返回 [-1, -1]。</p>
<p>示例 1:</p>
<pre><code>输入: nums = [5,7,7,8,8,10], target = 8
输出: [3,4]
</code></pre><p>示例 2:</p>
<pre><code>输入: nums = [5,7,7,8,8,10], target = 6
输出: [-1,-1]
</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><pre><code class="Java">class Solution {
    public int[] searchRange(int[] nums, int target) {
        int[] result = {-1, -1};
        if(nums.length == 0) return result;

        // 找左边界
        int l = 0, r = nums.length - 1;
        while(l &lt;= r) {
            int mid = (l + r) / 2;
            if(nums[mid] == target) r = mid - 1;
            else if(nums[mid] &lt; target) l = mid + 1;
            else if(nums[mid] &gt; target) r = mid - 1;
        }
        if(l &lt;= nums.length-1 &amp;&amp; nums[l] == target) result[0] = l;
        else return result;

        // 找右边界
        l = 0; r = nums.length - 1;
        while(l &lt;= r) {
            int mid = (l + r) / 2;
            if(nums[mid] == target) l = mid + 1;
            else if(nums[mid] &lt; target) l = mid + 1;
            else if(nums[mid] &gt; target) r = mid - 1;
        }
        if(r &gt;= 0 &amp;&amp; nums[r] == target) result[1] = r;
        return result;
    }
}
</code></pre>
<h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p>注意二分查找的边界值<br>详见题解中的<a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/er-fen-cha-zhao-suan-fa-xi-jie-xiang-jie-by-labula/" target="_blank" rel="external">二分查找算法细节详解</a></p>
<blockquote>
<p>我这里把 “找左边界” 和 “找右边界” 统一成了用闭区间的形式去实现，从语意上感觉更方便理解和记忆。需要注意的是，原本 “闭区间法” 的特性是，跳出循环时，必有left - 1 = right。此时，若存在target，则恰有right处于右边界，left处于左边界。<br>另外，这里left = mid + 1 和 right = mid - 1 都是运用“闭区间”的概念获得的。</p>
</blockquote>
<pre><code class="Python">class Solution(object):
    def searchRange(self, nums, target):
        return [self.left_bound(nums,target), self.right_bound(nums,target)]

    def right_bound(self, nums, target):
        if len(nums) == 0:
            return -1
        left, right = 0, len(nums) - 1
        while left &lt;= right:
            mid = (left + right) // 2
            if nums[mid] == target:
                left = mid + 1
            elif nums[mid] &lt; target:
                left = mid + 1
            elif nums[mid] &gt; target:
                right = mid - 1
        if right &gt;= 0 and nums[right] == target: return right # 注意
        else: return -1

    def left_bound(self, nums, target):
        if len(nums) == 0:
            return -1
        left, right = 0, len(nums) - 1

        while left &lt;= right:
            mid = (left + right) // 2
            if nums[mid] == target:
                right = mid - 1
            elif nums[mid] &lt; target:
                left = mid + 1
            elif nums[mid] &gt; target:
                right = mid - 1
        if left &lt;= len(nums)-1 and nums[left] == target: return left  # 注意
        else: return -1
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述 **&quot;&gt;&lt;/a&gt;题目描述 **&lt;/h2&gt;&lt;p&gt;给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置
    
    </summary>
    
      <category term="LeetCode-Java" scheme="http://sunyang.xyz/categories/LeetCode-Java/"/>
    
    
      <category term="Java" scheme="http://sunyang.xyz/tags/Java/"/>
    
      <category term="LeetCode" scheme="http://sunyang.xyz/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>33. 搜索旋转排序数组</title>
    <link href="http://sunyang.xyz/2019/10/05/LeetCode-Java/33.%20%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <id>http://sunyang.xyz/2019/10/05/LeetCode-Java/33. 搜索旋转排序数组/</id>
    <published>2019-10-05T07:51:20.000Z</published>
    <updated>2019-10-07T13:50:48.567Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述 *"></a>题目描述 <em>*</em></h2><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p>
<p>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。</p>
<p>你可以假设数组中不存在重复的元素。</p>
<p>你的算法时间复杂度必须是 O(log n) 级别。</p>
<p>示例 1:</p>
<pre><code>输入: nums = [4,5,6,7,0,1,2], target = 0
输出: 4
</code></pre><p>示例 2:</p>
<pre><code>输入: nums = [4,5,6,7,0,1,2], target = 3
输出: -1
</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>由于题目要求时间复杂度为 O(log n)，故实现为二分法查找，关于二分法，一般存在 low,high,mid位，来辅助判断。</p>
<ul>
<li>如果 target 在[mid+1,high] 序列中，则low = mid+1,否则 high = mid,关键是如何判断 target在[mid+1,high]序列中,具体判断如下：</li>
<li>当[0, mid] 序列是升序: nums[0] &lt;= nums[mid], 当target &gt; nums[mid] || target &lt; nums[0] ,则向后规约</li>
<li>当[0, mid] 序列存在旋转位: nums[0] &gt; nums[mid],当target &lt; nums[0] &amp;&amp; target &gt; nums[mid],则向后规约</li>
<li>当然其他其他情况就是向前规约了  </li>
</ul>
<p>循环判断，直到排除到只剩最后一个元素时，退出循环，如果该元素和 target 相同，直接返回下标，否则返回 -1。</p>
<pre><code class="Java">class Solution {
    public int search(int[] nums, int target) {
        if(nums.length == 0) return -1;
        int l = 0, r = nums.length-1;
        while(l &lt; r) {
            int mid = (l + r) / 2;
            if(nums[l] &lt;= nums[mid] &amp;&amp; (nums[l] &gt; target || nums[mid] &lt; target)) l = mid + 1;
            else if(nums[l] &gt; target &amp;&amp; nums[mid] &lt; target) l = mid + 1;
            else r = mid;
        }
        if(target == nums[l]) return l;
        else return -1;
    }
}
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述 *&quot;&gt;&lt;/a&gt;题目描述 &lt;em&gt;*&lt;/em&gt;&lt;/h2&gt;&lt;p&gt;假设按照升序排序的数组在预先未知的某个点上进行了旋转。&lt;/p&gt;
&lt;p&gt;( 例如，数组 [0,1,2
    
    </summary>
    
      <category term="LeetCode-Java" scheme="http://sunyang.xyz/categories/LeetCode-Java/"/>
    
    
      <category term="Java" scheme="http://sunyang.xyz/tags/Java/"/>
    
      <category term="LeetCode" scheme="http://sunyang.xyz/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>32. 最长有效括号</title>
    <link href="http://sunyang.xyz/2019/10/05/LeetCode-Java/32.%20%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/"/>
    <id>http://sunyang.xyz/2019/10/05/LeetCode-Java/32. 最长有效括号/</id>
    <published>2019-10-05T02:51:20.000Z</published>
    <updated>2019-10-07T13:50:51.440Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述  **"></a>题目描述  <em>**</em></h2><p>给定一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长的包含有效括号的子串的长度。</p>
<p>示例 1:</p>
<pre><code>输入: &quot;(()&quot;
输出: 2
解释: 最长有效括号子串为 &quot;()&quot;
</code></pre><p>示例 2:</p>
<pre><code>输入: &quot;)()())&quot;
输出: 4
解释: 最长有效括号子串为 &quot;()()&quot;
</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h4 id="解法一-栈"><a href="#解法一-栈" class="headerlink" title="解法一 栈"></a>解法一 栈</h4><p>栈中保存左括号的下标，右括号出栈</p>
<h5 id="错误代码！"><a href="#错误代码！" class="headerlink" title="错误代码！"></a>错误代码！</h5><pre><code class="Java">/* 
错误代码！
输入: &quot;)()())&quot;
输出: 2
预期结果：4
*/
class Solution {
    public int longestValidParentheses(String s) {
        Deque&lt;Integer&gt; stack = new ArrayDeque&lt;&gt;();
        int maxLength = 0;
        for(int i=0; i&lt;s.length(); i++) {
            if(s.charAt(i) == &#39;(&#39;) {
                stack.push(i);
            }
            else if(!stack.isEmpty()) {
                int j = stack.pop();
                int curLength = i - j + 1;
                maxLength = Math.max(maxLength, curLength);
            }
        }
        return maxLength;
    }
}
</code></pre>
<p>需要在左括号加一个界限，避免左括号出栈时丢失当前最长串的开始位置。<br>右括号出现有两种情况，一是右括号数大于左括号，有效串结束，出栈时除了把所有左括号出栈，还会把有效串开始位置出栈。下一个有效串的开始位置改变，要把当前位置进栈作为开始位置。<br>二是右括号小于或等于左括号，有效串未结束，相同数量的左括号出栈，栈中仍有有效串开始位置，有效串长度增加，可直接计算。</p>
<pre><code class="Java">class Solution {
    public int longestValidParentheses(String s) {
        Deque&lt;Integer&gt; stack = new ArrayDeque&lt;&gt;();
        int maxLength = 0;
        stack.push(-1);
        for(int i=0; i&lt;s.length(); i++) {
            if(s.charAt(i) == &#39;(&#39;) {
                stack.push(i);
            }
            else {
                stack.pop();
                if(stack.isEmpty()) {
                    stack.push(i);
                }
                else {
                    maxLength = Math.max(maxLength, i-stack.peek());
                }
            }
        }
        return maxLength;
    }
}
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述  **&quot;&gt;&lt;/a&gt;题目描述  &lt;em&gt;**&lt;/em&gt;&lt;/h2&gt;&lt;p&gt;给定一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长的包含有效括号的子串的长度。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode-Java" scheme="http://sunyang.xyz/categories/LeetCode-Java/"/>
    
    
      <category term="Java" scheme="http://sunyang.xyz/tags/Java/"/>
    
      <category term="LeetCode" scheme="http://sunyang.xyz/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>31. 下一个排列</title>
    <link href="http://sunyang.xyz/2019/10/04/LeetCode-Java/31.%20%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/"/>
    <id>http://sunyang.xyz/2019/10/04/LeetCode-Java/31. 下一个排列/</id>
    <published>2019-10-04T14:51:20.000Z</published>
    <updated>2019-10-07T13:50:54.844Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述 **"></a>题目描述 **</h2><p>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</p>
<p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p>
<p>必须原地修改，只允许使用额外常数空间。</p>
<p>以下是一些例子，输入位于左侧列，其相应输出位于右侧列。<br>1,2,3 → 1,3,2<br>3,2,1 → 1,2,3<br>1,1,5 → 1,5,1</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><ol>
<li>从后往前扫描找到第一个下标i,使得nums[i] &lt; nums[i + 1];</li>
<li>若i = -1，表示该数组为单调递减序列;否则，从后往前扫描找到找到第一个下标j使得nums[j] &gt; nums[i]，交换两数且不破坏nums(i, nums.length)的单调性；</li>
<li>翻转nums(i, nums.length)使其成为单调增序列。</li>
</ol>
<pre><code class="Java">class Solution {
    public void nextPermutation(int[] nums) {
        int i = nums.length - 1;
        int temp;
        while(i &gt; 0) {
            if(nums[i-1] &lt; nums[i]) break;
            i--;
        }
        if(i == 0) {
            // 输入排列为从大到小，需反转为从小到大
            for(int l = 0, r = nums.length-1; l &lt; r; l++, r--) {
                swap(nums, l, r);
            }
            return;
        }
        i = i-1;
        // 从后往前找出第一个比nums[i]大的数，交换
        int j=nums.length-1;
        while(nums[j] &lt;= nums[i]) j--;
        swap(nums, i, j);

        // 反转后面的元素，使其最小
        for(int l=i+1, r=nums.length-1; l&lt;r; l++, r--) {
            swap(nums, l, r);
        }
        return;
    }
    public void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述 **&quot;&gt;&lt;/a&gt;题目描述 **&lt;/h2&gt;&lt;p&gt;实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。&lt;/p&gt;
&lt;p&gt;如果不存在下
    
    </summary>
    
      <category term="LeetCode-Java" scheme="http://sunyang.xyz/categories/LeetCode-Java/"/>
    
    
      <category term="Java" scheme="http://sunyang.xyz/tags/Java/"/>
    
      <category term="LeetCode" scheme="http://sunyang.xyz/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>23. 合并K个排序链表</title>
    <link href="http://sunyang.xyz/2019/10/04/LeetCode-Java/23.%20%E5%90%88%E5%B9%B6K%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <id>http://sunyang.xyz/2019/10/04/LeetCode-Java/23. 合并K个排序链表/</id>
    <published>2019-10-04T12:51:20.000Z</published>
    <updated>2019-10-07T13:50:59.169Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述 *"></a>题目描述 <em>*</em></h2><p>合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</p>
<p>示例:</p>
<pre><code>输入:
[
  1-&gt;4-&gt;5,
  1-&gt;3-&gt;4,
  2-&gt;6
]
输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6
</code></pre><h2 id="题解（注意各种算法的复杂度分析）"><a href="#题解（注意各种算法的复杂度分析）" class="headerlink" title="题解（注意各种算法的复杂度分析）"></a>题解（注意各种算法的复杂度分析）</h2><h4 id="方法一-暴力法"><a href="#方法一-暴力法" class="headerlink" title="方法一 暴力法"></a>方法一 暴力法</h4><ul>
<li>遍历所有链表，将所有节点的值放到一个数组中。</li>
<li>将这个数组排序，然后遍历所有元素得到正确顺序的值。</li>
<li>用遍历得到的值，创建一个新的有序链表。  </li>
</ul>
<h5 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ul>
<li>时间复杂度：O(NlogN) ，其中N是节点的总数目。<ul>
<li>遍历所有的值需花费 O(N) 的时间。</li>
<li>一个稳定的排序算法花费 O(NlogN) 的时间。</li>
<li>遍历同时创建新的有序链表花费 O(N)O(N) 的时间。</li>
</ul>
</li>
<li>空间复杂度：O(N) 。<ul>
<li>排序花费O(N)空间（这取决于你选择的算法）。</li>
<li>创建一个新的链表花费 O(N) 的空间。</li>
</ul>
</li>
</ul>
<h4 id="方法二-逐一比较"><a href="#方法二-逐一比较" class="headerlink" title="方法二 逐一比较"></a>方法二 逐一比较</h4><h5 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h5><ul>
<li>比较k 个节点（每个链表的首节点），获得最小值的节点。</li>
<li>将选中的节点接在最终有序链表的后面。</li>
</ul>
<h5 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ul>
<li>时间复杂度： O(kN) ，其中k是链表的数目。<ul>
<li>几乎最终有序链表中每个节点的时间开销都为 O(k) （k-1 次比较）。</li>
<li>总共有 N 个节点在最后的链表中。</li>
</ul>
</li>
<li>空间复杂度：<ul>
<li>O(n) 。创建一个新的链表空间开销为 O(n) 。</li>
<li>O(1) 。重复利用原来的链表节点，每次选择节点时将它直接接在最后返回的链表后面，而不是创建一个新的节点。</li>
</ul>
</li>
</ul>
<h4 id="方法三-优先队列"><a href="#方法三-优先队列" class="headerlink" title="方法三 优先队列"></a>方法三 优先队列</h4><pre><code class="Java">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        if(lists.length == 0) return null;
        Queue&lt;ListNode&gt; queue = new PriorityQueue&lt;&gt;(new ListNodeComparator());
        // 也可以不自定义Comparator，采用更简洁的方法
        // Queue&lt;ListNode&gt; queue = new PriorityQueue&lt;&gt;(Comparator.comparingInt(node -&gt; node.val));

        for(ListNode l : lists) 
            if(l != null) queue.offer(l);

        ListNode result = new ListNode(-1);
        ListNode temp = result;
        while(!queue.isEmpty()) {
            int curValue = queue.peek().val;
            // 可以不与自身比较，直接插入优先队列中来排序。这里为了减少部分插入移出队列的开销，加入了与自身比较。但时间复杂度是同数量级的。
            while(temp.next != null &amp;&amp; temp.next.val &lt;= curValue) temp = temp.next;
            if(temp.next != null) queue.offer(temp.next);
            temp.next = queue.poll();
        }
        return result.next;
    }

    class ListNodeComparator implements Comparator&lt;ListNode&gt; {
        public int compare(ListNode l1, ListNode l2) {
            if(l1.val &lt; l2.val) return -1;
            else if(l1.val &gt; l2.val) return 1;
            else return 0;
        }
    }
}
</code></pre>
<ul>
<li>放入PriorityQueue的元素，必须实现Comparable接口，PriorityQueue会根据元素的排序顺序决定出队的优先级。如果我们要放入的元素并没有实现Comparable接口怎么办？PriorityQueue允许我们提供一个Comparator对象来判断两个元素的顺序。</li>
</ul>
<h5 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ul>
<li>时间复杂度： O(Nlogk) ，其中k是链表的数目。<ul>
<li>弹出操作时，比较操作的代价会被优化到 O(logk) 。同时，找到最小值节点的时间开销仅仅为 O(1)。</li>
<li>最后的链表中总共有 N 个节点。</li>
</ul>
</li>
<li>空间复杂度：<ul>
<li>O(n) 。创造一个新的链表需要 O(n) 的开销。</li>
<li>O(k) 。以上代码采用了重复利用原有节点，所以只要O(1)的空间。同时优先队列（通常用堆实现）需要O(k) 的空间（远比大多数情况的 N要小）。</li>
</ul>
</li>
</ul>
<h4 id="方法四-逐一两两合并链表"><a href="#方法四-逐一两两合并链表" class="headerlink" title="方法四 逐一两两合并链表"></a>方法四 逐一两两合并链表</h4><h5 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ul>
<li>时间复杂度：O(kN), 其中k是链表的数目。</li>
<li>空间复杂度：O(1)</li>
</ul>
<h4 id="方法五-分治合并链表"><a href="#方法五-分治合并链表" class="headerlink" title="方法五 分治合并链表"></a>方法五 分治合并链表</h4><h5 id="复杂度分析-4"><a href="#复杂度分析-4" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ul>
<li>时间复杂度：O(Nlogk)</li>
<li>空间复杂度：O(1)</li>
</ul>
<blockquote>
<p>分治的聚合次数不是logK次，是K-1次，每次聚合只会减少一个链表，聚合K-1次得到最终链表。 无论是分治法还是逐一聚合法都是如此。</p>
<p>两个链表聚合确实发生了K-1次。但是注意，题解中把 K个链表两两聚合，生成K/2个链表的过程叫一次Merging。然后这样的Merging总共发生log(K)次。每一次Merging需要比较的次数是N。 所以总的时间复杂度是O(N<em>log(K))。 这才是两两聚合和逐一聚合的本质差别。 逐一聚合的情况下，两个聚合的链表长度会发生偏斜，其中一个链表长度越来越长。考虑最坏情况K个链表每个仅包含一个元素（N为总元素数，这里N=K)，那么逐一聚合的总复杂度就是O(1+2+3+…N-1) = O(K</em>N). 而两两聚合的情况下，仍然考虑刚才的例子，<br>第一轮K个链表，聚合完成后剩K/2个，发生的比较次数是 1 + 1 + 1 + …+ 1 =1<em>K = N.<br>第二轮K/2个链表，聚合完成后剩K/4个，发生的比较次数是(最坏情况) 2+2+2+ … + 2 = 2 </em> K/2 = N .<br>第三轮K/4个链表，聚合完成后剩K/8个，发生的比较次数 4 + 4 + 4 + …. + 4 = 4 <em> K/4 = N .<br>…..<br>最后一轮剩2个链表，比较次数 K/2 + K/2 = 2</em> K/2 = N .<br>总共有log(K)轮，总比较次数 N*log(K)</p>
</blockquote>
<pre><code class="Java">class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        if(lists.length == 0) return null;
        return solve(lists, 0, lists.length-1);
    }

    private ListNode solve(ListNode[] arr, int left, int right){
        if(left == right) return arr[left];

        int mid = (left + right) &gt;&gt; 1; 
        ListNode lNode = solve(arr, left, mid);   
        ListNode rNode = solve(arr, mid+1, right); 

        return merge(lNode, rNode);
    }

    private ListNode merge(ListNode node1, ListNode node2){
        if(node1 == null) return node2;
        if(node2 == null) return node1;

        if(node1.val &lt; node2.val){
            node1.next = merge(node1.next, node2);
            return node1;
        }else{
            node2.next = merge(node1, node2.next);
            return node2;
        }
    }
}
</code></pre>
<p>典型的归并分治思想，自底向上，依次合并(可结合归并排序理解，将每个链表理解成排序的值)</p>
<p>分治法：</p>
<ol>
<li>分解原问题为若干个子问题，这些子问题是原问题的规模较小的实例；</li>
<li>解决这些子问题，递归地求解各子问题的规模足够小，则直接求解；</li>
<li>合并这些子问题的解即可得到原问题的解。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述 *&quot;&gt;&lt;/a&gt;题目描述 &lt;em&gt;*&lt;/em&gt;&lt;/h2&gt;&lt;p&gt;合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。&lt;/p&gt;
&lt;p&gt;示例:&lt;/p
    
    </summary>
    
      <category term="LeetCode-Java" scheme="http://sunyang.xyz/categories/LeetCode-Java/"/>
    
    
      <category term="Java" scheme="http://sunyang.xyz/tags/Java/"/>
    
      <category term="LeetCode" scheme="http://sunyang.xyz/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>22. 括号生成</title>
    <link href="http://sunyang.xyz/2019/10/04/LeetCode-Java/22.%20%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/"/>
    <id>http://sunyang.xyz/2019/10/04/LeetCode-Java/22. 括号生成/</id>
    <published>2019-10-04T07:51:20.000Z</published>
    <updated>2019-10-04T09:40:49.007Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述 **"></a>题目描述 <em>**</em></h2><p>给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。</p>
<p>例如，给出 n = 3，生成结果为：</p>
<pre><code>[
  &quot;((()))&quot;,
  &quot;(()())&quot;,
  &quot;(())()&quot;,
  &quot;()(())&quot;,
  &quot;()()()&quot;
]
</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h4 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h4><p>回溯？<br>将n个左括号放入list中，探索n个右括号可以插入的位置。要保证右括号数不能多于其左边的左括号数。第一个左括号后面只能跟一个右括号，而第n个左括号后面最多可以跟n个右括号。<br>所以，用回溯法从后往前遍历所有情况。</p>
<pre><code class="Java">class Solution {
    List&lt;String&gt; results = new ArrayList&lt;&gt;();
    public List&lt;String&gt; generateParenthesis(int n) {
        List&lt;String&gt; list = new ArrayList&lt;&gt;();
        for(int i=0; i&lt;n; i++) list.add(&quot;(&quot;);
        insert(list, n, n);
        // 开始时最后面（n的位置）留下n个右括号
        return results;
    }

    // 当前位置p剩下的可插入右括号数目n
    public void insert (List&lt;String&gt; list, int p, int n) {
        if(n == 0) {
            results.add(String.join(&quot;&quot;, list));
            // List&lt;String&gt; to String
            return;
        }
        if(n &gt; p) {
            return;
        }

        for(int i=0; i&lt;=n; i++) {

            List&lt;String&gt; newList = new ArrayList&lt;&gt;(list);
            // 当前位置插入i个右括号
            for(int j=0; j&lt;i; j++){
                newList.add(p, &quot;)&quot;);
            }
            // 前一位置可插入的右括号数
            insert(newList, p-1, n-i);
        };
    }
}
</code></pre>
<h4 id="解法二"><a href="#解法二" class="headerlink" title="解法二 *"></a>解法二 *</h4><p>如果我们还剩一个位置，我们可以开始放一个左括号。 如果它不超过左括号的数量，我们可以放一个右括号。</p>
<pre><code class="Java">class Solution {
    List&lt;String&gt; results = new ArrayList&lt;&gt;();
    public List&lt;String&gt; generateParenthesis(int n) {
        backtrack(&quot;&quot;, 0, 0, n);
        return results;
    }
    public void backtrack(String cur, int left, int right, int n) {
        if(left == n &amp;&amp; right == n) {
            results.add(cur);
            return;
        }
        if(left &lt; n) backtrack(cur+&quot;(&quot;, left+1, right, n);
        if(right &lt; left) backtrack(cur+&quot;)&quot;, left, right+1, n);
    }
}
</code></pre>
<h4 id="解法三"><a href="#解法三" class="headerlink" title="解法三 *"></a>解法三 *</h4><p>当我们清楚所有i&lt; n时括号的可能生成排列后，对与 i=n 的情况，我们考虑整个括号排列中最左边的括号。<br>它一定是一个左括号，那么它可以和它对应的右括号组成一组完整的括号”()”，我们认为这一组是相比 n-1 增加进来的括号。</p>
<p>那么，剩下 n-1 组括号有可能在哪呢？</p>
<p>【这里是重点，请着重理解】</p>
<p>剩下的括号要么在这一组新增的括号内部，要么在这一组新增括号的外部（右侧）。</p>
<p>既然知道了 i &lt; n 的情况，那我们就可以对所有情况进行遍历：</p>
<p>“(“ + 【i=p时所有括号的排列组合】 + “)” + 【i=q时所有括号的排列组合】</p>
<p>其中 p + q = n-1，且 p q 均为非负整数。</p>
<p>事实上，当上述 p 从 0 取到 n-1，q 从 n-1 取到 0 后，所有情况就遍历完了。</p>
<p>注：上述遍历是没有重复情况出现的，即当 (p1,q1)≠(p2,q2) 时，按上述方式取的括号组合一定不同。</p>
<pre><code class="Java">class Solution {
    public List&lt;String&gt; generateParenthesis(int n) {
        List&lt;List&lt;String&gt;&gt; results = new ArrayList&lt;&gt;();
        List&lt;String&gt; list0 = new ArrayList&lt;&gt;();
        list0.add(&quot;&quot;);
        results.add(list0);

        for(int i=1; i&lt;=n; i++) { // i对括号可生成的排列
            List&lt;String&gt; newList = new ArrayList&lt;&gt;();
            for(int j=0; j&lt;=i-1; j++) { // 括号内的括号对数j
                List&lt;String&gt; leftList = results.get(j);
                List&lt;String&gt; rightList = results.get(i-j-1);
                for(String s1:leftList) {
                    for(String s2:rightList) {
                        newList.add(&quot;(&quot; + s1 + &quot;)&quot; + s2);
                    }
                }
            }
            results.add(newList);
        }

        return results.get(n);
    }
}
</code></pre>
<h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><h4 id="递归和回溯的区别"><a href="#递归和回溯的区别" class="headerlink" title="递归和回溯的区别"></a>递归和回溯的区别</h4><blockquote>
<p>为了描述问题的某一状态，必须用到该状态的上一状态，而描述上一状态，又必须用到上一状态的上一状态……这种用自已来定义自己的方法，称为递归定义。形式如 f(n) = n<em>f(n-1), if n=0,f(n)=1.<br>从问题的某一种可能出发, 搜索从这种情况出发所能达到的所有可能, 当这一条路走到”尽头”的时候, 再倒回出发点, 从另一个可能出发, 继续搜索. 这种不断”回溯 “寻找解的方法, 称作”回溯法”。<br>递归是一种算法结构，递归会出现在子程序中自己调用自己或间接地自己调用自己。最直接的递归应用就是计算连续数的阶乘，计算规律：n!=(n-1)!</em>n。<br>观察阶乘计算的规律，前一个数结成的结果可以直接被应用到后一个数结成的计算中。</p>
</blockquote>
<pre><code>int fac（int n）
if（n==1）
return n;
else
return n*fac(n-1);
</code></pre><blockquote>
<p>回溯是一种算法思想，可以用递归实现。通俗点讲回溯就是一种试探，类似于穷举，但回溯有“剪枝”功能，比如求和问题。给定7个数字，1 2 3 4 5 6 7求和等于7的组合，从小到大搜索，选择1+2+3+4 =10&gt;7，已经超过了7，之后的5 6 7就没必要在继续了，这就是一种搜索过程的优化。如果还有不清楚的可以看一下8皇后问题。  </p>
</blockquote>
<h4 id="递归和迭代的区别"><a href="#递归和迭代的区别" class="headerlink" title="递归和迭代的区别"></a>递归和迭代的区别</h4><blockquote>
<ol>
<li>递归的基本概念:程序调用自身的编程技巧称为递归,是函数自己调用自己.一个函数在其定义中直接或间接调用自身的一种方法,它通常把一个大型的复杂的问题转化为一个与原问题相似的规模较小的问题来解决,可以极大的减少代码量.递归的能力在于用有限的语句来定义对象的无限集合。  </li>
<li>迭代:利用变量的原值推算出变量的一个新值.如果递归是自己调用自己的话,迭代就是A不停的调用B。  </li>
<li>递归中一定有迭代,但是迭代中不一定有递归,大部分可以相互转换.能用迭代的不用递归,递归调用函数,浪费空间,并且递归太深容易造成堆栈的溢出。</li>
</ol>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述 **&quot;&gt;&lt;/a&gt;题目描述 &lt;em&gt;**&lt;/em&gt;&lt;/h2&gt;&lt;p&gt;给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。&lt;/
    
    </summary>
    
      <category term="LeetCode-Java" scheme="http://sunyang.xyz/categories/LeetCode-Java/"/>
    
    
      <category term="Java" scheme="http://sunyang.xyz/tags/Java/"/>
    
      <category term="LeetCode" scheme="http://sunyang.xyz/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>21. 合并两个有序链表</title>
    <link href="http://sunyang.xyz/2019/10/04/LeetCode-Java/21.%20%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <id>http://sunyang.xyz/2019/10/04/LeetCode-Java/21. 合并两个有序链表/</id>
    <published>2019-10-04T02:14:20.000Z</published>
    <updated>2019-10-04T09:40:53.048Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><del>题目描述</del></h2><p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
<p>示例：</p>
<pre><code>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4
输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4
</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><pre><code class="Java">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode l3 = new ListNode(-1);
        ListNode temp3 = l3;

        ListNode temp1 = l1, temp2 = l2;

        while(temp1 != null &amp;&amp; temp2 != null) {
            if(temp1.val &lt;= temp2.val ) {
                temp3.next = temp1;
                temp1 = temp1.next;
            }
            else {
                temp3.next = temp2;
                temp2 = temp2.next;
            }
            temp3 = temp3.next;
        }
        temp3.next = temp1 == null ? temp2 : temp1;
        return l3.next;
    }
}
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;del&gt;题目描述&lt;/del&gt;&lt;/h2&gt;&lt;p&gt;将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 &lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode-Java" scheme="http://sunyang.xyz/categories/LeetCode-Java/"/>
    
    
      <category term="Java" scheme="http://sunyang.xyz/tags/Java/"/>
    
      <category term="LeetCode" scheme="http://sunyang.xyz/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>20. 有效的括号</title>
    <link href="http://sunyang.xyz/2019/10/03/LeetCode-Java/20.%20%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/"/>
    <id>http://sunyang.xyz/2019/10/03/LeetCode-Java/20. 有效的括号/</id>
    <published>2019-10-03T14:40:20.000Z</published>
    <updated>2019-10-04T09:41:25.916Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><del>题目描述</del></h2><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。</p>
<p>示例 1:</p>
<pre><code>输入: &quot;()&quot;
输出: true
</code></pre><p>示例 2:</p>
<pre><code>输入: &quot;()[]{}&quot;
输出: true
</code></pre><p>示例 3:</p>
<pre><code>输入: &quot;(]&quot;
输出: false
</code></pre><p>示例 4:</p>
<pre><code>输入: &quot;([)]&quot;
输出: false
</code></pre><p>示例 5:</p>
<pre><code>输入: &quot;{[]}&quot;
输出: true
</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><pre><code class="Java">class Solution {
    public boolean isValid(String s) {
        Deque&lt;Character&gt; stack = new ArrayDeque&lt;&gt;();
        for(int i=0; i&lt;s.length(); i++) {
            char c = s.charAt(i);
            switch(c) {
                case &#39;(&#39;:
                case &#39;[&#39;:
                case &#39;{&#39;:
                    stack.push(c);
                    break;
                case &#39;)&#39;:
                    if(stack.isEmpty() || stack.pop() != &#39;(&#39;) return false;
                    // 出栈之前别忘了判断栈是否为空
                    break;
                case &#39;]&#39;:
                    if(stack.isEmpty() || stack.pop() != &#39;[&#39;) return false;
                    break;
                case &#39;}&#39;:
                    if(stack.isEmpty() || stack.pop() != &#39;{&#39;) return false;
                    break;
            }
        }
        return stack.isEmpty();             
    }
}
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;del&gt;题目描述&lt;/del&gt;&lt;/h2&gt;&lt;p&gt;给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode-Java" scheme="http://sunyang.xyz/categories/LeetCode-Java/"/>
    
    
      <category term="Java" scheme="http://sunyang.xyz/tags/Java/"/>
    
      <category term="LeetCode" scheme="http://sunyang.xyz/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>19. 删除链表的倒数第N个节点</title>
    <link href="http://sunyang.xyz/2019/10/03/LeetCode-Java/19.%20%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
    <id>http://sunyang.xyz/2019/10/03/LeetCode-Java/19. 删除链表的倒数第N个节点/</id>
    <published>2019-10-03T14:14:20.000Z</published>
    <updated>2019-10-04T09:41:21.672Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><del>题目描述</del></h2><p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p>
<p>示例：</p>
<pre><code>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.

当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.
</code></pre><p>说明：</p>
<p>给定的 n 保证是有效的。</p>
<p>进阶：</p>
<p>你能尝试使用一趟扫描实现吗？</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>双指针</p>
<pre><code class="Java">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode right = head;
        for(int i=0; i&lt;n; i++) {
            right = right.next;
        }
        ListNode left = head;
        // 删除头结点(倒数第n个结点)的情况要单独讨论
        if(right == null) {
            left = left.next;
            return left;
        }
        else {
            while(right.next != null) {
                right = right.next;
                left = left.next;
            }
            left.next = left.next.next;
            return head;
        }      
    }
}
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;del&gt;题目描述&lt;/del&gt;&lt;/h2&gt;&lt;p&gt;给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;p
    
    </summary>
    
      <category term="LeetCode-Java" scheme="http://sunyang.xyz/categories/LeetCode-Java/"/>
    
    
      <category term="Java" scheme="http://sunyang.xyz/tags/Java/"/>
    
      <category term="LeetCode" scheme="http://sunyang.xyz/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>17. 电话号码的字母组合</title>
    <link href="http://sunyang.xyz/2019/10/03/LeetCode-Java/17.%20%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/"/>
    <id>http://sunyang.xyz/2019/10/03/LeetCode-Java/17. 电话号码的字母组合/</id>
    <published>2019-10-03T13:14:20.000Z</published>
    <updated>2019-10-04T09:41:18.667Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述 **"></a>题目描述 **</h2><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<p>示例:</p>
<pre><code>输入：&quot;23&quot;
输出：[&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].
</code></pre><p>说明:<br>尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>回溯是一种通过穷举所有可能情况来找到所有解的算法。如果一个候选解最后被发现并不是可行解，回溯算法会舍弃它，并在前面的一些步骤做出一些修改，并重新尝试找到可行解。</p>
<p>给出如下回溯函数 backtrack(combination, next_digits) ，它将一个目前已经产生的组合 combination 和接下来准备要输入的数字 next_digits 作为参数。</p>
<p>如果没有更多的数字需要被输入，那意味着当前的组合已经产生好了。<br>如果还有数字需要被输入：<br>遍历下一个数字所对应的所有映射的字母。<br>将当前的字母添加到组合最后，也就是 combination = combination + letter 。<br>重复这个过程，输入剩下的数字： backtrack(combination + letter, next_digits[1:]) 。</p>
<pre><code class="Java">class Solution {
    Map&lt;String, String&gt; map = new HashMap&lt;&gt;();
    // map 初始化
    {
        map.put(&quot;2&quot;, &quot;abc&quot;);
        map.put(&quot;3&quot;, &quot;def&quot;);
        map.put(&quot;4&quot;, &quot;ghi&quot;);
        map.put(&quot;5&quot;, &quot;jkl&quot;);
        map.put(&quot;6&quot;, &quot;mno&quot;);
        map.put(&quot;7&quot;, &quot;pqrs&quot;);
        map.put(&quot;8&quot;, &quot;tuv&quot;);
        map.put(&quot;9&quot;, &quot;wxyz&quot;);
    }
    List&lt;String&gt; result = new ArrayList&lt;&gt;();
    public List&lt;String&gt; letterCombinations(String digits) {
        if(digits.length() != 0) backtrack(&quot;&quot;, digits);
        return result;
    }
    public void backtrack(String s, String digits) {
        if(digits.length() == 0) {
            result.add(s);
            return;
        }
        String match = map.get(digits.substring(0,1));
        for(int i=0; i&lt;match.length(); i++) {
            String letter = match.substring(i, i+1);
            backtrack(s+letter, digits.substring(1));
        }
    }
}
</code></pre>
<h5 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ul>
<li><p>时间复杂度： O(3^N * 4^M)，其中 N 是输入数字中对应 3 个字母的数目（比方说 2，3，4，5，6，8）， M 是输入数字中对应 4 个字母的数目（比方说 7，9），N+M 是输入数字的总数。</p>
</li>
<li><p>空间复杂度：O(3^N <em> 4^M) ，这是因为需要保存 3^N </em> 4^M个结果。</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述 **&quot;&gt;&lt;/a&gt;题目描述 **&lt;/h2&gt;&lt;p&gt;给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。&lt;/p&gt;
&lt;p&gt;给出数字到字母的映射如下（与电
    
    </summary>
    
      <category term="LeetCode-Java" scheme="http://sunyang.xyz/categories/LeetCode-Java/"/>
    
    
      <category term="Java" scheme="http://sunyang.xyz/tags/Java/"/>
    
      <category term="LeetCode" scheme="http://sunyang.xyz/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>15. 三数之和</title>
    <link href="http://sunyang.xyz/2019/10/02/LeetCode-Java/15.%20%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://sunyang.xyz/2019/10/02/LeetCode-Java/15. 三数之和/</id>
    <published>2019-10-02T15:14:20.000Z</published>
    <updated>2019-10-04T09:41:14.620Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述 *"></a>题目描述 *</h2><p>给定一个包含 n 个整数的数组nums，判断nums中是否存在三个元素 a，b，c ，使得a + b + c = 0 ？找出所有满足条件且不重复的三元组。</p>
<p>注意：答案中不可以包含重复的三元组。</p>
<pre><code>例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，

满足要求的三元组集合为：
[
  [-1, 0, 1],
  [-1, -1, 2]
]
</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先对数组进行排序，排序后固定一个数nums[i]，再使用左右指针指向nums[i]后面的两端，数字分别为 nums[L] 和 nums[R]，计算三个数的和 sum 判断是否满足为 0，满足则添加进结果集<br>如果 nums[i]大于 0，则三数之和必然无法等于 0，结束循环<br>如果 nums[i]==nums[i−1]，则说明该数字重复，会导致结果重复，所以应该跳过<br>当 sum == 0 时，nums[L]==nums[L+1]则会导致结果重复，应该跳过，L++<br>当 sum == 0 时，nums[R] == nums[R−1] 则会导致结果重复，应该跳过，R−−<br>时间复杂度：O(n^2)，n 为数组长度</p>
<pre><code class="Java">class Solution {
    public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) {
        Arrays.sort(nums);
        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();
        int i = 0;
        while(i &lt; nums.length - 2){
            int a = nums[i];
            if(a &gt; 0) break;  // 最小值都大于0，那么不可能有解
            int j = i+1, k = nums.length - 1;
            while(j &lt; k){
                if(nums[j] + nums[k] == -a) {
                    result.add(Arrays.asList(a, nums[j], nums[k]));
                    j++; k--;
                    while(j &lt; k &amp;&amp; nums[j] == nums[j-1]) j++;
                    while(k &gt; j &amp;&amp; nums[k] == nums[k+1]) k--;
                }
                else if(nums[j] + nums[k] &lt; -a) {
                    j++;
                    while(j &lt; k &amp;&amp; nums[j] == nums[j-1]) j++;
                }
                else if(nums[j] + nums[k] &gt; -a) {
                    k--;
                    while(k &gt; j &amp;&amp; nums[k] == nums[k+1]) k--;
                }
            }
            i++;
            while(i &lt; nums.length - 2 &amp;&amp; nums[i] == nums[i-1]) i++;
        }
        return result;
    }
}
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述 *&quot;&gt;&lt;/a&gt;题目描述 *&lt;/h2&gt;&lt;p&gt;给定一个包含 n 个整数的数组nums，判断nums中是否存在三个元素 a，b，c ，使得a + b + c = 0
    
    </summary>
    
      <category term="LeetCode-Java" scheme="http://sunyang.xyz/categories/LeetCode-Java/"/>
    
    
      <category term="Java" scheme="http://sunyang.xyz/tags/Java/"/>
    
      <category term="LeetCode" scheme="http://sunyang.xyz/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>11. 盛最多水的容器</title>
    <link href="http://sunyang.xyz/2019/10/02/LeetCode-Java/11.%20%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/"/>
    <id>http://sunyang.xyz/2019/10/02/LeetCode-Java/11. 盛最多水的容器/</id>
    <published>2019-10-02T07:14:20.000Z</published>
    <updated>2019-10-04T09:41:11.929Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述 *"></a>题目描述 <em>*</em></h2><p>图见leetcode<br>给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点(i,ai) 。在坐标内画 n 条垂直线，垂直线 i的两个端点分别为(i,ai) 和 (i, 0)。找出其中的两条线，使得它们与x轴共同构成的容器可以容纳最多的水。</p>
<p>说明：你不能倾斜容器，且n的值至少为 2。</p>
<p>示例:</p>
<pre><code>输入: [1,8,6,2,5,4,8,3,7]
输出: 49
</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h4 id="解法一：暴力法"><a href="#解法一：暴力法" class="headerlink" title="解法一：暴力法"></a>解法一：暴力法</h4><pre><code class="Java">class Solution {
    public int maxArea(int[] height) {
        int n = height.length;
        int maxArea = 0;
        for(int i=0; i &lt; n-1; i++) {
            for(int j = i+1; j &lt; n; j++){
                int curArea = Math.min(height[i], height[j]) * (j - i);
                maxArea = Math.max(maxArea, curArea);
            }
        }
        return maxArea;
    }
}
</code></pre>
<h5 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><p>时间复杂度：O(n^2)，计算所有 n(n-1)/2 种高度组合的面积。<br>空间复杂度：O(1)，使用恒定的额外空间。</p>
<h4 id="解法二：双指针法"><a href="#解法二：双指针法" class="headerlink" title="解法二：双指针法"></a>解法二：双指针法</h4><p>这种方法背后的思路在于，两线段之间形成的区域总是会受到其中较短那条长度的限制。此外，两线段距离越远，得到的面积就越大。<br>我们在由线段长度构成的数组中使用两个指针，一个放在开始，一个置于末尾。 此外，我们会使用变量 maxarea 来持续存储到目前为止所获得的最大面积。 在每一步中，我们会找出指针所指向的两条线段形成的区域，更新maxarea，并将指向较短线段的指针向较长线段那端移动一步。<br>每移动一次较小指针，意味着计算了一对S(i,j)的值，而消去了一排S(i, k), i &lt; k &lt;= j, （假设i是较小指针），这一排是不需要计算的，因为矩形的高度受h[i]限制，只能更低，不能更高，而矩形的长度k-i &lt; j-i，所以这一排矩形面积不会更大，不需要计算。</p>
<pre><code class="Java">class Solution {
    public int maxArea(int[] height) {
        int n = height.length;
        int maxArea = 0;
        int left = 0, right = n-1;
        while(left &lt; right){
            if(height[left] &lt; height[right]) {
                maxArea = Math.max(maxArea, height[left] * (right - left));
                left ++;
            }
            else {
                maxArea = Math.max(maxArea, height[right] * (right - left));
                right --;
            }
        }
        return maxArea;
    }
}
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述 *&quot;&gt;&lt;/a&gt;题目描述 &lt;em&gt;*&lt;/em&gt;&lt;/h2&gt;&lt;p&gt;图见leetcode&lt;br&gt;给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点(
    
    </summary>
    
      <category term="LeetCode-Java" scheme="http://sunyang.xyz/categories/LeetCode-Java/"/>
    
    
      <category term="Java" scheme="http://sunyang.xyz/tags/Java/"/>
    
      <category term="LeetCode" scheme="http://sunyang.xyz/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>5. 最长回文子串</title>
    <link href="http://sunyang.xyz/2019/10/02/LeetCode-Java/5.%20%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <id>http://sunyang.xyz/2019/10/02/LeetCode-Java/5. 最长回文子串/</id>
    <published>2019-10-02T05:14:20.000Z</published>
    <updated>2019-10-04T09:41:08.714Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述  **"></a>题目描述  **</h2><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设s 的最大长度为 1000。</p>
<p>示例 1：</p>
<pre><code>输入: &quot;babad&quot;
输出: &quot;bab&quot;
注意: &quot;aba&quot; 也是一个有效答案。
</code></pre><p>示例 2：</p>
<pre><code>输入: &quot;cbbd&quot;
输出: &quot;bb&quot;
</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h4 id="解法一：扩展中心"><a href="#解法一：扩展中心" class="headerlink" title="解法一：扩展中心"></a>解法一：扩展中心</h4><p>回文串一定是对称的，所以我们可以每次循环选择一个中心，进行左右扩展，判断左右字符是否相等即可。  </p>
<pre><code class="Java">class Solution {
    public String longestPalindrome(String s) {
        int n = s.length();
        int maxLen = 0;
        String subS = &quot;&quot;;
        for(int i = 0; i &lt; n; i++){
            // 奇数回文串，中心是一个元素
            int left = i, right = i;  
            while(left &gt; -1 &amp;&amp; right &lt; n &amp;&amp; s.charAt(left) == s.charAt(right)){
                left --;
                right ++;
            }
            if(maxLen &lt; right-left-1){
                maxLen = right-left-1;
                subS = s.substring(left+1, right);
            }

            // 偶数回文串，中心是两个元素
            left = i; 
            right = i+1;
            while(left &gt; -1 &amp;&amp; right &lt; n &amp;&amp; s.charAt(left) == s.charAt(right)){
                left --;
                right ++;
            }
            if(maxLen &lt; right-left-1){
                maxLen = right-left-1;
                subS = s.substring(left+1, right);
            }
        }
        return subS;
    }
}
</code></pre>
<p>复杂度分析<br>时间复杂度： O(n^2)<br>空间复杂度： O(1)</p>
<h4 id="解法二：动态规划"><a href="#解法二：动态规划" class="headerlink" title="解法二：动态规划"></a>解法二：动态规划</h4><p>如果S[i+1,j−1] 是回文串，那么只要S[i]==S[j]，就可以确定 S[i,j]也是回文串了。</p>
<p>求 长度为 1 和长度为 2 的 P(i,j) 时不能用上边的公式，因为我们代入公式后会遇到 P[i][j] 中 i &gt; j 的情况，比如求 P[1][2] 的话，我们需要知道 P[1+1][2-1]=P[2][1]，而 P[2][1] 代表着S[2,1] 是不是回文串，显然是不对的，所以我们需要单独判断。</p>
<p>所以我们先初始化长度是 1 的回文串的P[i,j]，这样利用上边提出的公式 P(i,j)=(P(i+1,j-1)\&amp;\&amp;S[i]==S[j])，然后两边向外各扩充一个字符，长度为 3 的，为 5 的，所有奇数长度的就都求出来了。</p>
<p>同理，初始化长度是 2 的回文串P[i,i+1]，利用公式，长度为 4 的，6 的所有偶数长度的就都求出来了。</p>
<pre><code class="Java">class Solution {
    public String longestPalindrome(String s) {
        int n = s.length();
        boolean[][] isPalindrome = new boolean[n][n];
        int maxLen = 0;
        String subS = &quot;&quot;;
        for(int len = 1; len &lt;= n; len++) {
            for(int start = 0; start &lt;= n - len; start++){
                int end = start + len - 1;
                isPalindrome[start][end] = (len == 1 || len == 2 || isPalindrome[start+1][end-1]) &amp;&amp; s.charAt(start) == s.charAt(end);  
                // len==1 和 len==2 单独判断（初始化）
                if(isPalindrome[start][end] &amp;&amp; len &gt; maxLen) {
                    maxLen = len;
                    subS = s.substring(start, end+1);
                }
            }    
        }
        return subS;
    }
}
</code></pre>
<p>复杂度分析<br>时间复杂度：两层循环 O(n^2）。<br>空间复杂度：用二维数组 P 保存每个子串的情况 O(n^2)。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述  **&quot;&gt;&lt;/a&gt;题目描述  **&lt;/h2&gt;&lt;p&gt;给定一个字符串 s，找到 s 中最长的回文子串。你可以假设s 的最大长度为 1000。&lt;/p&gt;
&lt;p&gt;示例 
    
    </summary>
    
      <category term="LeetCode-Java" scheme="http://sunyang.xyz/categories/LeetCode-Java/"/>
    
    
      <category term="Java" scheme="http://sunyang.xyz/tags/Java/"/>
    
      <category term="LeetCode" scheme="http://sunyang.xyz/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>4. 寻找两个有序数组的中位数</title>
    <link href="http://sunyang.xyz/2019/10/01/LeetCode-Java/4.%20%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <id>http://sunyang.xyz/2019/10/01/LeetCode-Java/4. 寻找两个有序数组的中位数/</id>
    <published>2019-10-01T13:14:20.000Z</published>
    <updated>2019-10-04T09:40:58.990Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述  **"></a>题目描述  <em>**</em></h2><p>给定两个大小为 m 和 n 的有序数组nums1 和nums2。</p>
<p>请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为O(log(m + n))。</p>
<p>你可以假设nums1和nums2不会同时为空。</p>
<p>示例 1:</p>
<pre><code>nums1 = [1, 3]
nums2 = [2]

则中位数是 2.0
</code></pre><p>示例 2:</p>
<pre><code>nums1 = [1, 2]
nums2 = [3, 4]

则中位数是 (2 + 3)/2 = 2.5
</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h4 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h4><p>开始的思路是写一个循环，然后里边判断是否到了中位数的位置，到了就返回结果，但这里对偶数和奇数的分类会很麻烦。当其中一个数组遍历完后，出了 for 循环对边界的判断也会分几种情况。总体来说，虽然复杂度不影响，但代码会看起来很乱。</p>
<p>首先是怎么将奇数和偶数的情况合并一下。</p>
<p>用 len 表示合并后数组的长度，如果是奇数，我们需要知道第 （len+1）/2 个数就可以了，如果遍历的话需要遍历 int(len/2 ) + 1 次。如果是偶数，我们需要知道第 len/2和 len/2+1 个数，也是需要遍历 len/2+1 次。所以遍历的话，奇数和偶数都是 len/2+1 次。</p>
<p>返回中位数的话，奇数需要最后一次遍历的结果就可以了，偶数需要最后一次和上一次遍历的结果。所以我们用两个变量 left 和 right，right 保存当前循环的结果，在每次循环前将 right 的值赋给 left。这样在最后一次循环的时候，left 将得到 right 的值，也就是上一次循环的结果，接下来 right 更新为最后一次的结果。</p>
<p>循环中该怎么写，什么时候 A 数组后移，什么时候 B 数组后移。用 aStart 和 bStart 分别表示当前指向 A 数组和 B 数组的位置。如果 aStart 还没有到最后并且此时 A 位置的数字小于 B 位置的数组，那么就可以后移了。也就是aStart＜m&amp;&amp;A[aStart]&lt; B[bStart]。</p>
<p>但如果 B 数组此刻已经没有数字了，继续取数字 B[ bStart ]，则会越界，所以判断下 bStart 是否大于数组长度了，这样 || 后边的就不会执行了，也就不会导致错误了，所以增加为 aStart＜m&amp;&amp;(bStart) &gt;= n||A[aStart] &lt; B[bStart]) 。</p>
<pre><code class="Java">public double findMedianSortedArrays(int[] A, int[] B) {
    int m = A.length;
    int n = B.length;
    int len = m + n;
    int left = -1, right = -1;
    int aStart = 0, bStart = 0;
    for (int i = 0; i &lt;= len / 2; i++) {
        left = right;
        if (aStart &lt; m &amp;&amp; (bStart &gt;= n || A[aStart] &lt; B[bStart])) {
            right = A[aStart++];
        } else {
            right = B[bStart++];
        }
    }
    if ((len &amp; 1) == 0)
        return (left + right) / 2.0;
    else
        return right;
}
</code></pre>
<h4 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h4><p>第k小数（删掉一定比该数小的部分）<br>求中位数，其实就是求第k小数的一种特殊情况，可以每次循环排除掉 k/2 个数。<br>例如找两个数组中第k小的数，则将两个数组中第k/2小的数进行比较，较小者所在的数组，位于该元素之前的数一定都比总体的第k小数要小的。所以可以排除掉该数组的前k/2个元素。然后再递归排除。<br>要注意，如果一个数组的元素个数已经少于k/2个了，则要将该数组的最后元素（最大）与另一数组的k/2小元素比较。  </p>
<pre><code class="Java">class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int m = nums1.length, n = nums2.length;
        int total = m + n;
        if(total % 2 == 0) return (getKth(nums1, 0, m-1, nums2, 0, n-1, total/2) + getKth(nums1, 0, m-1, nums2, 0, n-1, total/2+1)) / 2;
        else return getKth(nums1, 0, m-1, nums2, 0, n-1, total/2+1);
    }
    public double getKth(int[] nums1, int start1, int end1, int[] nums2, int start2, int end2, int k){
        if(end1 &lt; start1) return nums2[start2 + k - 1];
        if(end2 &lt; start2) return nums1[start1 + k - 1];
        if(k == 1) return nums1[start1] &lt; nums2[start2] ? nums1[start1] : nums2[start2];
        int i = Math.min(end1, k/2 + start1 -1), j = Math.min(end2, k/2 + start2 - 1);
        if(nums1[i] &lt;= nums2[j]){
            k = k - (i - start1 + 1);
            start1 = i + 1;
        }
        else{
            k = k - (j - start2 + 1);
            start2 = j + 1;
        }
        return getKth(nums1, start1, end1, nums2, start2, end2, k);
    }
}
</code></pre>
<p>复杂度分析<br>时间复杂度：每进行一次循环，我们就减少 k/2 个元素，所以时间复杂度是 O(log(k))，而 k=(m+n)/2，所以最终的复杂也就是 O(log(m+n))。</p>
<p>空间复杂度：虽然我们用到了递归，但是可以看到这个递归属于尾递归，所以编译器不需要不停地堆栈，所以空间复杂度为 O(1)。  </p>
<blockquote>
<p>尾递归：<br>如果一个函数中所有递归形式的调用都出现在函数的末尾，我们称这个递归函数是尾递归的。当递归调用是整个函数体中最后执行的语句且它的返回值不属于表达式的一部分时，这个递归调用就是尾递归。尾递归函数的特点是在回归过程中不用做任何操作，这个特性很重要，因为大多数现代的编译器会利用这种特点自动生成优化的代码。<br>当编译器检测到一个函数调用是尾递归的时候，它就覆盖当前的活动记录而不是在栈中去创建一个新的。编译器可以做到这点，因为递归调用是当前活跃期内最后一条待执行的语句，于是当这个调用返回时栈帧中并没有其他事情可做，因此也就没有保存栈帧的必要了。通过覆盖当前的栈帧而不是在其之上重新添加一个，这样所使用的栈空间就大大缩减了，这使得实际的运行效率会变得更高。</p>
</blockquote>
<h4 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h4><p>切分数组<br>中位数将数组分为元素数相等的两部分，故将两数组都进行切分，必须保证左边两部分数量等于右边两部分数量。其次，左边最大值要小于右边最小值。<br>所以初始化两条切分线在两数组中间，然后在保证条件一的基础上不断移动切分线，使其满足条件二。</p>
<pre><code class="Java">class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int m = nums1.length, n = nums2.length;
        if(m &gt; n) return findMedianSortedArrays(nums2, nums1); // 保证nums1比nums2短
        int iMin = 0, iMax = m;  // 这是i能够取到的最小值与最大值
        while(iMin &lt;= iMax){
            int i = (iMin + iMax) / 2;
            int j = (m + n + 1) / 2 - i;  // （1）

            if(i!=0 &amp;&amp; nums1[i-1] &gt; nums2[j]) iMax = i - 1;  // （2）
            else if(i!=m &amp;&amp; nums2[j-1] &gt; nums1[i]) iMin = i + 1;
            else{
                int maxLeft;
                if(i == 0) maxLeft = nums2[j-1];
                else if(j == 0) maxLeft = nums1[i-1];
                else maxLeft = Math.max(nums1[i-1], nums2[j-1]);
                if((m+n) % 2 == 1) return maxLeft;  // 若和为奇数，直接返回最大左边值，

                int minRight;
                if(i == m) minRight = nums2[j];
                else if(j == n) minRight = nums1[i];
                else minRight = Math.min(nums1[i], nums2[j]);
                return (maxLeft + minRight) / 2.0;
            }
        }
        return 0.0;
    }
}
</code></pre>
<p>（1） 若为偶数， j = (m+n)/2 - i，切分线左右两边数量相等。若为奇数，使左边比右边多一个元素，则 j = (m+n+1)/2 - i 。 发现偶数的情况可以合并到奇数里。（m+n+1没有影响）。<br>（2） 二分查找，减半找中间的，再减半找中间的。不是主动移动中间数，而是将边界不断减半，使中间数被动移动。  </p>
<p>复杂度分析<br>时间复杂度：我们对较短的数组进行了二分查找，所以时间复杂度是 O(log(min(m,n)))。<br>空间复杂度：只有一些固定的变量，和数组长度无关，所以空间复杂度是 O(1)。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述  **&quot;&gt;&lt;/a&gt;题目描述  &lt;em&gt;**&lt;/em&gt;&lt;/h2&gt;&lt;p&gt;给定两个大小为 m 和 n 的有序数组nums1 和nums2。&lt;/p&gt;
&lt;p&gt;请你找出这
    
    </summary>
    
      <category term="LeetCode-Java" scheme="http://sunyang.xyz/categories/LeetCode-Java/"/>
    
    
      <category term="Java" scheme="http://sunyang.xyz/tags/Java/"/>
    
      <category term="LeetCode" scheme="http://sunyang.xyz/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>3. 无重复字符的最长子串</title>
    <link href="http://sunyang.xyz/2019/09/29/LeetCode-Java/3.%20%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
    <id>http://sunyang.xyz/2019/09/29/LeetCode-Java/3. 无重复字符的最长子串/</id>
    <published>2019-09-29T02:14:20.000Z</published>
    <updated>2019-10-04T09:41:02.263Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述  *"></a>题目描述  <em>*</em></h2><p>给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。</p>
<p>示例1:</p>
<pre><code>输入: &quot;abcabcbb&quot;
输出: 3 
解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。
</code></pre><p>示例 2:</p>
<pre><code>输入: &quot;bbbbb&quot;
输出: 1
解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。
</code></pre><p>示例 3:</p>
<pre><code>输入: &quot;pwwkew&quot;
输出: 3
解释: 因为无重复字符的最长子串是&quot;wke&quot;，所以其长度为 3。
请注意，你的答案必须是子串的长度，&quot;pwke&quot;是一个子序列，不是子串。
</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h4 id="1-边界值滑动窗口"><a href="#1-边界值滑动窗口" class="headerlink" title="1. 边界值滑动窗口"></a>1. 边界值滑动窗口</h4><p>用边界值作滑动窗口，两次遍历字符串</p>
<pre><code class="Java">class Solution {
    public int lengthOfLongestSubstring(String s) {
    // 滑动窗口右移，用右侧新字符与窗口内所有字符比较，如有相同，则左侧窗口移到相同处的右侧。
        int start = 0, end = 0, maxLength = 0, curLength = 0;
        for(end=0; end &lt; s.length(); end++){
            for(int i=start; i&lt;end; i++){
                if(s.charAt(i) == s.charAt(end)) {
                    start = i+1;
                    break;
                }
            }
            curLength = end - start + 1;
            if(curLength &gt; maxLength) maxLength = curLength;
        }
        return maxLength;
    }
}
</code></pre>
<p>复杂度分析</p>
<ul>
<li>时间复杂度：O(n^2)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h4 id="2-HashSet滑动窗口"><a href="#2-HashSet滑动窗口" class="headerlink" title="2. HashSet滑动窗口"></a>2. HashSet滑动窗口</h4><p>用HashSet作滑动窗口，可直接判断有无重复元素，避免二次遍历。</p>
<pre><code class="Java">class Solution {
    public int lengthOfLongestSubstring(String s) {
        Set&lt;Character&gt; hashSet = new HashSet&lt;&gt;();
        int maxLength = 0, start = 0, end = 0;
        int n = s.length();
        while(end &lt; n){
            if(!hashSet.contains(s.charAt(end))){
                hashSet.add(s.charAt(end));
                maxLength = Math.max(end - start + 1, maxLength);
                end ++;
            }
            else{
                hashSet.remove(s.charAt(start++));
                // 如果有重复元素，由于set无法确定重复元素的位置，需要按照原字符串的顺序从start开始一个个删除，将包含重复元素之前的元素都删掉。
            }
        }
        return maxLength;
    }
}
</code></pre>
<p>复杂度分析</p>
<ul>
<li>时间复杂度：O(2n) = O(n)</li>
<li>空间复杂度：O(min(m,n)，Set的大小取决于字符串n的大小以及字符集m的大小。</li>
</ul>
<h4 id="3-HashMap滑动窗口"><a href="#3-HashMap滑动窗口" class="headerlink" title="3. HashMap滑动窗口"></a>3. HashMap滑动窗口</h4><p>我们可以定义字符到索引的映射，而不是使用集合来判断一个字符是否存在。 当我们找到重复的字符时，我们可以立即跳过该窗口。</p>
<pre><code class="Java">class Solution {
    public int lengthOfLongestSubstring(String s) {
        Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();
        int start = 0, end = 0;
        int maxLength = 0;
        int n = s.length();
        while(end &lt; n){
            if(map.containsKey(s.charAt(end))){
                start = Math.max(map.get(s.charAt(end))+1, start);
            }
            maxLength = Math.max(maxLength, end - start + 1);
            map.put(s.charAt(end), end);
            end ++;
        }
        return maxLength;
    }
}
</code></pre>
<p>复杂度分析</p>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(min(m,n))，与方法2相同。  </li>
</ul>
<p><strong>注意：</strong><br>尽管方法2、3的时间复杂度比方法1低，但涉及到集合或映射的建立、插入、删除，实际运行时间可能比方法1长。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述  *&quot;&gt;&lt;/a&gt;题目描述  &lt;em&gt;*&lt;/em&gt;&lt;/h2&gt;&lt;p&gt;给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。&lt;/p&gt;
&lt;p&gt;示例1:&lt;/p&gt;

    
    </summary>
    
      <category term="LeetCode-Java" scheme="http://sunyang.xyz/categories/LeetCode-Java/"/>
    
    
      <category term="Java" scheme="http://sunyang.xyz/tags/Java/"/>
    
      <category term="LeetCode" scheme="http://sunyang.xyz/tags/LeetCode/"/>
    
  </entry>
  
</feed>
