<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[49. 字母异位词分组]]></title>
      <url>/2019/10/06/LeetCode-Java/49.%20%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84/</url>
      <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述 **"></a>题目描述 <em>**</em></h2><p>给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。</p>
<p>示例:</p>
<pre><code>输入: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;],
输出:
[
  [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;],
  [&quot;nat&quot;,&quot;tan&quot;],
  [&quot;bat&quot;]
]
</code></pre><p>说明：</p>
<ul>
<li>所有输入均为小写字母。</li>
<li>不考虑答案输出的顺序。</li>
</ul>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h4 id="解法一-暴力"><a href="#解法一-暴力" class="headerlink" title="解法一 暴力"></a>解法一 暴力</h4><p>遍历每个字符串，判断与results中每组字符串是否异位。通过字符串中不同字母的个数来判断。</p>
<pre><code class="Java">class Solution {
    public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) {
        List&lt;List&lt;String&gt;&gt; results = new ArrayList&lt;&gt;();
        if(strs.length == 0) return results;
        List&lt;String&gt; l = new ArrayList&lt;String&gt;();
        l.add(strs[0]);
        results.add(l);
        for(int i=1; i&lt;strs.length; i++) {
            String s = strs[i];
            boolean exist = false;
            for(List&lt;String&gt; group : results) {
                if(isAnagrams(group.get(0), s)) {
                    group.add(s);
                    exist = true;
                    break;
                }
            }
            if(!exist) {
                List&lt;String&gt; list = new ArrayList&lt;String&gt;();
                list.add(s);
                results.add(list);
            }
        }
        return results;
    }
    public boolean isAnagrams(String a, String b) {
        if(a.length() != b.length()) return false;
        Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();
        for(int i = 0; i&lt;a.length(); i++) {
            char c = a.charAt(i);
            map.put(c, map.getOrDefault(c, 0) + 1);
        }
        for(int i=0; i&lt;b.length(); i++) {
            char c = b.charAt(i);
            if(map.containsKey(c) &amp;&amp; map.get(c) != 0) map.put(c, map.get(c)-1);
            else return false;
        }
        return true;
    }
}
</code></pre>
<h4 id="解法二-按排序字符串分类"><a href="#解法二-按排序字符串分类" class="headerlink" title="解法二 按排序字符串分类"></a>解法二 按排序字符串分类</h4><p><strong>当且仅当它们的排序字符串相等时，两个字符串是字母异位词。</strong><br>维护一个映射 ans : {String -&gt; List}，其中每个键ans是一个排序字符串，每个值是初始输入的字符串列表，排序后等于ans。</p>
<pre><code class="Java">class Solution {
    public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) {
        Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;&gt;();
        for(String s : strs) {
            char[] cs = s.toCharArray(); // (1) String to char[]
            Arrays.sort(cs); 
            String key = String.valueOf(cs); // (2) char[] to String
            if(map.containsKey(key)) map.get(key).add(s);
            else {
                List&lt;String&gt; list = new ArrayList&lt;&gt;();
                list.add(s);
                map.put(key, list);
            }
        }
        return new ArrayList(map.values());
    }
}
</code></pre>
<h5 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ul>
<li><p>时间复杂度：O(NKlogK)，其中 N 是 strs 的长度，而 K 是 strs 中字符串的最大长度。当我们遍历每个字符串时，外部循环具有的复杂度为 O(N)。然后，我们在 O(KlogK) 的时间内对每个字符串排序。</p>
</li>
<li><p>空间复杂度：O(NK)，排序存储在 ans 中的全部信息内容。</p>
</li>
</ul>
<h4 id="解法三-按字符计数分类"><a href="#解法三-按字符计数分类" class="headerlink" title="解法三 按字符计数分类"></a>解法三 按字符计数分类</h4><p><strong>当且仅当它们的字符计数（每个字符的出现次数）相同时，两个字符串是字母异位词。</strong><br>我们可以将每个字符串s 转换为字符数 count，由26个非负整数组成，表示 a，b，c 的数量等。我们使用这些计数作为哈希映射的基础。<br>在 Java 中，我们的字符数 count 的散列化表示将是一个用 <strong>＃</strong> 字符分隔的字符串。 例如，abbccc 将表示为 ＃1＃2＃3＃0＃0＃0 …＃0，其中总共有26个条目。</p>
<pre><code class="Java">class Solution {
    public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) {
        Map&lt;String, List&gt; map = new HashMap();
        for(String s : strs) {
            int[] count = new int[26];
            for(char c : s.toCharArray()) count[c-&#39;a&#39;]++;
            StringBuilder sb = new StringBuilder();
            for(int c : count) {
                sb.append(&#39;#&#39;);
                sb.append(c);
            }
            String newS = sb.toString();

            if(map.containsKey(newS)) map.get(newS).add(s);
            else {
                List&lt;String&gt; list = new ArrayList();
                list.add(s);
                map.put(newS, list);
            }
        }
        return new ArrayList(map.values());

    }
}
</code></pre>
<h5 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ul>
<li>时间复杂度：O(NK)，其中 N 是 strs 的长度，而 K 是 strs 中字符串的最大长度。计算每个字符串的字符串大小是线性的，我们统计每个字符串。</li>
<li>空间复杂度：O(NK)，排序存储在 ans 中的全部信息内容。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> LeetCode-Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[48. 旋转图像]]></title>
      <url>/2019/10/06/LeetCode-Java/48.%20%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/</url>
      <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述 *"></a>题目描述 <em>*</em></h2><p>给定一个 n × n 的二维矩阵表示一个图像。</p>
<p>将图像顺时针旋转 90 度。</p>
<p>说明：</p>
<p>你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。</p>
<p>示例 1:</p>
<pre><code>给定 matrix = 
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
],

原地旋转输入矩阵，使其变为:
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]
</code></pre><p>示例 2:</p>
<pre><code>给定 matrix =
[
  [ 5, 1, 9,11],
  [ 2, 4, 8,10],
  [13, 3, 6, 7],
  [15,14,12,16]
], 

原地旋转输入矩阵，使其变为:
[
  [15,13, 2, 5],
  [14, 3, 4, 1],
  [12, 6, 8, 9],
  [16, 7,10,11]
]
</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h4 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h4><p>一次转一步，分圈转，每圈转n次  </p>
<pre><code class="Java">class Solution {
    public void rotate(int[][] matrix) {
        int n = matrix.length;
        for(int round = 0; round &lt; n / 2; round++) {
            for(int step = 0; step &lt; n-2*round-1; step++) oneStep(matrix, round);
        }
        return;
    }
    public void oneStep(int[][] matrix, int round) {
        int n = matrix.length;
        int temp = matrix[round][round];
        for(int i1 = round; i1 &lt; n - round - 1; i1++) {
            matrix[i1][round] = matrix[i1+1][round];
        }
        for(int j2 = round; j2 &lt; n - round - 1; j2++) {
            matrix[n-round-1][j2] = matrix[n-round-1][j2+1];
        }
        for(int i3 = n-round-1; i3 &gt; round; i3--) {
            matrix[i3][n-round-1] = matrix[i3-1][n-round-1];
        }
        for(int j4 = n-round-1; j4 &gt; round+1; j4--) {
            matrix[round][j4] = matrix[round][j4-1];
        }
        matrix[round][round+1] = temp;
        return;
    }
}
</code></pre>
<h4 id="解法二-旋转四个矩形"><a href="#解法二-旋转四个矩形" class="headerlink" title="解法二 旋转四个矩形"></a>解法二 旋转四个矩形</h4><p>每圈转1次，一次转n步  </p>
<pre><code class="Java">class Solution {
    public void rotate(int[][] matrix) {
        if(matrix.length == 0 || matrix.length != matrix[0].length) {
            return;
        }
        int nums = matrix.length;
        int times = 0;
        while(times &lt;= (nums &gt;&gt; 1)){
            int len = nums - (times &lt;&lt; 1);
            for(int i = 0; i &lt; len - 1; ++i){
                int temp = matrix[times][times + i];
                matrix[times][times + i] = matrix[times + len - i - 1][times];
                matrix[times + len - i - 1][times] = matrix[times + len - 1][times + len - i - 1];
                matrix[times + len - 1][times + len - i - 1] = matrix[times + i][times + len - 1];
                matrix[times + i][times + len - 1] = temp;
            }
            ++times;
        }       
    }
}
</code></pre>
<h4 id="解法三-转置加翻转"><a href="#解法三-转置加翻转" class="headerlink" title="解法三 转置加翻转"></a>解法三 转置加翻转</h4><p>最直接的想法是先转置矩阵，然后翻转每一行。这个简单的方法已经能达到最优的时间复杂度O(N^2)。  </p>
<pre><code class="Java">class Solution {
  public void rotate(int[][] matrix) {
    int n = matrix.length;

    // transpose matrix
    for (int i = 0; i &lt; n; i++) {
      for (int j = i; j &lt; n; j++) {
        int tmp = matrix[j][i];
        matrix[j][i] = matrix[i][j];
        matrix[i][j] = tmp;
      }
    }
    // reverse each row
    for (int i = 0; i &lt; n; i++) {
      for (int j = 0; j &lt; n / 2; j++) {
        int tmp = matrix[i][j];
        matrix[i][j] = matrix[i][n - j - 1];
        matrix[i][n - j - 1] = tmp;
      }
    }
  }
}
</code></pre>
]]></content>
      
        <categories>
            
            <category> LeetCode-Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[46. 全排列]]></title>
      <url>/2019/10/05/LeetCode-Java/46.%20%E5%85%A8%E6%8E%92%E5%88%97/</url>
      <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述 **"></a>题目描述 **</h2><p>给定一个没有重复数字的序列，返回其所有可能的全排列。</p>
<p>示例:</p>
<pre><code>输入: [1,2,3]
输出:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>回溯法  </p>
<pre><code class="Java">class Solution {
    List&lt;List&lt;Integer&gt;&gt; results = new ArrayList&lt;&gt;();
    public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) {
        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
        for(int i:nums) list.add(i);
        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();
        backtrack(list, result);
        return results;
    }
    public void backtrack(List&lt;Integer&gt; list, List&lt;Integer&gt; result) {
        if(list.isEmpty()) {
            results.add(new ArrayList&lt;Integer&gt;(result)); //(1)
            return;
        }

        for(int i=0; i&lt;list.size(); i++) {
            // List&lt;Integer&gt; newList = new ArrayList&lt;&gt;(list);
            // List&lt;Integer&gt; newResult = new ArrayList&lt;&gt;(result);
            // newResult.add(newList.remove(i));
            // backtrack(newList, newResult);
            int temp = list.remove(i);
            result.add(temp);
            backtrack(list, result);
            list.add(i, temp);
            result.remove(result.size()-1);
        }
        return;
    }
}
</code></pre>
<p>两种方法，一是每次回溯函数传入的参数都重新生成（newList和newResult），这时最终的result不用重新生成，直接用参数就好（(1）处）。<br>二是不生成新list，移除之前要保存，执行完回溯函数再还原。这时，最终的result要新生成 。</p>
]]></content>
      
        <categories>
            
            <category> LeetCode-Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[42. 接雨水]]></title>
      <url>/2019/10/05/LeetCode-Java/42.%20%E6%8E%A5%E9%9B%A8%E6%B0%B4/</url>
      <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述 **"></a>题目描述 **</h2><p>图见 <a href="https://leetcode-cn.com/problems/trapping-rain-water" target="_blank" rel="external">链接</a><br>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。<br>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。</p>
<p>示例:</p>
<pre><code>输入: [0,1,0,2,1,0,1,3,2,1,2,1]
输出: 6
</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h4 id="解法一-动态规划"><a href="#解法一-动态规划" class="headerlink" title="解法一 动态规划"></a>解法一 动态规划</h4><p>我们注意到，解法二中。对于每一列，我们求它左边最高的墙和右边最高的墙，都是重新遍历一遍所有高度，这里我们可以优化一下。</p>
<p>首先用两个数组，max_left [i] 代表第 i 列左边最高的墙的高度，max_right[i] 代表第 i 列右边最高的墙的高度。（一定要注意下，第 i 列左（右）边最高的墙，是不包括自身的，和 leetcode 上边的讲的有些不同）</p>
<p>对于 max_left我们其实可以这样求。</p>
<p>max_left [i] = Max(max_left [i-1],height[i-1])。它前边的墙的左边的最高高度和它前边的墙的高度选一个较大的，就是当前列左边最高的墙了。</p>
<p>对于 max_right我们可以这样求。</p>
<p>max_right[i] = Max(max_right[i+1],height[i+1]) 。它后边的墙的右边的最高高度和它后边的墙的高度选一个较大的，就是当前列右边最高的墙了。</p>
<p>这样，我们再利用解法二的算法，就不用在 for 循环里每次重新遍历一次求 max_left 和 max_right 了。</p>
<pre><code class="Java">class Solution {
    public int trap(int[] height) {
        int n = height.length;
        int sum = 0;
        int[] maxLeft = new int[n];
        int[] maxRight = new int[n];
        for(int i=1; i&lt;n; i++) maxLeft[i] = Math.max(maxLeft[i-1], height[i-1]);
        for(int i=n-2; i&gt;=0; i--) maxRight[i] = Math.max(maxRight[i+1], height[i+1]);

        for(int i=1; i&lt;n-1; i++) {
            int h = Math.min(maxLeft[i], maxRight[i]);
            if(h &gt; height[i]) sum += h - height[i];
        }
        return sum;
    }
}
</code></pre>
<h4 id="解法二-双指针"><a href="#解法二-双指针" class="headerlink" title="解法二 双指针"></a>解法二 双指针</h4><p>类似于<a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="external">11. 盛最多水的容器</a></p>
<pre><code class="Java">class Solution {
    public int trap(int[] height) {
        if(height.length == 0) return 0;
        int l = 0, r = height.length-1;
        int maxL = height[l], maxR = height[r];
        int sum = 0;
        while(l &lt; r) {
            if(height[l] &lt;= height[r]) {
                // 此时height[r]是最大值，也一定比maxL大
                if(height[l] &lt; maxL) sum += maxL - height[l];
                else if(height[l] &gt; maxL) maxL = height[l];
                l++;
            }
            else {
                // 此时height[l]是最大值，也一定比maxR大
                if(height[r] &lt; maxR) sum += maxR - height[r];
                else if(height[r] &gt; maxR) maxR = height[r];
                r--;
            }
        }
        return sum;
    }
}
</code></pre>
]]></content>
      
        <categories>
            
            <category> LeetCode-Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[39. 组合总和]]></title>
      <url>/2019/10/05/LeetCode-Java/39.%20%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/</url>
      <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述 **"></a>题目描述 **</h2><p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。<br>candidates 中的数字可以无限制重复被选取。<br>说明：</p>
<ul>
<li>所有数字（包括 target）都是正整数。</li>
<li>解集不能包含重复的组合。  </li>
</ul>
<p>示例 1:</p>
<pre><code>输入: candidates = [2,3,6,7], target = 7,
所求解集为:
[
  [7],
  [2,2,3]
]
</code></pre><p>示例 2:</p>
<pre><code>输入: candidates = [2,3,5], target = 8,
所求解集为:
[
  [2,2,2,2],
  [2,3,3],
  [3,5]
]
</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><pre><code class="Java">class Solution {
    List&lt;List&lt;Integer&gt;&gt; results = new ArrayList&lt;&gt;();

    public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) {
        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();
        backtrack(candidates, 0, target, result);
        return results;
    }

    public void backtrack(int[] candidates, int p, int target, List&lt;Integer&gt; result) {
        if(target == 0) {
            results.add(result);
            return;
        }
        if(p &gt;= candidates.length) return;

        for(int i=0; i&lt;=target/candidates[p]; i++) {
            // 每次回溯都要建立新list！！！
            List&lt;Integer&gt; newResult = new ArrayList&lt;&gt;(result);
            for(int j=0; j&lt;i; j++) newResult.add(candidates[p]);
            backtrack(candidates, p+1, target-candidates[p]*i, newResult);
        }
        return;
    }
}
</code></pre>
]]></content>
      
        <categories>
            
            <category> LeetCode-Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[34. 在排序数组中查找元素的第一个和最后一个位置]]></title>
      <url>/2019/10/05/LeetCode-Java/34.%20%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述 **"></a>题目描述 **</h2><p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p>
<p>你的算法时间复杂度必须是 O(log n) 级别。</p>
<p>如果数组中不存在目标值，返回 [-1, -1]。</p>
<p>示例 1:</p>
<pre><code>输入: nums = [5,7,7,8,8,10], target = 8
输出: [3,4]
</code></pre><p>示例 2:</p>
<pre><code>输入: nums = [5,7,7,8,8,10], target = 6
输出: [-1,-1]
</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><pre><code class="Java">class Solution {
    public int[] searchRange(int[] nums, int target) {
        int[] result = {-1, -1};
        if(nums.length == 0) return result;

        // 找左边界
        int l = 0, r = nums.length - 1;
        while(l &lt;= r) {
            int mid = (l + r) / 2;
            if(nums[mid] == target) r = mid - 1;
            else if(nums[mid] &lt; target) l = mid + 1;
            else if(nums[mid] &gt; target) r = mid - 1;
        }
        if(l &lt;= nums.length-1 &amp;&amp; nums[l] == target) result[0] = l;
        else return result;

        // 找右边界
        l = 0; r = nums.length - 1;
        while(l &lt;= r) {
            int mid = (l + r) / 2;
            if(nums[mid] == target) l = mid + 1;
            else if(nums[mid] &lt; target) l = mid + 1;
            else if(nums[mid] &gt; target) r = mid - 1;
        }
        if(r &gt;= 0 &amp;&amp; nums[r] == target) result[1] = r;
        return result;
    }
}
</code></pre>
<h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p>注意二分查找的边界值<br>详见题解中的<a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/er-fen-cha-zhao-suan-fa-xi-jie-xiang-jie-by-labula/" target="_blank" rel="external">二分查找算法细节详解</a></p>
<blockquote>
<p>我这里把 “找左边界” 和 “找右边界” 统一成了用闭区间的形式去实现，从语意上感觉更方便理解和记忆。需要注意的是，原本 “闭区间法” 的特性是，跳出循环时，必有left - 1 = right。此时，若存在target，则恰有right处于右边界，left处于左边界。<br>另外，这里left = mid + 1 和 right = mid - 1 都是运用“闭区间”的概念获得的。</p>
</blockquote>
<pre><code class="Python">class Solution(object):
    def searchRange(self, nums, target):
        return [self.left_bound(nums,target), self.right_bound(nums,target)]

    def right_bound(self, nums, target):
        if len(nums) == 0:
            return -1
        left, right = 0, len(nums) - 1
        while left &lt;= right:
            mid = (left + right) // 2
            if nums[mid] == target:
                left = mid + 1
            elif nums[mid] &lt; target:
                left = mid + 1
            elif nums[mid] &gt; target:
                right = mid - 1
        if right &gt;= 0 and nums[right] == target: return right # 注意
        else: return -1

    def left_bound(self, nums, target):
        if len(nums) == 0:
            return -1
        left, right = 0, len(nums) - 1

        while left &lt;= right:
            mid = (left + right) // 2
            if nums[mid] == target:
                right = mid - 1
            elif nums[mid] &lt; target:
                left = mid + 1
            elif nums[mid] &gt; target:
                right = mid - 1
        if left &lt;= len(nums)-1 and nums[left] == target: return left  # 注意
        else: return -1
</code></pre>
]]></content>
      
        <categories>
            
            <category> LeetCode-Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[33. 搜索旋转排序数组]]></title>
      <url>/2019/10/05/LeetCode-Java/33.%20%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
      <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述 *"></a>题目描述 <em>*</em></h2><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p>
<p>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。</p>
<p>你可以假设数组中不存在重复的元素。</p>
<p>你的算法时间复杂度必须是 O(log n) 级别。</p>
<p>示例 1:</p>
<pre><code>输入: nums = [4,5,6,7,0,1,2], target = 0
输出: 4
</code></pre><p>示例 2:</p>
<pre><code>输入: nums = [4,5,6,7,0,1,2], target = 3
输出: -1
</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>由于题目要求时间复杂度为 O(log n)，故实现为二分法查找，关于二分法，一般存在 low,high,mid位，来辅助判断。</p>
<ul>
<li>如果 target 在[mid+1,high] 序列中，则low = mid+1,否则 high = mid,关键是如何判断 target在[mid+1,high]序列中,具体判断如下：</li>
<li>当[0, mid] 序列是升序: nums[0] &lt;= nums[mid], 当target &gt; nums[mid] || target &lt; nums[0] ,则向后规约</li>
<li>当[0, mid] 序列存在旋转位: nums[0] &gt; nums[mid],当target &lt; nums[0] &amp;&amp; target &gt; nums[mid],则向后规约</li>
<li>当然其他其他情况就是向前规约了  </li>
</ul>
<p>循环判断，直到排除到只剩最后一个元素时，退出循环，如果该元素和 target 相同，直接返回下标，否则返回 -1。</p>
<pre><code class="Java">class Solution {
    public int search(int[] nums, int target) {
        if(nums.length == 0) return -1;
        int l = 0, r = nums.length-1;
        while(l &lt; r) {
            int mid = (l + r) / 2;
            if(nums[l] &lt;= nums[mid] &amp;&amp; (nums[l] &gt; target || nums[mid] &lt; target)) l = mid + 1;
            else if(nums[l] &gt; target &amp;&amp; nums[mid] &lt; target) l = mid + 1;
            else r = mid;
        }
        if(target == nums[l]) return l;
        else return -1;
    }
}
</code></pre>
]]></content>
      
        <categories>
            
            <category> LeetCode-Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[32. 最长有效括号]]></title>
      <url>/2019/10/05/LeetCode-Java/32.%20%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/</url>
      <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述  **"></a>题目描述  <em>**</em></h2><p>给定一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长的包含有效括号的子串的长度。</p>
<p>示例 1:</p>
<pre><code>输入: &quot;(()&quot;
输出: 2
解释: 最长有效括号子串为 &quot;()&quot;
</code></pre><p>示例 2:</p>
<pre><code>输入: &quot;)()())&quot;
输出: 4
解释: 最长有效括号子串为 &quot;()()&quot;
</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h4 id="解法一-栈"><a href="#解法一-栈" class="headerlink" title="解法一 栈"></a>解法一 栈</h4><p>栈中保存左括号的下标，右括号出栈</p>
<h5 id="错误代码！"><a href="#错误代码！" class="headerlink" title="错误代码！"></a>错误代码！</h5><pre><code class="Java">/* 
错误代码！
输入: &quot;)()())&quot;
输出: 2
预期结果：4
*/
class Solution {
    public int longestValidParentheses(String s) {
        Deque&lt;Integer&gt; stack = new ArrayDeque&lt;&gt;();
        int maxLength = 0;
        for(int i=0; i&lt;s.length(); i++) {
            if(s.charAt(i) == &#39;(&#39;) {
                stack.push(i);
            }
            else if(!stack.isEmpty()) {
                int j = stack.pop();
                int curLength = i - j + 1;
                maxLength = Math.max(maxLength, curLength);
            }
        }
        return maxLength;
    }
}
</code></pre>
<p>需要在左括号加一个界限，避免左括号出栈时丢失当前最长串的开始位置。<br>右括号出现有两种情况，一是右括号数大于左括号，有效串结束，出栈时除了把所有左括号出栈，还会把有效串开始位置出栈。下一个有效串的开始位置改变，要把当前位置进栈作为开始位置。<br>二是右括号小于或等于左括号，有效串未结束，相同数量的左括号出栈，栈中仍有有效串开始位置，有效串长度增加，可直接计算。</p>
<pre><code class="Java">class Solution {
    public int longestValidParentheses(String s) {
        Deque&lt;Integer&gt; stack = new ArrayDeque&lt;&gt;();
        int maxLength = 0;
        stack.push(-1);
        for(int i=0; i&lt;s.length(); i++) {
            if(s.charAt(i) == &#39;(&#39;) {
                stack.push(i);
            }
            else {
                stack.pop();
                if(stack.isEmpty()) {
                    stack.push(i);
                }
                else {
                    maxLength = Math.max(maxLength, i-stack.peek());
                }
            }
        }
        return maxLength;
    }
}
</code></pre>
]]></content>
      
        <categories>
            
            <category> LeetCode-Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[31. 下一个排列]]></title>
      <url>/2019/10/04/LeetCode-Java/31.%20%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/</url>
      <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述 **"></a>题目描述 **</h2><p>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</p>
<p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p>
<p>必须原地修改，只允许使用额外常数空间。</p>
<p>以下是一些例子，输入位于左侧列，其相应输出位于右侧列。<br>1,2,3 → 1,3,2<br>3,2,1 → 1,2,3<br>1,1,5 → 1,5,1</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><ol>
<li>从后往前扫描找到第一个下标i,使得nums[i] &lt; nums[i + 1];</li>
<li>若i = -1，表示该数组为单调递减序列;否则，从后往前扫描找到找到第一个下标j使得nums[j] &gt; nums[i]，交换两数且不破坏nums(i, nums.length)的单调性；</li>
<li>翻转nums(i, nums.length)使其成为单调增序列。</li>
</ol>
<pre><code class="Java">class Solution {
    public void nextPermutation(int[] nums) {
        int i = nums.length - 1;
        int temp;
        while(i &gt; 0) {
            if(nums[i-1] &lt; nums[i]) break;
            i--;
        }
        if(i == 0) {
            // 输入排列为从大到小，需反转为从小到大
            for(int l = 0, r = nums.length-1; l &lt; r; l++, r--) {
                swap(nums, l, r);
            }
            return;
        }
        i = i-1;
        // 从后往前找出第一个比nums[i]大的数，交换
        int j=nums.length-1;
        while(nums[j] &lt;= nums[i]) j--;
        swap(nums, i, j);

        // 反转后面的元素，使其最小
        for(int l=i+1, r=nums.length-1; l&lt;r; l++, r--) {
            swap(nums, l, r);
        }
        return;
    }
    public void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
</code></pre>
]]></content>
      
        <categories>
            
            <category> LeetCode-Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[23. 合并K个排序链表]]></title>
      <url>/2019/10/04/LeetCode-Java/23.%20%E5%90%88%E5%B9%B6K%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
      <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述 *"></a>题目描述 <em>*</em></h2><p>合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</p>
<p>示例:</p>
<pre><code>输入:
[
  1-&gt;4-&gt;5,
  1-&gt;3-&gt;4,
  2-&gt;6
]
输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6
</code></pre><h2 id="题解（注意各种算法的复杂度分析）"><a href="#题解（注意各种算法的复杂度分析）" class="headerlink" title="题解（注意各种算法的复杂度分析）"></a>题解（注意各种算法的复杂度分析）</h2><h4 id="方法一-暴力法"><a href="#方法一-暴力法" class="headerlink" title="方法一 暴力法"></a>方法一 暴力法</h4><ul>
<li>遍历所有链表，将所有节点的值放到一个数组中。</li>
<li>将这个数组排序，然后遍历所有元素得到正确顺序的值。</li>
<li>用遍历得到的值，创建一个新的有序链表。  </li>
</ul>
<h5 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ul>
<li>时间复杂度：O(NlogN) ，其中N是节点的总数目。<ul>
<li>遍历所有的值需花费 O(N) 的时间。</li>
<li>一个稳定的排序算法花费 O(NlogN) 的时间。</li>
<li>遍历同时创建新的有序链表花费 O(N)O(N) 的时间。</li>
</ul>
</li>
<li>空间复杂度：O(N) 。<ul>
<li>排序花费O(N)空间（这取决于你选择的算法）。</li>
<li>创建一个新的链表花费 O(N) 的空间。</li>
</ul>
</li>
</ul>
<h4 id="方法二-逐一比较"><a href="#方法二-逐一比较" class="headerlink" title="方法二 逐一比较"></a>方法二 逐一比较</h4><h5 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h5><ul>
<li>比较k 个节点（每个链表的首节点），获得最小值的节点。</li>
<li>将选中的节点接在最终有序链表的后面。</li>
</ul>
<h5 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ul>
<li>时间复杂度： O(kN) ，其中k是链表的数目。<ul>
<li>几乎最终有序链表中每个节点的时间开销都为 O(k) （k-1 次比较）。</li>
<li>总共有 N 个节点在最后的链表中。</li>
</ul>
</li>
<li>空间复杂度：<ul>
<li>O(n) 。创建一个新的链表空间开销为 O(n) 。</li>
<li>O(1) 。重复利用原来的链表节点，每次选择节点时将它直接接在最后返回的链表后面，而不是创建一个新的节点。</li>
</ul>
</li>
</ul>
<h4 id="方法三-优先队列"><a href="#方法三-优先队列" class="headerlink" title="方法三 优先队列"></a>方法三 优先队列</h4><pre><code class="Java">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        if(lists.length == 0) return null;
        Queue&lt;ListNode&gt; queue = new PriorityQueue&lt;&gt;(new ListNodeComparator());
        // 也可以不自定义Comparator，采用更简洁的方法
        // Queue&lt;ListNode&gt; queue = new PriorityQueue&lt;&gt;(Comparator.comparingInt(node -&gt; node.val));

        for(ListNode l : lists) 
            if(l != null) queue.offer(l);

        ListNode result = new ListNode(-1);
        ListNode temp = result;
        while(!queue.isEmpty()) {
            int curValue = queue.peek().val;
            // 可以不与自身比较，直接插入优先队列中来排序。这里为了减少部分插入移出队列的开销，加入了与自身比较。但时间复杂度是同数量级的。
            while(temp.next != null &amp;&amp; temp.next.val &lt;= curValue) temp = temp.next;
            if(temp.next != null) queue.offer(temp.next);
            temp.next = queue.poll();
        }
        return result.next;
    }

    class ListNodeComparator implements Comparator&lt;ListNode&gt; {
        public int compare(ListNode l1, ListNode l2) {
            if(l1.val &lt; l2.val) return -1;
            else if(l1.val &gt; l2.val) return 1;
            else return 0;
        }
    }
}
</code></pre>
<ul>
<li>放入PriorityQueue的元素，必须实现Comparable接口，PriorityQueue会根据元素的排序顺序决定出队的优先级。如果我们要放入的元素并没有实现Comparable接口怎么办？PriorityQueue允许我们提供一个Comparator对象来判断两个元素的顺序。</li>
</ul>
<h5 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ul>
<li>时间复杂度： O(Nlogk) ，其中k是链表的数目。<ul>
<li>弹出操作时，比较操作的代价会被优化到 O(logk) 。同时，找到最小值节点的时间开销仅仅为 O(1)。</li>
<li>最后的链表中总共有 N 个节点。</li>
</ul>
</li>
<li>空间复杂度：<ul>
<li>O(n) 。创造一个新的链表需要 O(n) 的开销。</li>
<li>O(k) 。以上代码采用了重复利用原有节点，所以只要O(1)的空间。同时优先队列（通常用堆实现）需要O(k) 的空间（远比大多数情况的 N要小）。</li>
</ul>
</li>
</ul>
<h4 id="方法四-逐一两两合并链表"><a href="#方法四-逐一两两合并链表" class="headerlink" title="方法四 逐一两两合并链表"></a>方法四 逐一两两合并链表</h4><h5 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ul>
<li>时间复杂度：O(kN), 其中k是链表的数目。</li>
<li>空间复杂度：O(1)</li>
</ul>
<h4 id="方法五-分治合并链表"><a href="#方法五-分治合并链表" class="headerlink" title="方法五 分治合并链表"></a>方法五 分治合并链表</h4><h5 id="复杂度分析-4"><a href="#复杂度分析-4" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ul>
<li>时间复杂度：O(Nlogk)</li>
<li>空间复杂度：O(1)</li>
</ul>
<blockquote>
<p>分治的聚合次数不是logK次，是K-1次，每次聚合只会减少一个链表，聚合K-1次得到最终链表。 无论是分治法还是逐一聚合法都是如此。</p>
<p>两个链表聚合确实发生了K-1次。但是注意，题解中把 K个链表两两聚合，生成K/2个链表的过程叫一次Merging。然后这样的Merging总共发生log(K)次。每一次Merging需要比较的次数是N。 所以总的时间复杂度是O(N<em>log(K))。 这才是两两聚合和逐一聚合的本质差别。 逐一聚合的情况下，两个聚合的链表长度会发生偏斜，其中一个链表长度越来越长。考虑最坏情况K个链表每个仅包含一个元素（N为总元素数，这里N=K)，那么逐一聚合的总复杂度就是O(1+2+3+…N-1) = O(K</em>N). 而两两聚合的情况下，仍然考虑刚才的例子，<br>第一轮K个链表，聚合完成后剩K/2个，发生的比较次数是 1 + 1 + 1 + …+ 1 =1<em>K = N.<br>第二轮K/2个链表，聚合完成后剩K/4个，发生的比较次数是(最坏情况) 2+2+2+ … + 2 = 2 </em> K/2 = N .<br>第三轮K/4个链表，聚合完成后剩K/8个，发生的比较次数 4 + 4 + 4 + …. + 4 = 4 <em> K/4 = N .<br>…..<br>最后一轮剩2个链表，比较次数 K/2 + K/2 = 2</em> K/2 = N .<br>总共有log(K)轮，总比较次数 N*log(K)</p>
</blockquote>
<pre><code class="Java">class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        if(lists.length == 0) return null;
        return solve(lists, 0, lists.length-1);
    }

    private ListNode solve(ListNode[] arr, int left, int right){
        if(left == right) return arr[left];

        int mid = (left + right) &gt;&gt; 1; 
        ListNode lNode = solve(arr, left, mid);   
        ListNode rNode = solve(arr, mid+1, right); 

        return merge(lNode, rNode);
    }

    private ListNode merge(ListNode node1, ListNode node2){
        if(node1 == null) return node2;
        if(node2 == null) return node1;

        if(node1.val &lt; node2.val){
            node1.next = merge(node1.next, node2);
            return node1;
        }else{
            node2.next = merge(node1, node2.next);
            return node2;
        }
    }
}
</code></pre>
<p>典型的归并分治思想，自底向上，依次合并(可结合归并排序理解，将每个链表理解成排序的值)</p>
<p>分治法：</p>
<ol>
<li>分解原问题为若干个子问题，这些子问题是原问题的规模较小的实例；</li>
<li>解决这些子问题，递归地求解各子问题的规模足够小，则直接求解；</li>
<li>合并这些子问题的解即可得到原问题的解。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> LeetCode-Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[22. 括号生成]]></title>
      <url>/2019/10/04/LeetCode-Java/22.%20%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/</url>
      <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述 **"></a>题目描述 <em>**</em></h2><p>给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。</p>
<p>例如，给出 n = 3，生成结果为：</p>
<pre><code>[
  &quot;((()))&quot;,
  &quot;(()())&quot;,
  &quot;(())()&quot;,
  &quot;()(())&quot;,
  &quot;()()()&quot;
]
</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h4 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h4><p>回溯？<br>将n个左括号放入list中，探索n个右括号可以插入的位置。要保证右括号数不能多于其左边的左括号数。第一个左括号后面只能跟一个右括号，而第n个左括号后面最多可以跟n个右括号。<br>所以，用回溯法从后往前遍历所有情况。</p>
<pre><code class="Java">class Solution {
    List&lt;String&gt; results = new ArrayList&lt;&gt;();
    public List&lt;String&gt; generateParenthesis(int n) {
        List&lt;String&gt; list = new ArrayList&lt;&gt;();
        for(int i=0; i&lt;n; i++) list.add(&quot;(&quot;);
        insert(list, n, n);
        // 开始时最后面（n的位置）留下n个右括号
        return results;
    }

    // 当前位置p剩下的可插入右括号数目n
    public void insert (List&lt;String&gt; list, int p, int n) {
        if(n == 0) {
            results.add(String.join(&quot;&quot;, list));
            // List&lt;String&gt; to String
            return;
        }
        if(n &gt; p) {
            return;
        }

        for(int i=0; i&lt;=n; i++) {

            List&lt;String&gt; newList = new ArrayList&lt;&gt;(list);
            // 当前位置插入i个右括号
            for(int j=0; j&lt;i; j++){
                newList.add(p, &quot;)&quot;);
            }
            // 前一位置可插入的右括号数
            insert(newList, p-1, n-i);
        };
    }
}
</code></pre>
<h4 id="解法二"><a href="#解法二" class="headerlink" title="解法二 *"></a>解法二 *</h4><p>如果我们还剩一个位置，我们可以开始放一个左括号。 如果它不超过左括号的数量，我们可以放一个右括号。</p>
<pre><code class="Java">class Solution {
    List&lt;String&gt; results = new ArrayList&lt;&gt;();
    public List&lt;String&gt; generateParenthesis(int n) {
        backtrack(&quot;&quot;, 0, 0, n);
        return results;
    }
    public void backtrack(String cur, int left, int right, int n) {
        if(left == n &amp;&amp; right == n) {
            results.add(cur);
            return;
        }
        if(left &lt; n) backtrack(cur+&quot;(&quot;, left+1, right, n);
        if(right &lt; left) backtrack(cur+&quot;)&quot;, left, right+1, n);
    }
}
</code></pre>
<h4 id="解法三"><a href="#解法三" class="headerlink" title="解法三 *"></a>解法三 *</h4><p>当我们清楚所有i&lt; n时括号的可能生成排列后，对与 i=n 的情况，我们考虑整个括号排列中最左边的括号。<br>它一定是一个左括号，那么它可以和它对应的右括号组成一组完整的括号”()”，我们认为这一组是相比 n-1 增加进来的括号。</p>
<p>那么，剩下 n-1 组括号有可能在哪呢？</p>
<p>【这里是重点，请着重理解】</p>
<p>剩下的括号要么在这一组新增的括号内部，要么在这一组新增括号的外部（右侧）。</p>
<p>既然知道了 i &lt; n 的情况，那我们就可以对所有情况进行遍历：</p>
<p>“(“ + 【i=p时所有括号的排列组合】 + “)” + 【i=q时所有括号的排列组合】</p>
<p>其中 p + q = n-1，且 p q 均为非负整数。</p>
<p>事实上，当上述 p 从 0 取到 n-1，q 从 n-1 取到 0 后，所有情况就遍历完了。</p>
<p>注：上述遍历是没有重复情况出现的，即当 (p1,q1)≠(p2,q2) 时，按上述方式取的括号组合一定不同。</p>
<pre><code class="Java">class Solution {
    public List&lt;String&gt; generateParenthesis(int n) {
        List&lt;List&lt;String&gt;&gt; results = new ArrayList&lt;&gt;();
        List&lt;String&gt; list0 = new ArrayList&lt;&gt;();
        list0.add(&quot;&quot;);
        results.add(list0);

        for(int i=1; i&lt;=n; i++) { // i对括号可生成的排列
            List&lt;String&gt; newList = new ArrayList&lt;&gt;();
            for(int j=0; j&lt;=i-1; j++) { // 括号内的括号对数j
                List&lt;String&gt; leftList = results.get(j);
                List&lt;String&gt; rightList = results.get(i-j-1);
                for(String s1:leftList) {
                    for(String s2:rightList) {
                        newList.add(&quot;(&quot; + s1 + &quot;)&quot; + s2);
                    }
                }
            }
            results.add(newList);
        }

        return results.get(n);
    }
}
</code></pre>
<h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><h4 id="递归和回溯的区别"><a href="#递归和回溯的区别" class="headerlink" title="递归和回溯的区别"></a>递归和回溯的区别</h4><blockquote>
<p>为了描述问题的某一状态，必须用到该状态的上一状态，而描述上一状态，又必须用到上一状态的上一状态……这种用自已来定义自己的方法，称为递归定义。形式如 f(n) = n<em>f(n-1), if n=0,f(n)=1.<br>从问题的某一种可能出发, 搜索从这种情况出发所能达到的所有可能, 当这一条路走到”尽头”的时候, 再倒回出发点, 从另一个可能出发, 继续搜索. 这种不断”回溯 “寻找解的方法, 称作”回溯法”。<br>递归是一种算法结构，递归会出现在子程序中自己调用自己或间接地自己调用自己。最直接的递归应用就是计算连续数的阶乘，计算规律：n!=(n-1)!</em>n。<br>观察阶乘计算的规律，前一个数结成的结果可以直接被应用到后一个数结成的计算中。</p>
</blockquote>
<pre><code>int fac（int n）
if（n==1）
return n;
else
return n*fac(n-1);
</code></pre><blockquote>
<p>回溯是一种算法思想，可以用递归实现。通俗点讲回溯就是一种试探，类似于穷举，但回溯有“剪枝”功能，比如求和问题。给定7个数字，1 2 3 4 5 6 7求和等于7的组合，从小到大搜索，选择1+2+3+4 =10&gt;7，已经超过了7，之后的5 6 7就没必要在继续了，这就是一种搜索过程的优化。如果还有不清楚的可以看一下8皇后问题。  </p>
</blockquote>
<h4 id="递归和迭代的区别"><a href="#递归和迭代的区别" class="headerlink" title="递归和迭代的区别"></a>递归和迭代的区别</h4><blockquote>
<ol>
<li>递归的基本概念:程序调用自身的编程技巧称为递归,是函数自己调用自己.一个函数在其定义中直接或间接调用自身的一种方法,它通常把一个大型的复杂的问题转化为一个与原问题相似的规模较小的问题来解决,可以极大的减少代码量.递归的能力在于用有限的语句来定义对象的无限集合。  </li>
<li>迭代:利用变量的原值推算出变量的一个新值.如果递归是自己调用自己的话,迭代就是A不停的调用B。  </li>
<li>递归中一定有迭代,但是迭代中不一定有递归,大部分可以相互转换.能用迭代的不用递归,递归调用函数,浪费空间,并且递归太深容易造成堆栈的溢出。</li>
</ol>
</blockquote>
]]></content>
      
        <categories>
            
            <category> LeetCode-Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[21. 合并两个有序链表]]></title>
      <url>/2019/10/04/LeetCode-Java/21.%20%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
      <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><del>题目描述</del></h2><p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
<p>示例：</p>
<pre><code>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4
输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4
</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><pre><code class="Java">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode l3 = new ListNode(-1);
        ListNode temp3 = l3;

        ListNode temp1 = l1, temp2 = l2;

        while(temp1 != null &amp;&amp; temp2 != null) {
            if(temp1.val &lt;= temp2.val ) {
                temp3.next = temp1;
                temp1 = temp1.next;
            }
            else {
                temp3.next = temp2;
                temp2 = temp2.next;
            }
            temp3 = temp3.next;
        }
        temp3.next = temp1 == null ? temp2 : temp1;
        return l3.next;
    }
}
</code></pre>
]]></content>
      
        <categories>
            
            <category> LeetCode-Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[20. 有效的括号]]></title>
      <url>/2019/10/03/LeetCode-Java/20.%20%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</url>
      <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><del>题目描述</del></h2><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。</p>
<p>示例 1:</p>
<pre><code>输入: &quot;()&quot;
输出: true
</code></pre><p>示例 2:</p>
<pre><code>输入: &quot;()[]{}&quot;
输出: true
</code></pre><p>示例 3:</p>
<pre><code>输入: &quot;(]&quot;
输出: false
</code></pre><p>示例 4:</p>
<pre><code>输入: &quot;([)]&quot;
输出: false
</code></pre><p>示例 5:</p>
<pre><code>输入: &quot;{[]}&quot;
输出: true
</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><pre><code class="Java">class Solution {
    public boolean isValid(String s) {
        Deque&lt;Character&gt; stack = new ArrayDeque&lt;&gt;();
        for(int i=0; i&lt;s.length(); i++) {
            char c = s.charAt(i);
            switch(c) {
                case &#39;(&#39;:
                case &#39;[&#39;:
                case &#39;{&#39;:
                    stack.push(c);
                    break;
                case &#39;)&#39;:
                    if(stack.isEmpty() || stack.pop() != &#39;(&#39;) return false;
                    // 出栈之前别忘了判断栈是否为空
                    break;
                case &#39;]&#39;:
                    if(stack.isEmpty() || stack.pop() != &#39;[&#39;) return false;
                    break;
                case &#39;}&#39;:
                    if(stack.isEmpty() || stack.pop() != &#39;{&#39;) return false;
                    break;
            }
        }
        return stack.isEmpty();             
    }
}
</code></pre>
]]></content>
      
        <categories>
            
            <category> LeetCode-Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[19. 删除链表的倒数第N个节点]]></title>
      <url>/2019/10/03/LeetCode-Java/19.%20%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
      <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><del>题目描述</del></h2><p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p>
<p>示例：</p>
<pre><code>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.

当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.
</code></pre><p>说明：</p>
<p>给定的 n 保证是有效的。</p>
<p>进阶：</p>
<p>你能尝试使用一趟扫描实现吗？</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>双指针</p>
<pre><code class="Java">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode right = head;
        for(int i=0; i&lt;n; i++) {
            right = right.next;
        }
        ListNode left = head;
        // 删除头结点(倒数第n个结点)的情况要单独讨论
        if(right == null) {
            left = left.next;
            return left;
        }
        else {
            while(right.next != null) {
                right = right.next;
                left = left.next;
            }
            left.next = left.next.next;
            return head;
        }      
    }
}
</code></pre>
]]></content>
      
        <categories>
            
            <category> LeetCode-Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[17. 电话号码的字母组合]]></title>
      <url>/2019/10/03/LeetCode-Java/17.%20%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/</url>
      <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述 **"></a>题目描述 **</h2><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<p>示例:</p>
<pre><code>输入：&quot;23&quot;
输出：[&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].
</code></pre><p>说明:<br>尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>回溯是一种通过穷举所有可能情况来找到所有解的算法。如果一个候选解最后被发现并不是可行解，回溯算法会舍弃它，并在前面的一些步骤做出一些修改，并重新尝试找到可行解。</p>
<p>给出如下回溯函数 backtrack(combination, next_digits) ，它将一个目前已经产生的组合 combination 和接下来准备要输入的数字 next_digits 作为参数。</p>
<p>如果没有更多的数字需要被输入，那意味着当前的组合已经产生好了。<br>如果还有数字需要被输入：<br>遍历下一个数字所对应的所有映射的字母。<br>将当前的字母添加到组合最后，也就是 combination = combination + letter 。<br>重复这个过程，输入剩下的数字： backtrack(combination + letter, next_digits[1:]) 。</p>
<pre><code class="Java">class Solution {
    Map&lt;String, String&gt; map = new HashMap&lt;&gt;();
    // map 初始化
    {
        map.put(&quot;2&quot;, &quot;abc&quot;);
        map.put(&quot;3&quot;, &quot;def&quot;);
        map.put(&quot;4&quot;, &quot;ghi&quot;);
        map.put(&quot;5&quot;, &quot;jkl&quot;);
        map.put(&quot;6&quot;, &quot;mno&quot;);
        map.put(&quot;7&quot;, &quot;pqrs&quot;);
        map.put(&quot;8&quot;, &quot;tuv&quot;);
        map.put(&quot;9&quot;, &quot;wxyz&quot;);
    }
    List&lt;String&gt; result = new ArrayList&lt;&gt;();
    public List&lt;String&gt; letterCombinations(String digits) {
        if(digits.length() != 0) backtrack(&quot;&quot;, digits);
        return result;
    }
    public void backtrack(String s, String digits) {
        if(digits.length() == 0) {
            result.add(s);
            return;
        }
        String match = map.get(digits.substring(0,1));
        for(int i=0; i&lt;match.length(); i++) {
            String letter = match.substring(i, i+1);
            backtrack(s+letter, digits.substring(1));
        }
    }
}
</code></pre>
<h5 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ul>
<li><p>时间复杂度： O(3^N * 4^M)，其中 N 是输入数字中对应 3 个字母的数目（比方说 2，3，4，5，6，8）， M 是输入数字中对应 4 个字母的数目（比方说 7，9），N+M 是输入数字的总数。</p>
</li>
<li><p>空间复杂度：O(3^N <em> 4^M) ，这是因为需要保存 3^N </em> 4^M个结果。</p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> LeetCode-Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[15. 三数之和]]></title>
      <url>/2019/10/02/LeetCode-Java/15.%20%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述 *"></a>题目描述 *</h2><p>给定一个包含 n 个整数的数组nums，判断nums中是否存在三个元素 a，b，c ，使得a + b + c = 0 ？找出所有满足条件且不重复的三元组。</p>
<p>注意：答案中不可以包含重复的三元组。</p>
<pre><code>例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，

满足要求的三元组集合为：
[
  [-1, 0, 1],
  [-1, -1, 2]
]
</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先对数组进行排序，排序后固定一个数nums[i]，再使用左右指针指向nums[i]后面的两端，数字分别为 nums[L] 和 nums[R]，计算三个数的和 sum 判断是否满足为 0，满足则添加进结果集<br>如果 nums[i]大于 0，则三数之和必然无法等于 0，结束循环<br>如果 nums[i]==nums[i−1]，则说明该数字重复，会导致结果重复，所以应该跳过<br>当 sum == 0 时，nums[L]==nums[L+1]则会导致结果重复，应该跳过，L++<br>当 sum == 0 时，nums[R] == nums[R−1] 则会导致结果重复，应该跳过，R−−<br>时间复杂度：O(n^2)，n 为数组长度</p>
<pre><code class="Java">class Solution {
    public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) {
        Arrays.sort(nums);
        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();
        int i = 0;
        while(i &lt; nums.length - 2){
            int a = nums[i];
            if(a &gt; 0) break;  // 最小值都大于0，那么不可能有解
            int j = i+1, k = nums.length - 1;
            while(j &lt; k){
                if(nums[j] + nums[k] == -a) {
                    result.add(Arrays.asList(a, nums[j], nums[k]));
                    j++; k--;
                    while(j &lt; k &amp;&amp; nums[j] == nums[j-1]) j++;
                    while(k &gt; j &amp;&amp; nums[k] == nums[k+1]) k--;
                }
                else if(nums[j] + nums[k] &lt; -a) {
                    j++;
                    while(j &lt; k &amp;&amp; nums[j] == nums[j-1]) j++;
                }
                else if(nums[j] + nums[k] &gt; -a) {
                    k--;
                    while(k &gt; j &amp;&amp; nums[k] == nums[k+1]) k--;
                }
            }
            i++;
            while(i &lt; nums.length - 2 &amp;&amp; nums[i] == nums[i-1]) i++;
        }
        return result;
    }
}
</code></pre>
]]></content>
      
        <categories>
            
            <category> LeetCode-Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[11. 盛最多水的容器]]></title>
      <url>/2019/10/02/LeetCode-Java/11.%20%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</url>
      <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述 *"></a>题目描述 <em>*</em></h2><p>图见leetcode<br>给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点(i,ai) 。在坐标内画 n 条垂直线，垂直线 i的两个端点分别为(i,ai) 和 (i, 0)。找出其中的两条线，使得它们与x轴共同构成的容器可以容纳最多的水。</p>
<p>说明：你不能倾斜容器，且n的值至少为 2。</p>
<p>示例:</p>
<pre><code>输入: [1,8,6,2,5,4,8,3,7]
输出: 49
</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h4 id="解法一：暴力法"><a href="#解法一：暴力法" class="headerlink" title="解法一：暴力法"></a>解法一：暴力法</h4><pre><code class="Java">class Solution {
    public int maxArea(int[] height) {
        int n = height.length;
        int maxArea = 0;
        for(int i=0; i &lt; n-1; i++) {
            for(int j = i+1; j &lt; n; j++){
                int curArea = Math.min(height[i], height[j]) * (j - i);
                maxArea = Math.max(maxArea, curArea);
            }
        }
        return maxArea;
    }
}
</code></pre>
<h5 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><p>时间复杂度：O(n^2)，计算所有 n(n-1)/2 种高度组合的面积。<br>空间复杂度：O(1)，使用恒定的额外空间。</p>
<h4 id="解法二：双指针法"><a href="#解法二：双指针法" class="headerlink" title="解法二：双指针法"></a>解法二：双指针法</h4><p>这种方法背后的思路在于，两线段之间形成的区域总是会受到其中较短那条长度的限制。此外，两线段距离越远，得到的面积就越大。<br>我们在由线段长度构成的数组中使用两个指针，一个放在开始，一个置于末尾。 此外，我们会使用变量 maxarea 来持续存储到目前为止所获得的最大面积。 在每一步中，我们会找出指针所指向的两条线段形成的区域，更新maxarea，并将指向较短线段的指针向较长线段那端移动一步。<br>每移动一次较小指针，意味着计算了一对S(i,j)的值，而消去了一排S(i, k), i &lt; k &lt;= j, （假设i是较小指针），这一排是不需要计算的，因为矩形的高度受h[i]限制，只能更低，不能更高，而矩形的长度k-i &lt; j-i，所以这一排矩形面积不会更大，不需要计算。</p>
<pre><code class="Java">class Solution {
    public int maxArea(int[] height) {
        int n = height.length;
        int maxArea = 0;
        int left = 0, right = n-1;
        while(left &lt; right){
            if(height[left] &lt; height[right]) {
                maxArea = Math.max(maxArea, height[left] * (right - left));
                left ++;
            }
            else {
                maxArea = Math.max(maxArea, height[right] * (right - left));
                right --;
            }
        }
        return maxArea;
    }
}
</code></pre>
]]></content>
      
        <categories>
            
            <category> LeetCode-Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[5. 最长回文子串]]></title>
      <url>/2019/10/02/LeetCode-Java/5.%20%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
      <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述  **"></a>题目描述  **</h2><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设s 的最大长度为 1000。</p>
<p>示例 1：</p>
<pre><code>输入: &quot;babad&quot;
输出: &quot;bab&quot;
注意: &quot;aba&quot; 也是一个有效答案。
</code></pre><p>示例 2：</p>
<pre><code>输入: &quot;cbbd&quot;
输出: &quot;bb&quot;
</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h4 id="解法一：扩展中心"><a href="#解法一：扩展中心" class="headerlink" title="解法一：扩展中心"></a>解法一：扩展中心</h4><p>回文串一定是对称的，所以我们可以每次循环选择一个中心，进行左右扩展，判断左右字符是否相等即可。  </p>
<pre><code class="Java">class Solution {
    public String longestPalindrome(String s) {
        int n = s.length();
        int maxLen = 0;
        String subS = &quot;&quot;;
        for(int i = 0; i &lt; n; i++){
            // 奇数回文串，中心是一个元素
            int left = i, right = i;  
            while(left &gt; -1 &amp;&amp; right &lt; n &amp;&amp; s.charAt(left) == s.charAt(right)){
                left --;
                right ++;
            }
            if(maxLen &lt; right-left-1){
                maxLen = right-left-1;
                subS = s.substring(left+1, right);
            }

            // 偶数回文串，中心是两个元素
            left = i; 
            right = i+1;
            while(left &gt; -1 &amp;&amp; right &lt; n &amp;&amp; s.charAt(left) == s.charAt(right)){
                left --;
                right ++;
            }
            if(maxLen &lt; right-left-1){
                maxLen = right-left-1;
                subS = s.substring(left+1, right);
            }
        }
        return subS;
    }
}
</code></pre>
<p>复杂度分析<br>时间复杂度： O(n^2)<br>空间复杂度： O(1)</p>
<h4 id="解法二：动态规划"><a href="#解法二：动态规划" class="headerlink" title="解法二：动态规划"></a>解法二：动态规划</h4><p>如果S[i+1,j−1] 是回文串，那么只要S[i]==S[j]，就可以确定 S[i,j]也是回文串了。</p>
<p>求 长度为 1 和长度为 2 的 P(i,j) 时不能用上边的公式，因为我们代入公式后会遇到 P[i][j] 中 i &gt; j 的情况，比如求 P[1][2] 的话，我们需要知道 P[1+1][2-1]=P[2][1]，而 P[2][1] 代表着S[2,1] 是不是回文串，显然是不对的，所以我们需要单独判断。</p>
<p>所以我们先初始化长度是 1 的回文串的P[i,j]，这样利用上边提出的公式 P(i,j)=(P(i+1,j-1)\&amp;\&amp;S[i]==S[j])，然后两边向外各扩充一个字符，长度为 3 的，为 5 的，所有奇数长度的就都求出来了。</p>
<p>同理，初始化长度是 2 的回文串P[i,i+1]，利用公式，长度为 4 的，6 的所有偶数长度的就都求出来了。</p>
<pre><code class="Java">class Solution {
    public String longestPalindrome(String s) {
        int n = s.length();
        boolean[][] isPalindrome = new boolean[n][n];
        int maxLen = 0;
        String subS = &quot;&quot;;
        for(int len = 1; len &lt;= n; len++) {
            for(int start = 0; start &lt;= n - len; start++){
                int end = start + len - 1;
                isPalindrome[start][end] = (len == 1 || len == 2 || isPalindrome[start+1][end-1]) &amp;&amp; s.charAt(start) == s.charAt(end);  
                // len==1 和 len==2 单独判断（初始化）
                if(isPalindrome[start][end] &amp;&amp; len &gt; maxLen) {
                    maxLen = len;
                    subS = s.substring(start, end+1);
                }
            }    
        }
        return subS;
    }
}
</code></pre>
<p>复杂度分析<br>时间复杂度：两层循环 O(n^2）。<br>空间复杂度：用二维数组 P 保存每个子串的情况 O(n^2)。</p>
]]></content>
      
        <categories>
            
            <category> LeetCode-Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[4. 寻找两个有序数组的中位数]]></title>
      <url>/2019/10/01/LeetCode-Java/4.%20%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
      <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述  **"></a>题目描述  <em>**</em></h2><p>给定两个大小为 m 和 n 的有序数组nums1 和nums2。</p>
<p>请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为O(log(m + n))。</p>
<p>你可以假设nums1和nums2不会同时为空。</p>
<p>示例 1:</p>
<pre><code>nums1 = [1, 3]
nums2 = [2]

则中位数是 2.0
</code></pre><p>示例 2:</p>
<pre><code>nums1 = [1, 2]
nums2 = [3, 4]

则中位数是 (2 + 3)/2 = 2.5
</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h4 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h4><p>开始的思路是写一个循环，然后里边判断是否到了中位数的位置，到了就返回结果，但这里对偶数和奇数的分类会很麻烦。当其中一个数组遍历完后，出了 for 循环对边界的判断也会分几种情况。总体来说，虽然复杂度不影响，但代码会看起来很乱。</p>
<p>首先是怎么将奇数和偶数的情况合并一下。</p>
<p>用 len 表示合并后数组的长度，如果是奇数，我们需要知道第 （len+1）/2 个数就可以了，如果遍历的话需要遍历 int(len/2 ) + 1 次。如果是偶数，我们需要知道第 len/2和 len/2+1 个数，也是需要遍历 len/2+1 次。所以遍历的话，奇数和偶数都是 len/2+1 次。</p>
<p>返回中位数的话，奇数需要最后一次遍历的结果就可以了，偶数需要最后一次和上一次遍历的结果。所以我们用两个变量 left 和 right，right 保存当前循环的结果，在每次循环前将 right 的值赋给 left。这样在最后一次循环的时候，left 将得到 right 的值，也就是上一次循环的结果，接下来 right 更新为最后一次的结果。</p>
<p>循环中该怎么写，什么时候 A 数组后移，什么时候 B 数组后移。用 aStart 和 bStart 分别表示当前指向 A 数组和 B 数组的位置。如果 aStart 还没有到最后并且此时 A 位置的数字小于 B 位置的数组，那么就可以后移了。也就是aStart＜m&amp;&amp;A[aStart]&lt; B[bStart]。</p>
<p>但如果 B 数组此刻已经没有数字了，继续取数字 B[ bStart ]，则会越界，所以判断下 bStart 是否大于数组长度了，这样 || 后边的就不会执行了，也就不会导致错误了，所以增加为 aStart＜m&amp;&amp;(bStart) &gt;= n||A[aStart] &lt; B[bStart]) 。</p>
<pre><code class="Java">public double findMedianSortedArrays(int[] A, int[] B) {
    int m = A.length;
    int n = B.length;
    int len = m + n;
    int left = -1, right = -1;
    int aStart = 0, bStart = 0;
    for (int i = 0; i &lt;= len / 2; i++) {
        left = right;
        if (aStart &lt; m &amp;&amp; (bStart &gt;= n || A[aStart] &lt; B[bStart])) {
            right = A[aStart++];
        } else {
            right = B[bStart++];
        }
    }
    if ((len &amp; 1) == 0)
        return (left + right) / 2.0;
    else
        return right;
}
</code></pre>
<h4 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h4><p>第k小数（删掉一定比该数小的部分）<br>求中位数，其实就是求第k小数的一种特殊情况，可以每次循环排除掉 k/2 个数。<br>例如找两个数组中第k小的数，则将两个数组中第k/2小的数进行比较，较小者所在的数组，位于该元素之前的数一定都比总体的第k小数要小的。所以可以排除掉该数组的前k/2个元素。然后再递归排除。<br>要注意，如果一个数组的元素个数已经少于k/2个了，则要将该数组的最后元素（最大）与另一数组的k/2小元素比较。  </p>
<pre><code class="Java">class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int m = nums1.length, n = nums2.length;
        int total = m + n;
        if(total % 2 == 0) return (getKth(nums1, 0, m-1, nums2, 0, n-1, total/2) + getKth(nums1, 0, m-1, nums2, 0, n-1, total/2+1)) / 2;
        else return getKth(nums1, 0, m-1, nums2, 0, n-1, total/2+1);
    }
    public double getKth(int[] nums1, int start1, int end1, int[] nums2, int start2, int end2, int k){
        if(end1 &lt; start1) return nums2[start2 + k - 1];
        if(end2 &lt; start2) return nums1[start1 + k - 1];
        if(k == 1) return nums1[start1] &lt; nums2[start2] ? nums1[start1] : nums2[start2];
        int i = Math.min(end1, k/2 + start1 -1), j = Math.min(end2, k/2 + start2 - 1);
        if(nums1[i] &lt;= nums2[j]){
            k = k - (i - start1 + 1);
            start1 = i + 1;
        }
        else{
            k = k - (j - start2 + 1);
            start2 = j + 1;
        }
        return getKth(nums1, start1, end1, nums2, start2, end2, k);
    }
}
</code></pre>
<p>复杂度分析<br>时间复杂度：每进行一次循环，我们就减少 k/2 个元素，所以时间复杂度是 O(log(k))，而 k=(m+n)/2，所以最终的复杂也就是 O(log(m+n))。</p>
<p>空间复杂度：虽然我们用到了递归，但是可以看到这个递归属于尾递归，所以编译器不需要不停地堆栈，所以空间复杂度为 O(1)。  </p>
<blockquote>
<p>尾递归：<br>如果一个函数中所有递归形式的调用都出现在函数的末尾，我们称这个递归函数是尾递归的。当递归调用是整个函数体中最后执行的语句且它的返回值不属于表达式的一部分时，这个递归调用就是尾递归。尾递归函数的特点是在回归过程中不用做任何操作，这个特性很重要，因为大多数现代的编译器会利用这种特点自动生成优化的代码。<br>当编译器检测到一个函数调用是尾递归的时候，它就覆盖当前的活动记录而不是在栈中去创建一个新的。编译器可以做到这点，因为递归调用是当前活跃期内最后一条待执行的语句，于是当这个调用返回时栈帧中并没有其他事情可做，因此也就没有保存栈帧的必要了。通过覆盖当前的栈帧而不是在其之上重新添加一个，这样所使用的栈空间就大大缩减了，这使得实际的运行效率会变得更高。</p>
</blockquote>
<h4 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h4><p>切分数组<br>中位数将数组分为元素数相等的两部分，故将两数组都进行切分，必须保证左边两部分数量等于右边两部分数量。其次，左边最大值要小于右边最小值。<br>所以初始化两条切分线在两数组中间，然后在保证条件一的基础上不断移动切分线，使其满足条件二。</p>
<pre><code class="Java">class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int m = nums1.length, n = nums2.length;
        if(m &gt; n) return findMedianSortedArrays(nums2, nums1); // 保证nums1比nums2短
        int iMin = 0, iMax = m;  // 这是i能够取到的最小值与最大值
        while(iMin &lt;= iMax){
            int i = (iMin + iMax) / 2;
            int j = (m + n + 1) / 2 - i;  // （1）

            if(i!=0 &amp;&amp; nums1[i-1] &gt; nums2[j]) iMax = i - 1;  // （2）
            else if(i!=m &amp;&amp; nums2[j-1] &gt; nums1[i]) iMin = i + 1;
            else{
                int maxLeft;
                if(i == 0) maxLeft = nums2[j-1];
                else if(j == 0) maxLeft = nums1[i-1];
                else maxLeft = Math.max(nums1[i-1], nums2[j-1]);
                if((m+n) % 2 == 1) return maxLeft;  // 若和为奇数，直接返回最大左边值，

                int minRight;
                if(i == m) minRight = nums2[j];
                else if(j == n) minRight = nums1[i];
                else minRight = Math.min(nums1[i], nums2[j]);
                return (maxLeft + minRight) / 2.0;
            }
        }
        return 0.0;
    }
}
</code></pre>
<p>（1） 若为偶数， j = (m+n)/2 - i，切分线左右两边数量相等。若为奇数，使左边比右边多一个元素，则 j = (m+n+1)/2 - i 。 发现偶数的情况可以合并到奇数里。（m+n+1没有影响）。<br>（2） 二分查找，减半找中间的，再减半找中间的。不是主动移动中间数，而是将边界不断减半，使中间数被动移动。  </p>
<p>复杂度分析<br>时间复杂度：我们对较短的数组进行了二分查找，所以时间复杂度是 O(log(min(m,n)))。<br>空间复杂度：只有一些固定的变量，和数组长度无关，所以空间复杂度是 O(1)。</p>
]]></content>
      
        <categories>
            
            <category> LeetCode-Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[3. 无重复字符的最长子串]]></title>
      <url>/2019/09/29/LeetCode-Java/3.%20%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
      <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述  *"></a>题目描述  <em>*</em></h2><p>给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。</p>
<p>示例1:</p>
<pre><code>输入: &quot;abcabcbb&quot;
输出: 3 
解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。
</code></pre><p>示例 2:</p>
<pre><code>输入: &quot;bbbbb&quot;
输出: 1
解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。
</code></pre><p>示例 3:</p>
<pre><code>输入: &quot;pwwkew&quot;
输出: 3
解释: 因为无重复字符的最长子串是&quot;wke&quot;，所以其长度为 3。
请注意，你的答案必须是子串的长度，&quot;pwke&quot;是一个子序列，不是子串。
</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h4 id="1-边界值滑动窗口"><a href="#1-边界值滑动窗口" class="headerlink" title="1. 边界值滑动窗口"></a>1. 边界值滑动窗口</h4><p>用边界值作滑动窗口，两次遍历字符串</p>
<pre><code class="Java">class Solution {
    public int lengthOfLongestSubstring(String s) {
    // 滑动窗口右移，用右侧新字符与窗口内所有字符比较，如有相同，则左侧窗口移到相同处的右侧。
        int start = 0, end = 0, maxLength = 0, curLength = 0;
        for(end=0; end &lt; s.length(); end++){
            for(int i=start; i&lt;end; i++){
                if(s.charAt(i) == s.charAt(end)) {
                    start = i+1;
                    break;
                }
            }
            curLength = end - start + 1;
            if(curLength &gt; maxLength) maxLength = curLength;
        }
        return maxLength;
    }
}
</code></pre>
<p>复杂度分析</p>
<ul>
<li>时间复杂度：O(n^2)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h4 id="2-HashSet滑动窗口"><a href="#2-HashSet滑动窗口" class="headerlink" title="2. HashSet滑动窗口"></a>2. HashSet滑动窗口</h4><p>用HashSet作滑动窗口，可直接判断有无重复元素，避免二次遍历。</p>
<pre><code class="Java">class Solution {
    public int lengthOfLongestSubstring(String s) {
        Set&lt;Character&gt; hashSet = new HashSet&lt;&gt;();
        int maxLength = 0, start = 0, end = 0;
        int n = s.length();
        while(end &lt; n){
            if(!hashSet.contains(s.charAt(end))){
                hashSet.add(s.charAt(end));
                maxLength = Math.max(end - start + 1, maxLength);
                end ++;
            }
            else{
                hashSet.remove(s.charAt(start++));
                // 如果有重复元素，由于set无法确定重复元素的位置，需要按照原字符串的顺序从start开始一个个删除，将包含重复元素之前的元素都删掉。
            }
        }
        return maxLength;
    }
}
</code></pre>
<p>复杂度分析</p>
<ul>
<li>时间复杂度：O(2n) = O(n)</li>
<li>空间复杂度：O(min(m,n)，Set的大小取决于字符串n的大小以及字符集m的大小。</li>
</ul>
<h4 id="3-HashMap滑动窗口"><a href="#3-HashMap滑动窗口" class="headerlink" title="3. HashMap滑动窗口"></a>3. HashMap滑动窗口</h4><p>我们可以定义字符到索引的映射，而不是使用集合来判断一个字符是否存在。 当我们找到重复的字符时，我们可以立即跳过该窗口。</p>
<pre><code class="Java">class Solution {
    public int lengthOfLongestSubstring(String s) {
        Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();
        int start = 0, end = 0;
        int maxLength = 0;
        int n = s.length();
        while(end &lt; n){
            if(map.containsKey(s.charAt(end))){
                start = Math.max(map.get(s.charAt(end))+1, start);
            }
            maxLength = Math.max(maxLength, end - start + 1);
            map.put(s.charAt(end), end);
            end ++;
        }
        return maxLength;
    }
}
</code></pre>
<p>复杂度分析</p>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(min(m,n))，与方法2相同。  </li>
</ul>
<p><strong>注意：</strong><br>尽管方法2、3的时间复杂度比方法1低，但涉及到集合或映射的建立、插入、删除，实际运行时间可能比方法1长。</p>
]]></content>
      
        <categories>
            
            <category> LeetCode-Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[2. 两数相加]]></title>
      <url>/2019/09/27/LeetCode-Java/2.%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
      <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述 *"></a>题目描述 *</h2><p>给出两个非空的链表用来表示两个非负的整数。其中，它们各自的位数是按照逆序的方式存储的，并且它们的每个节点只能存储一位数字。</p>
<p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p>
<p>您可以假设除了数字0之外，这两个数都不会以0开头。</p>
<p>示例：</p>
<pre><code>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)
输出：7 -&gt; 0 -&gt; 8
原因：342 + 465 = 807
</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><pre><code class="Java">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode result;
        ListNode temp1 = l1, temp2 = l2;
        int sum = temp1.val + temp2.val;
        int flag = sum / 10;
        result = new ListNode(sum % 10);
        ListNode curResult = result;
        temp1 = temp1.next;
        temp2 = temp2.next;
        while(temp1 != null || temp2 != null){
        //这里把一条链表为空的情况也包含进来了，而不是在循环外再分别对两条链表的剩余部分循环。在单条链表为空时，把它赋0值。
            int x = (temp1 == null ? 0 : temp1.val);
            int y = (temp2 == null ? 0 : temp2.val);
            sum = x + y + flag;
            flag = sum / 10;
            curResult.next = new ListNode(sum % 10);
            curResult = curResult.next;
            if(temp1 != null) temp1 = temp1.next;
            if(temp2 != null) temp2 = temp2.next;
            // 因为包含了单条链表为空的情况，所以要判断，只有链表不为空时才能往下next。
        }
        if(flag != 0) curResult.next = new ListNode(flag);
        return result;
    }
}
</code></pre>
]]></content>
      
        <categories>
            
            <category> LeetCode-Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[1. 两数之和]]></title>
      <url>/2019/09/27/LeetCode-Java/1.%20%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述  **"></a>题目描述  **</h2><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p>
<p>示例:</p>
<pre><code>给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]
</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h4 id="1-暴力法"><a href="#1-暴力法" class="headerlink" title="1. 暴力法"></a>1. 暴力法</h4><p>遍历每个元素 x，并查找是否存在一个值与 target−x 相等的目标元素。</p>
<pre><code class="Java">class Solution {
    public int[] twoSum(int[] nums, int target) {
        int[] result = new int[2];
        for(int i = 0; i &lt; nums.length; i++){
            for(int j = i+1; j &lt; nums.length; j++){
                if(nums[i] + nums[j] == target)  {
                    result[0] = i;
                    result[1] = j;
                    return result;
                }
            }
        }
        return result;
    }
}
</code></pre>
<p>复杂度分析：</p>
<ul>
<li><p>时间复杂度：O(n^2)<br>对于每个元素，我们试图通过遍历数组的其余部分来寻找它所对应的目标元素，这将耗费 O(n) 的时间。因此时间复杂度为 O(n^2)。</p>
</li>
<li><p>空间复杂度：O(1)。</p>
</li>
</ul>
<h4 id="2-两遍哈希表"><a href="#2-两遍哈希表" class="headerlink" title="2. 两遍哈希表"></a>2. 两遍哈希表</h4><p>为了对运行时间复杂度进行优化，我们需要一种更有效的方法来检查数组中是否存在目标元素。如果存在，我们需要找出它的索引。保持数组中的每个元素与其索引相互对应的最好方法是什么？哈希表。</p>
<p>通过以空间换取速度的方式，我们可以将查找时间从 O(n)降低到 O(1)。哈希表正是为此目的而构建的，它支持以 近似恒定的时间进行快速查找。我用“近似”来描述，是因为一旦出现冲突，查找用时可能会退化到 O(n)。但只要你仔细地挑选哈希函数，在哈希表中进行查找的用时应当被摊销为 O(1)。</p>
<pre><code class="Java">class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map&lt;Integer, Integer&gt; hashMap = new HashMap&lt;&gt;();
        for(int i = 0; i &lt; nums.length; i++) hashMap.put(nums[i], i);
        for(int i = 0; i &lt; nums.length; i++){
            int diff = target - nums[i];
            if(hashMap.containsKey(diff)){
                if(hashMap.get(diff) != i) return new int[]{i, hashMap.get(diff)};
                // [1]
            } 
        }
        throw new IllegalArgumentException(&quot;No solution&quot;);
    }
}
</code></pre>
<p>复杂度分析：</p>
<ul>
<li><p>时间复杂度：O(n)，<br>我们把包含有 n 个元素的列表遍历两次。由于哈希表将查找时间缩短到 O(1) ，所以时间复杂度为 O(n)。</p>
</li>
<li><p>空间复杂度：O(n)，<br>所需的额外空间取决于哈希表中存储的元素数量，该表中存储了 n 个元素。</p>
</li>
</ul>
<h4 id="3-一遍哈希表"><a href="#3-一遍哈希表" class="headerlink" title="3. 一遍哈希表"></a>3. 一遍哈希表</h4><pre><code class="Java">class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map&lt;Integer, Integer&gt; hashMap = new HashMap&lt;&gt;();
        for(int i = 0; i &lt; nums.length; i++){
            int diff = target - nums[i];
            if(hashMap.containsKey(diff)) return new int[]{hashMap.get(diff), i};
            // [2]
            hashMap.put(nums[i], i);
        }
        throw new IllegalArgumentException(&quot;No solution&quot;);
    }
}
</code></pre>
<p>复杂度同上。<br><strong>注意：</strong><br>两遍哈希表和一遍哈希表的return的数组的顺序是不同的！！！</p>
]]></content>
      
        <categories>
            
            <category> LeetCode-Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[计算机网络学习笔记]]></title>
      <url>/2019/09/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h1 id="第一章-概述"><a href="#第一章-概述" class="headerlink" title="第一章 概述"></a>第一章 概述</h1><h2 id="1-3-互联网的组成"><a href="#1-3-互联网的组成" class="headerlink" title="1.3 互联网的组成"></a>1.3 互联网的组成</h2><ol>
<li>边缘部分  由所有连接在互联网上的主机组成。用户直接使用。  </li>
<li>核心部分  由大量网络和连接这些网络的路由器组成。为边缘部分提供服务。</li>
</ol>
<h3 id="1-3-1-互联网的边缘部分"><a href="#1-3-1-互联网的边缘部分" class="headerlink" title="1.3.1 互联网的边缘部分"></a>1.3.1 互联网的边缘部分</h3><p>在网络边缘的端系统之间的通信方式可划分为两大类：客户-服务器方式（C/S方式）和对等连接方式（P2P方式）。  </p>
<h3 id="1-3-2-互联网的核心部分"><a href="#1-3-2-互联网的核心部分" class="headerlink" title="1.3.2 互联网的核心部分"></a>1.3.2 互联网的核心部分</h3><ol>
<li>电路交换<br>建立连接–通话–释放连接<br>在通话的全部时间内，通话的两个用户始终占用端到端的通信资源。其线路的传输效率往往很低，因为数据是突发式地出现在传输线路上的，线路上真正用来传送数据的时间往往不到10%。  </li>
<li>分组交换<br>采用存储转发技术。把一个报文划分为几个分组后再发送。省去了建立连接和释放连接的开销，数据的传输效率更高。  </li>
</ol>
<p><strong>分组交换的优点：</strong></p>
<ul>
<li>高效。传输过程中动态分配传输带宽，对通信链路是逐段占用。</li>
<li>灵活。为每一个分组独立地选择最合适的转发路由。</li>
<li>迅速。以分组为传送单位，可以不先建立连接就能发送。</li>
<li>可靠。保证可靠性的网络协议；分布式多路由的分组交换网，使网络有很好的生存性。</li>
</ul>
<p><strong>分组交换的问题：</strong></p>
<ul>
<li>分组在各路由器存储转发时需要排队，这就造成一定的时延。</li>
<li>分组交换不像电路交换那样通过建立连接来保证通信时所需的各种资源，因而无法确保通信时端到端所需的带宽。</li>
<li>各分组必须携带的控制信息也造成了一定的开销。</li>
</ul>
<h1 id="第三章-数据链路层"><a href="#第三章-数据链路层" class="headerlink" title="第三章 数据链路层"></a>第三章 数据链路层</h1><h2 id="3-1-使用点对点信道的数据链路层"><a href="#3-1-使用点对点信道的数据链路层" class="headerlink" title="3.1 使用点对点信道的数据链路层"></a>3.1 使用点对点信道的数据链路层</h2><h3 id="3-1-2-三个基本问题"><a href="#3-1-2-三个基本问题" class="headerlink" title="3.1.2 三个基本问题"></a>3.1.2 三个基本问题</h3><p>封装成帧、透明传输和差错检测  </p>
<ol>
<li>封装成帧<br>帧的首尾定界符，可用来判断是不是完整的帧，丢弃不完整的帧。  </li>
<li>透明传输<br>字节填充或字符填充，在帧的数据部分中，在定界符前面添加一个转义字符ESC，也在转义字符ESC前面添加一个转义字符ESC。  </li>
<li>差错检测<br>比特差错：0变成1或者1变成0<br>采用循环冗余检测CRC来检错，把数据划分为帧，每一帧都加上冗余码，在接收方逐帧进行差错检验。<br><strong>注：</strong> 在数据链路层使用CRC检验，能够实现无比特差错的传输，但不是可靠传输。可能出现帧丢失、帧重复、帧失序的情况。  </li>
</ol>
<h2 id="3-3-使用广播信道的数据链路层"><a href="#3-3-使用广播信道的数据链路层" class="headerlink" title="3.3 使用广播信道的数据链路层"></a>3.3 使用广播信道的数据链路层</h2><p>一对多通信</p>
<h3 id="3-3-1-局域网的数据链路层"><a href="#3-3-1-局域网的数据链路层" class="headerlink" title="3.3.1 局域网的数据链路层"></a>3.3.1 局域网的数据链路层</h3><ol>
<li>静态划分信道<br>频分复用、时分复用、波分复用、码分复用<br>代价较高，不适合局域网使用  </li>
<li>动态媒体接入控制  </li>
</ol>
<ul>
<li>随机接入<br>必须有解决碰撞的协议</li>
<li>受控接入<br>令牌环、多点线路探测</li>
</ul>
<h3 id="3-3-2-CSMA-CD协议"><a href="#3-3-2-CSMA-CD协议" class="headerlink" title="3.3.2 CSMA/CD协议"></a>3.3.2 CSMA/CD协议</h3><blockquote>
<p>详见计算机网络P90  </p>
</blockquote>
<p>以太网使用总线，广播通信方式。在帧的首部写明接收站的地址，仅当数据帧中的目标地址与适配器ROM中存放的硬件地址一致时，适配器才能接收这个数据帧。这样，具有广播特性的总线上就实现了一对一的通信。  </p>
<ul>
<li>以太网采用无连接方式，适配器对发送的数据帧不进行编号，也不要求对方发回确认。<strong>尽最大努力交付，不可靠</strong>。使用CRC查出有差错则丢弃，对有差错帧是否重传由高层决定。<br>总线上同一时间只能允许一台计算机发送数据。以太网采用随机接入，使用CSMA/CD（载波监听多点接入/碰撞检测）协议减少冲突。</li>
<li>以太网采用<strong>曼彻斯特编码</strong>。</li>
<li>使用CSMA/CD协议时，一个站不可能同时进行发送和接收（信号叠加无法恢复），但必须边发送边监听（碰撞检测），因此以太网只能进行<strong>半双工通信</strong>。</li>
<li>某个站发送了一个很短的帧，在发送完毕之前并没有检测出碰撞。这个帧在继续向前传播到达目的站之前和别的站发送的帧发生了碰撞，目的站收到有差错的帧会丢弃，但发送站不知道发生了碰撞，所以不会重传。为了避免这种情况的发生，以太网规定了<strong>最短帧长64字节</strong>，即512bit。也就是争用期2t。<br>如果争用期没有发生碰撞，那么后续发送的数据一定不会发生碰撞。  </li>
<li>以太网还规定了<strong>帧间最小间隔</strong>为9.6us，这样做是为了使刚刚收到数据帧的站的接收缓存来得及清理，做好接收下一帧的准备。  </li>
</ul>
<h3 id="3-3-3-使用集线器的星型拓扑"><a href="#3-3-3-使用集线器的星型拓扑" class="headerlink" title="3.3.3 使用集线器的星型拓扑"></a>3.3.3 使用集线器的星型拓扑</h3><p>集线器的一些特点：  </p>
<ul>
<li>使用集线器的局域网在物理上是一个星型网，在逻辑上仍是一个总线网，使用的还是CSMA/CD协议。</li>
<li>集线器工作在物理层，仅仅简单地转发比特，不进行碰撞检测。</li>
</ul>
<h2 id="3-4-扩展的以太网"><a href="#3-4-扩展的以太网" class="headerlink" title="3.4 扩展的以太网"></a>3.4 扩展的以太网</h2><h3 id="3-4-1-在物理层扩展以太网"><a href="#3-4-1-在物理层扩展以太网" class="headerlink" title="3.4.1 在物理层扩展以太网"></a>3.4.1 在物理层扩展以太网</h3><p>采用转发器或集线器  </p>
<ul>
<li>在三个系的以太网互连起来之前，每一个系的10BASE-T以太网是一个独立的碰撞域，每个系的以太网的最大吞吐量是10Mbit/s，因此三个系总的最大吞吐量共有30Mbit/s。三个系的以太网通过集线器互连起来后就把三个碰撞域变成一个碰撞域，这时的最大吞吐量任然是一个系的吞吐量10Mbit/s。当某个系的两个站在通信时所传送的数据会通过所有的集线器进行转发，使得其他系的内部在这时都不能通信。  </li>
<li>一个系使用10Mbit/s的适配器，而另外两个系使用100Mbit.s的适配器，那么用集线器连接起来后，大家都只能工作在10Mbit/s的速率。</li>
</ul>
<h3 id="3-4-2-在数据链路层扩展以太网"><a href="#3-4-2-在数据链路层扩展以太网" class="headerlink" title="3.4.2 在数据链路层扩展以太网"></a>3.4.2 在数据链路层扩展以太网</h3><p>最初使用网桥，对收到的帧根据MAC帧的目的地址，查找网桥中的地址表，进行转发和过滤。  </p>
<h4 id="1-以太网交换机的特点"><a href="#1-以太网交换机的特点" class="headerlink" title="1. 以太网交换机的特点"></a>1. 以太网交换机的特点</h4><ul>
<li>实质上是一个多接口的网桥，全双工，并行性，即能同时连通多对接口，使多对主机能同时通信。</li>
<li>以太网交换机的接口有存储器，能缓存帧。支持存储转发和直通两种交换方式。</li>
<li>其内部的帧交换表（地址表）通过自学习算法自动建立。</li>
</ul>
<h4 id="2-以太网交换机的自学习功能"><a href="#2-以太网交换机的自学习功能" class="headerlink" title="2. 以太网交换机的自学习功能"></a>2. 以太网交换机的自学习功能</h4><ul>
<li>交换表中的每个项目都设有一定的有效时间，过期自动删除。</li>
<li>生成树协议STP解决无限兜圈子的问题。</li>
</ul>
<h4 id="3-从总线以太网到星形以太网"><a href="#3-从总线以太网到星形以太网" class="headerlink" title="3. 从总线以太网到星形以太网"></a>3. 从总线以太网到星形以太网</h4><p>总线以太网使用CSMA/CD协议，以半双工方式工作。<br>以太网交换机不适用共享总线，没有碰撞问题，因此不使用CSMA/CD协议，而是以全双工方式工作。  </p>
<h1 id="第四章-网络层"><a href="#第四章-网络层" class="headerlink" title="第四章 网络层"></a>第四章 网络层</h1><h2 id="4-1-网络层提供的两种服务"><a href="#4-1-网络层提供的两种服务" class="headerlink" title="4.1 网络层提供的两种服务"></a>4.1 网络层提供的两种服务</h2><table>
<thead>
<tr>
<th>对比的方面</th>
<th>虚电路服务</th>
<th>数据报服务</th>
</tr>
</thead>
<tbody>
<tr>
<td>思路</td>
<td>可靠通信应当由网络来保证</td>
<td>可靠通信应当由用户主机来保证</td>
</tr>
<tr>
<td>终点地址</td>
<td>仅在连接建立阶段使用，每个分组使用短的虚电路号</td>
<td>每个分组都有终点的完整地址</td>
</tr>
<tr>
<td>分组的顺序</td>
<td>总是按发送顺序到达终点</td>
<td>到达终点的时间不一定按发送顺序</td>
</tr>
</tbody>
</table>
<p>TCP/IP体系的网络层提供的是数据报服务，尽最大努力交付。  </p>
<h3 id="4-2-3-IP地址与硬件地址"><a href="#4-2-3-IP地址与硬件地址" class="headerlink" title="4.2.3 IP地址与硬件地址"></a>4.2.3 IP地址与硬件地址</h3><p>物理地址是数据链路层和物理层使用的地址，而IP地址是网络层和以上各层使用的地址。  </p>
<ol>
<li>IP数据报的首部中的源地址和目的地址<strong>始终</strong>是源主机和目的主机的IP地址，数据报中间经过的路由器的IP地址并不出现在IP数据报的首部中。  </li>
<li>虽然在IP数据报首部有源站IP地址，但路由器只根据目的站的IP地址的网络号进行路由选择。</li>
</ol>
<h3 id="4-2-4-地址解析协议ARP"><a href="#4-2-4-地址解析协议ARP" class="headerlink" title="4.2.4 地址解析协议ARP"></a>4.2.4 地址解析协议ARP</h3><p><strong>解决问题</strong><br>已经知道一个机器的IP地址，需要找出其相应的硬件地址。  </p>
<p><strong>为什么要使用IP地址，而不直接使用硬件地址？</strong><br>存在各种各样的网络，使用不同的硬件地址。要使这些异构网络能够互相通信就必须进行非常复杂的硬件地址转换工作。IP编址解决了这个问题，使它们就像连接在同一个网络上那样简单方便。</p>
<ul>
<li>由于是IP协议使用了ARP协议，因此通常把ARP协议划归网络层。但ARP协议的用途是为了从网络层使用的IP地址，解析出在数据链路层使用的硬件地址。因此，也可以把ARP协议划归在数据链路层。</li>
<li>每一台主机都设有一个ARP高速缓存，里面有本局域网上的各主机和路由器的IP地址到硬件地址的映射表。</li>
<li>ARP请求是在本地局域网广播发送的，带有源主机的IP地址和MAC地址，还有目的主机的IP地址。收到请求的主机检查自己的IP与目的IP是否一致。一致则发回响应，不一致则不理睬。ARP响应分组是单播。</li>
</ul>
<p><strong>注意：</strong><br>ARP是解决同一个局域网上的主机或路由器的IP地址和硬件地址的映射问题。如果源主机和目的主机不在同一个局域网上，就无法解析出硬件地址。只需要解析出路由器的硬件地址。  </p>
<p><strong>使用ARP的四种典型情况</strong>详见P127  </p>
<h3 id="4-2-5-IP数据报的格式"><a href="#4-2-5-IP数据报的格式" class="headerlink" title="4.2.5 IP数据报的格式"></a>4.2.5 IP数据报的格式</h3><p>详见P128  </p>
<ul>
<li><strong>首部检验和</strong> 这个字段只检验数据报的首部，但不包括数据部分，因为数据报每经过一个路由器，路由器都要重新计算一下首部检验和（一些字段，如生存时间、标志、片偏移等都可能发生变化）。不检验数据部分可减少计算的工作量。  </li>
</ul>
<h3 id="4-2-6-IP层转发分组的流程"><a href="#4-2-6-IP层转发分组的流程" class="headerlink" title="4.2.6 IP层转发分组的流程"></a>4.2.6 IP层转发分组的流程</h3><p><strong>分组转发算法</strong> 详见P134</p>
<h2 id="4-3-划分子网和构造超网"><a href="#4-3-划分子网和构造超网" class="headerlink" title="4.3 划分子网和构造超网"></a>4.3 划分子网和构造超网</h2><h3 id="4-3-1-划分子网"><a href="#4-3-1-划分子网" class="headerlink" title="4.3.1 划分子网"></a>4.3.1 划分子网</h3><ol>
<li>从两级IP地址到三级IP地址<br>两级IP地址的局限性：  </li>
</ol>
<ul>
<li>IP地址空间的利用率有时很低。</li>
<li>给每个物理网络分配一个网络号会使路由表变得太大因而使网络性能变坏。</li>
<li>两级IP地址不够灵活。我们希望能够灵活增加某单位的网络，而不必事先到互联网管理机构去申请新的网络号。  </li>
</ul>
<h3 id="4-3-3-无分类编址CIDR（构造超网）"><a href="#4-3-3-无分类编址CIDR（构造超网）" class="headerlink" title="4.3.3 无分类编址CIDR（构造超网）"></a>4.3.3 无分类编址CIDR（构造超网）</h3><p>无分类域间路由选择CIDR<br>CIDR消除了传统的A类、B类和C类地址以及划分子网的概念。使IP地址从三级编址又回到了两级编址，但这已是无分类的两级编址。  </p>
<h2 id="4-4-网际控制报文协议ICMP"><a href="#4-4-网际控制报文协议ICMP" class="headerlink" title="4.4 网际控制报文协议ICMP"></a>4.4 网际控制报文协议ICMP</h2><p>ICMP报文是装在IP数据报中，作为其中的数据部分。  </p>
<h3 id="4-4-1-ICMP报文的种类"><a href="#4-4-1-ICMP报文的种类" class="headerlink" title="4.4.1 ICMP报文的种类"></a>4.4.1 ICMP报文的种类</h3><table><br>    <tr><br>        <th>ICMP报文种类</th><br>        <th>ICMP报文的类型</th><br>    </tr><br>    <tr><br>        <td rowspan="4">差错报告报文</td><br>        <td>终点不可达</td><br>    </tr><br>    <tr><br>        <td>时间超过</td><br>    </tr><br>    <tr><br>        <td>参数问题</td><br>    </tr><br>    <tr><br>        <td>改变路由</td><br>    </tr><br>    <tr><br>        <td rowspan="2">询问报文</td><br>        <td>回送请求或回答</td><br>    </tr><br>    <tr><br>        <td>时间戳请求或回答</td><br>    </tr><br></table>

<p><strong>改变路由报文</strong><br>在互联网的主机中也要有一个路由表。当主机要发送数据报时，首先是查找主机自己的路由表，看应当从哪个接口发送。在互联网中主机的数量远大于路由器的数量，出于效率的考虑， <strong>这些主机不和连接在网络上的路由器定期交换路由信息。</strong>  </p>
<h3 id="4-4-2-ICMP的应用举例"><a href="#4-4-2-ICMP的应用举例" class="headerlink" title="4.4.2 ICMP的应用举例"></a>4.4.2 ICMP的应用举例</h3><p>分组网间探测PING（Packet InterNet Groper），使用了 <strong>ICMP回送请求与回送回答报文</strong> 。PING是应用层直接使用网络层ICMP的一个例子，它没有通过运输层的TCP或UDP。  </p>
<p>Traceroute数据报中封装的是无法交付的UDP用户数据报。把数据报的TTL依次设为1-n，路由器会发回 <strong>ICMP时间超过差错报告报文</strong> 。最终的目的主机会发回 <strong>ICMP终点不可达差错报告报文</strong> 。  </p>
<h2 id="4-5-互联网的路由选择协议"><a href="#4-5-互联网的路由选择协议" class="headerlink" title="4.5 互联网的路由选择协议"></a>4.5 互联网的路由选择协议</h2><ol>
<li>内部网关协议IGP，即在一个自治系统AS内部使用的路由选择协议，使用较多的如RIP和OSPF协议。</li>
<li>外部网关协议EGP，目前使用最多的是BGP。</li>
</ol>
<h3 id="4-5-2-内部网关协议RIP"><a href="#4-5-2-内部网关协议RIP" class="headerlink" title="4.5.2 内部网关协议RIP"></a>4.5.2 内部网关协议RIP</h3><p>基于距离向量的路由选择协议，最大优点是简单。距离定义为跳数，RIP允许一条路径最多只能包含15个路由器，距离等于16即相当于不可达。所以只适应于小型互联网。<br><strong>RIP的特点</strong>  </p>
<ol>
<li>仅和相邻路由器交换信息。</li>
<li>交换的是当前本路由器所知道的全部信息，即自己现在的路由表。</li>
<li>按固定的时间间隔交换路由信息。</li>
<li>RIP使用UDP来发送。  </li>
</ol>
<p><strong>距离向量算法</strong> 详见P155</p>
<p>RIP的主要问题是当网络出现故障时，要经过比较长的时间才能将此信息传送到所有的路由器。 <strong>好消息传播得快，坏消息传播得慢</strong>。  </p>
<p>RIP的最大优点是实现简单，开销较小。缺点：首先，RIP限制了网络的规模，最大距离15。其次，交换的路由信息是完整路由表，随着网络规模扩大，开销也增加。最后，坏消息传播得慢。  </p>
<h3 id="4-5-3-内部网关协议OSPF"><a href="#4-5-3-内部网关协议OSPF" class="headerlink" title="4.5.3 内部网关协议OSPF"></a>4.5.3 内部网关协议OSPF</h3><p>开放最短路径优先OSPF的特点：  </p>
<ol>
<li>向本自治系统的所有路由器发送信息。使用洪泛法。</li>
<li>发送的信息是与本路由器相邻的所有路由器的链路状态。</li>
<li>只有当链路状态发生变化时才发送此信息。</li>
<li>OSPF直接用IP数据报传送。</li>
</ol>
<p>所有的路由器最终都能建立一个链路状态数据库。也就是全网的拓扑结构图，在全网范围内是一致的。</p>
<h3 id="4-5-4-外部网关协议BGP"><a href="#4-5-4-外部网关协议BGP" class="headerlink" title="4.5.4 外部网关协议BGP"></a>4.5.4 外部网关协议BGP</h3><p>在不同自治系统AS之间的路由选择不使用内部网关协议RIP或者OSPF的原因：  </p>
<ol>
<li>互联网的规模太大，使得自治系统AS之间路由选择非常困难。链路状态数据库庞大，Dijkstra算法花费时间长，各自治系统的距离度量不同。</li>
<li>自治系统AS之间的路由选择必须考虑有关策略。如数据报需要避开某些网络。  </li>
</ol>
<p>BGP采用了路径向量路由选择协议。  </p>
<h3 id="4-6-3-从IPv4向IPv6过渡"><a href="#4-6-3-从IPv4向IPv6过渡" class="headerlink" title="4.6.3 从IPv4向IPv6过渡"></a>4.6.3 从IPv4向IPv6过渡</h3><ol>
<li>双协议栈<br>双协议栈主机在和IPv6主机通信时采用IPv6地址，而和IPv4主机通信时则采用IPv4地址。使用域名系统DNS来查询，确定目的主机是哪一种地址。  </li>
<li>隧道技术<br>把整个IPv6数据报变成IPv4数据报的数据部分。</li>
</ol>
<h2 id="4-7-IP多播"><a href="#4-7-IP多播" class="headerlink" title="4.7 IP多播"></a>4.7 IP多播</h2><h3 id="4-7-1-IP多播的基本概念"><a href="#4-7-1-IP多播的基本概念" class="headerlink" title="4.7.1 IP多播的基本概念"></a>4.7.1 IP多播的基本概念</h3><p>多播地址只能用于目的地址，而不能用于源地址。对多播数据报不产生ICMP差错报文。因此，若在PING命令后面键入多播地址，将永远不会收到响应。</p>
<h2 id="4-8-虚拟专用网VPN和网络地址转换NAT"><a href="#4-8-虚拟专用网VPN和网络地址转换NAT" class="headerlink" title="4.8 虚拟专用网VPN和网络地址转换NAT"></a>4.8 虚拟专用网VPN和网络地址转换NAT</h2><h3 id="4-8-1-虚拟专用网VPN"><a href="#4-8-1-虚拟专用网VPN" class="headerlink" title="4.8.1 虚拟专用网VPN"></a>4.8.1 虚拟专用网VPN</h3><p>专用地址，只能用作本地地址而不能用作全球地址。在互联网中的所有路由器，对目的地址是专用地址的数据报一律不进行转发。  </p>
<ol>
<li>10.0.0.0 到 10.255.255.255（10.0.0.0/8）</li>
<li>172.16.0.0 到 172.31.255.255（172.16.0.0）</li>
<li>192.168.0.0 到 192.168.255.255（192.168.0.0/16）  </li>
</ol>
<h3 id="4-8-2-网络地址转换NAT"><a href="#4-8-2-网络地址转换NAT" class="headerlink" title="4.8.2 网络地址转换NAT"></a>4.8.2 网络地址转换NAT</h3><p>当NAT路由器具有n个全球IP地址时，专用网内最多可以同时有n台主机接入互联网。<br>NAT转换表把运输层的端口号也利用上，就可以使多个拥有本地地址的主机，共用一个NAT路由器上的全球IP地址。<br><strong>注意</strong>：<br>普通路由器在转发IP数据报时，对于源IP地址或目的IP地址都是不改变的。但NAT路由器在转发IP数据报时，一定要更换其IP地址。其次，普通路由器在转发分组时，是工作在网络层。但NAPT路由器还要查看和转换运输层的端口号。</p>
<h1 id="第五章-运输层"><a href="#第五章-运输层" class="headerlink" title="第五章 运输层"></a>第五章 运输层</h1><h2 id="5-1-运输层协议概述"><a href="#5-1-运输层协议概述" class="headerlink" title="5.1 运输层协议概述"></a>5.1 运输层协议概述</h2><h3 id="5-1-1-进程之间的通信"><a href="#5-1-1-进程之间的通信" class="headerlink" title="5.1.1 进程之间的通信"></a>5.1.1 进程之间的通信</h3><p>运输层向它上面的应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最底层。当网络的边缘部分中的两台主机使用网络的核心功能进行端到端的通信时，只有主机的协议栈才有运输层，而网络核心部分中的路由器在转发分组时都只用到下三层的功能。  </p>
<h3 id="5-1-2-运输层的两个主要协议"><a href="#5-1-2-运输层的两个主要协议" class="headerlink" title="5.1.2 运输层的两个主要协议"></a>5.1.2 运输层的两个主要协议</h3><ol>
<li>用户数据报协议UDP（User Datagram Protocol）</li>
<li>传输控制协议TCP（Transmission Control Protocol）</li>
</ol>
<p>TCP不提供广播或多播服务。由于TCP要提供可靠的、面向连接的运输服务，因此不可避免地增加了许多的开销，如确认、流量控制、计时器以及连接管理等。这不仅使协议数据单元的首部增大许多，还要占用许多的处理器资源。</p>
<table>
<thead>
<tr>
<th>应用</th>
<th>应用层协议</th>
<th>运输层协议</th>
</tr>
</thead>
<tbody>
<tr>
<td>名字转换</td>
<td>DNS（域名系统）</td>
<td>UDP</td>
</tr>
<tr>
<td>文件传送</td>
<td>TFTP（简单文件传送协议）</td>
<td>UDP</td>
</tr>
<tr>
<td>路由选择协议</td>
<td>RIP（路由信息协议）</td>
<td>UDP</td>
</tr>
<tr>
<td>IP地址配置</td>
<td>DHCP（动态主机配置协议）</td>
<td>UDP</td>
</tr>
<tr>
<td>网络管理</td>
<td>SNMP（简单网络管理协议）</td>
<td>UDP</td>
</tr>
<tr>
<td>远程文件服务器</td>
<td>NFS（网络文件系统）</td>
<td>UDP</td>
</tr>
<tr>
<td>IP电话</td>
<td>专用协议</td>
<td>UDP</td>
</tr>
<tr>
<td>流式多媒体通信</td>
<td>专用协议</td>
<td>UDP</td>
</tr>
<tr>
<td>多播</td>
<td>IGMP（网际组管理协议）</td>
<td>UDP</td>
</tr>
<tr>
<td>电子邮件</td>
<td>SMTP（简单邮件传送协议）</td>
<td>TCP</td>
</tr>
<tr>
<td>远程终端接入</td>
<td>TELNET（远程终端协议）</td>
<td>TCP</td>
</tr>
<tr>
<td>万维网</td>
<td>HTTP（超文本传送协议）</td>
<td>TCP</td>
</tr>
<tr>
<td>文件传送</td>
<td>FTP（文件传送协议）</td>
<td>TCP  </td>
</tr>
</tbody>
</table>
<h2 id="5-2-用户数据报协议UDP"><a href="#5-2-用户数据报协议UDP" class="headerlink" title="5.2 用户数据报协议UDP"></a>5.2 用户数据报协议UDP</h2><h3 id="5-2-1-UDP概述"><a href="#5-2-1-UDP概述" class="headerlink" title="5.2.1 UDP概述"></a>5.2.1 UDP概述</h3><ol>
<li>UDP是无连接的，减少了开销和发送数据之前的时延。  </li>
<li>UDP使用尽最大努力交付。但有差错检测，有错就丢弃。 <strong>UDP的检验和是把首部和数据部分一起都检验。</strong></li>
<li>UDP是面向报文的。UDP对应用程序交下来的报文，添加首部后就交付IP层，既不合并也不拆分。接收方UDP除去首部后就原封不动的交付上层应用。UDP一次交付一个完整的报文。因此，应用程序必须选择合适大小的报文。若报文太长，UDP把它交给IP层后，IP层在传送时可能要进行分片，这会降低IP层的效率。若报文太短，IP的首部相对太长也降低效率。</li>
<li>UDP没有拥塞控制，因此网络出现的拥塞不会使源主机的发送速率降低。很多实时应用，如IP电话、实时视频会议等要求源主机以恒定的速率发送数据，并且允许在网络发生拥塞时丢失一些数据，但却不允许数据有太大的时延。</li>
<li>UDP支持一对一、一对多、多对一和多对多的交互通信。</li>
<li>UDP首部开销小，只有8个字节，比TCP的20个字节的首部要短。</li>
</ol>
<h2 id="5-3-传输控制协议TCP概述"><a href="#5-3-传输控制协议TCP概述" class="headerlink" title="5.3 传输控制协议TCP概述"></a>5.3 传输控制协议TCP概述</h2><h3 id="5-3-1-TCP最主要的特点"><a href="#5-3-1-TCP最主要的特点" class="headerlink" title="5.3.1 TCP最主要的特点"></a>5.3.1 TCP最主要的特点</h3><ol>
<li>每一条TCP连接只能是点对点的（一对一）。</li>
<li>可靠交付。无差错、不丢失、不重复，按序到达。</li>
<li>全双工通信。双方应用程序在任何时候都能发送数据。两端有发送缓存和接收缓存。</li>
<li>面向字节流。TCP并不关心应用进程一次把多长的报文发送到TCP的缓存中，而是根据对方给出的窗口值和当前网络拥塞的程度来决定一个报文段应包含多少个字节（ <strong>UDP发送的报文长度是应用进程给出的</strong> ）。</li>
</ol>
<h2 id="5-4-可靠传输的工作原理"><a href="#5-4-可靠传输的工作原理" class="headerlink" title="5.4 可靠传输的工作原理"></a>5.4 可靠传输的工作原理</h2><p>理想的传输条件有以下两个特点：</p>
<ol>
<li>传输信道不产生差错。</li>
<li>不管发送方以多快的速度发送数据，接收方总是来得及处理收到的数据。</li>
</ol>
<p>使用可靠传输协议，当出现差错时让发送方重传，在接收方来不及处理收到的数据时，及时告知发送方适当降低发送数据的速度。</p>
<h2 id="5-5-TCP报文段的首部格式"><a href="#5-5-TCP报文段的首部格式" class="headerlink" title="5.5 TCP报文段的首部格式"></a>5.5 TCP报文段的首部格式</h2><ol>
<li>序号<br>在一个TCP连接中传送的字节流中的每一个字节都按顺序编号。  </li>
<li>确认号<br>是期望收到对方下一个报文段的第一个数据字节的序号。若确认号=N，则表示到序号N-1为止的所有数据都已正确收到。  </li>
<li>确认ACK<br>仅当ACK=1时确认号字段才有效。在连接建立后所有传送的报文段都必须把ACK置1。  </li>
<li>同步SYN<br>当SYN=1而ACK=0时，表明这是一个连接请求报文段。SYN=1且ACK=1时是一个连接接受报文。  </li>
<li>窗口<br>接收方的数据缓存空间是有限的，窗口值指出了现在允许对方发送的数据量。  </li>
</ol>
<h2 id="5-6-TCP可靠传输的实现"><a href="#5-6-TCP可靠传输的实现" class="headerlink" title="5.6 TCP可靠传输的实现"></a>5.6 TCP可靠传输的实现</h2><h3 id="5-6-1-以字节为单位的滑动窗口"><a href="#5-6-1-以字节为单位的滑动窗口" class="headerlink" title="5.6.1 以字节为单位的滑动窗口"></a>5.6.1 以字节为单位的滑动窗口</h3><p>一、 虽然发送窗口是根据接收窗口设置的，但在同一时刻，发送窗口并不总是和接收窗口一样大。因为通过网络传送窗口值需要一定的时间滞后。另外，发送方还可能根据网络的拥塞情况适当减小自己的发送窗口数值。<br>二、 TCP接收方累计确认。接收方可以在适当的时候发送确认，也可以在自己有数据要发送时捎带确认。但捎带确认并不经常发生，因为大多数应用程序很少同时在两个方向上发送数据。  </p>
<h3 id="5-6-2-超时重传时间的选择"><a href="#5-6-2-超时重传时间的选择" class="headerlink" title="5.6.2 超时重传时间的选择"></a>5.6.2 超时重传时间的选择</h3><p>TCP采用了一种自适应算法，测量报文段的往返时间RTT，计算加权平均往返时间RTTs。<br>只要报文段重传了，就不采用其往返时间样本。</p>
<h2 id="5-8-TCP的拥塞控制"><a href="#5-8-TCP的拥塞控制" class="headerlink" title="5.8 TCP的拥塞控制"></a>5.8 TCP的拥塞控制</h2><h3 id="5-8-1-拥塞控制的一般原理"><a href="#5-8-1-拥塞控制的一般原理" class="headerlink" title="5.8.1 拥塞控制的一般原理"></a>5.8.1 拥塞控制的一般原理</h3><p><strong>流量控制</strong> 是指点对点通信量的控制，接收端抑制发送端发送数据的速率，以便使接收端来得及接收。<br><strong>拥塞控制</strong> 是防止过多的数据注入到网络，使网络中的路由器或链路不致过载，是一个全局性的过程。</p>
<h3 id="5-8-2-TCP的拥塞控制方法"><a href="#5-8-2-TCP的拥塞控制方法" class="headerlink" title="5.8.2 TCP的拥塞控制方法"></a>5.8.2 TCP的拥塞控制方法</h3><p>慢开始、拥塞避免、快重传、快恢复 详见P232<br>发送方窗口的上限值 = Min[接收方窗口rwnd, 拥塞窗口cwnd]</p>
<h2 id="5-9-TCP的运输连接管理"><a href="#5-9-TCP的运输连接管理" class="headerlink" title="5.9 TCP的运输连接管理"></a>5.9 TCP的运输连接管理</h2><h3 id="5-9-1-TCP的连接建立"><a href="#5-9-1-TCP的连接建立" class="headerlink" title="5.9.1 TCP的连接建立"></a>5.9.1 TCP的连接建立</h3><p>三次握手，第一次、第二次都消耗一个序号，不能携带数据，第三次可以携带数据，但如果不携带数据则不消耗序号。（即本次报文段seq=x+1，下一个报文段序号仍然是seq=x+1）。  </p>
<p>为什么要发送第三次报文（最后还要发送一次确认）？<br>详见P239</p>
<h3 id="5-9-2-TCP的连接释放"><a href="#5-9-2-TCP的连接释放" class="headerlink" title="5.9.2 TCP的连接释放"></a>5.9.2 TCP的连接释放</h3><p>A主动关闭，B发送确认，A进入半关闭状态，即A没有数据要发送，但仍要接收数据。<br>之后B发连接释放报文段，A发出确认，进入时间等待状态，经过2MSL（最长报文段寿命）后才关闭。<br>A等待2MSL的原因：  </p>
<ol>
<li>为了保证A发送的最后一个ACK报文能够到达B。若这个ACK丢失，B收不到，就会超时重传FIN+ACK，A就能在2MSL时间内收到这个重传的FIN+ACK，接着A重传一次确认，重新启动2MSL计时器。最后，A和B都进入关闭状态。</li>
<li>防止上一节提到的“已失效的连接请求报文段”出现在本连接中。经过2MSL，就可以使本连接持续时间内所产生的所有报文段都从网络中小时。使下一个新的连接中不会出现这种旧的连接请求报文段。<br>B结束TCP的连接时间比A早一些。  </li>
</ol>
<p>TCP还设有一个保活计时器。若一方主机故障，等待两小时后，连发十个探测报文段，仍无响应则关闭连接。  </p>
<h1 id="第六章-应用层"><a href="#第六章-应用层" class="headerlink" title="第六章 应用层"></a>第六章 应用层</h1><h2 id="6-1-域名系统DNS"><a href="#6-1-域名系统DNS" class="headerlink" title="6.1 域名系统DNS"></a>6.1 域名系统DNS</h2><p>基于UDP</p>
<h3 id="6-1-2-互联网的域名结构"><a href="#6-1-2-互联网的域名结构" class="headerlink" title="6.1.2 互联网的域名结构"></a>6.1.2 互联网的域名结构</h3><p>域名中的标号都由英文字母和数字组成，标号不区分大小写字母。</p>
<h3 id="6-1-3-域名服务器"><a href="#6-1-3-域名服务器" class="headerlink" title="6.1.3 域名服务器"></a>6.1.3 域名服务器</h3><ol>
<li>根域名服务器</li>
<li>顶级域名服务器</li>
<li>权限域名服务器</li>
<li>本地域名服务器<br>电脑上配置的就是本地域名服务器。</li>
</ol>
<p>第一，主机向本地域名服务器的查询采用递归查询。即如果本地域名服务器不知道被查询域名的IP地址，那么本地域名服务器就以DNS客户的身份，向其他根域名服务器继续查询，而不是让该主机自己进行下一步查询。<br>第二，本地域名服务器向根域名服务器的查询通常采用迭代查询。本地域名服务器依次向根域名、顶级域名、权限域名服务器查询。</p>
<h2 id="6-2-文件传送协议"><a href="#6-2-文件传送协议" class="headerlink" title="6.2 文件传送协议"></a>6.2 文件传送协议</h2><h3 id="6-2-1-FTP概述"><a href="#6-2-1-FTP概述" class="headerlink" title="6.2.1 FTP概述"></a>6.2.1 FTP概述</h3><p>基于TCP的FTP和基于UDP的简单文件传送协议TFTP，都是文件共享协议的一大类，即复制整个文件。</p>
<h3 id="6-2-2-FTP的基本工作原理"><a href="#6-2-2-FTP的基本工作原理" class="headerlink" title="6.2.2 FTP的基本工作原理"></a>6.2.2 FTP的基本工作原理</h3><p>一个FTP服务器进程可同时为多个客户进程提供服务。一个主进程，负责接收新的请求；若干个从属进程，负责处理单个请求。<br>在进行文件传输时，FTP的客户和服务器之间要建立两个并行的TCP连接：控制连接和数据连接。控制连接在整个会话期间一直保持打开。端口号21用于控制连接，20用于数据传送连接。<br>FTP修改大文件需要来回传送整个文件。网络文件系统NFS允许应用进程打开一个远地文件，并能在该文件的某一个特定的位置上开始读写数据。不需要复制整个大文件。</p>
<h2 id="6-4-万维网WWW"><a href="#6-4-万维网WWW" class="headerlink" title="6.4 万维网WWW"></a>6.4 万维网WWW</h2><h3 id="6-4-3-超文本传送协议HTTP"><a href="#6-4-3-超文本传送协议HTTP" class="headerlink" title="6.4.3 超文本传送协议HTTP"></a>6.4.3 超文本传送协议HTTP</h3><p>HTTP使用面向连接的TCP作为运输层协议，但HTTP协议本身是无连接的。  </p>
<p>请求一个万维网文档所需的时间是该文档的传输时间加上两倍往返时间RTT（一个RTT用于建立TCP连接，另一个RTT用于请求和接收万维网文档。TCP建立连接的三报文握手的第三个报文段中的数据，就是客户对万维网文档的请求报文）。  </p>
<p>HTTP/1.0的主要缺点，就是每请求一个文档就有两倍RTT的开销。另一种开销是万维网客户和服务器每一次建立新的TCP连接都要分配缓存和变量。特别是万维网服务器往往要同时服务于大量客户的请求。所以这种非持续连接会使万维网的负担很重。好在浏览器都能够打开5-10个并行的TCP连接，而每一个TCP连接处理客户的一个请求。因此，使用并行TCP连接可以缩短响应时间。<br>HTTP/1.1较好地解决了这个问题，它使用持续连接，万维网服务器在发送响应后仍然在一段时间内保持这条连接，使同一个客户和该服务器可以继续在这条连接上传送后续的HTTP请求报文和响应报文。<br>HTTP/1.1的持续连接有两种工作方式，非流水线方式和流水线方式。<br>非流水线方式，是客户在收到前一个响应后才能发出下一个请求，因此在TCP连接已建立后，客户每访问一次对象就要用去一个往返RTT，这比非持续连接用的2RTT的开销，节省了建立TCP连接所需的一个RTT。<br>流水线方式，客户在收到响应之前就能接着发送新的请求报文，客户访问所有的对象只需花费一个RTT。<br>另见 <a href="https://zhuanlan.zhihu.com/p/61423830" target="_blank" rel="external">补充</a>  </p>
]]></content>
      
        <categories>
            
            <category> 计算机网络 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[计算机网络协议]]></title>
      <url>/2019/09/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/</url>
      <content type="html"><![CDATA[<h2 id="地址解析协议ARP"><a href="#地址解析协议ARP" class="headerlink" title="地址解析协议ARP"></a>地址解析协议ARP</h2><h3 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h3><p>已经知道一个机器的IP地址，需要找出其相应的硬件地址。</p>
<ul>
<li>由于是IP协议使用了ARP协议，因此通常把ARP协议划归网络层。但ARP协议的用途是为了从网络层使用的IP地址，解析出在数据链路层使用的硬件地址。因此，也可以把ARP协议划归在数据链路层。</li>
<li>每一台主机都设有一个ARP高速缓存，里面有本局域网上的各主机和路由器的IP地址到硬件地址的映射表。</li>
<li>ARP请求是在本地局域网广播发送的，带有源主机的IP地址和MAC地址，还有目的主机的IP地址。收到请求的主机检查自己的IP与目的IP是否一致。一致则发回响应，不一致则不理睬。ARP响应分组是单播。</li>
</ul>
<p><strong>注意：</strong><br>ARP是解决同一个局域网上的主机或路由器的IP地址和硬件地址的映射问题。如果源主机和目的主机不在同一个局域网上，就无法解析出硬件地址。只需要解析出路由器的硬件地址。</p>
<h2 id="动态主机设置协议DHCP"><a href="#动态主机设置协议DHCP" class="headerlink" title="动态主机设置协议DHCP"></a>动态主机设置协议DHCP</h2><p>DHCP使用UDP协议工作，主要用途有两个：用于内部网或网络服务供应商自动分配IP地址；给用户用于内部网管理员作为对所有计算机作中央管理的手段。  </p>
<h3 id="三种分配机制"><a href="#三种分配机制" class="headerlink" title="三种分配机制"></a>三种分配机制</h3><ol>
<li>自动分配方式，永久IP</li>
<li>动态分配方式，有时间限制的IP</li>
<li>手工分配方式，永久IP</li>
</ol>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>主机放松请求信息到DHCP服务器的68号端口，DHCP服务器回应应答消息给主机的67号端口。  </p>
<ol>
<li>DHCP Client以广播的方式发出DHCP Discover 报文。</li>
<li>所有的DHCP Server都能够接收到DHCP Client 发送的DHCP Discover报文，所有的DHCP Server 都会给出响应，向DHCP Client发送一个DHCP Offer 报文。DHCP Offer报文中“Your(Client) IP Address”字段就是DHCP Server能够提供给DHCP Client使用的IP地址，且DHCP Server 会将自己的IP地址放在“option”字段中以便DHCP Client区分不同的DHCP Server。DHCP Server在发出此报文后会存在一个已分配IP地址的纪录。</li>
<li>DHCP Client只能处理其中的一个DHCP Offer报文，一般的原则是DHCP Client处理最先收到的DHCP Offer报文。<br>DHCP Client会发出一个广播的DHCP Request报文，在选项字段中会加入选中的DHCP Server的IP地址和需要的IP地址。</li>
<li>DHCP Server收到DHCP Request 报文后，判断选项字段中的IP地址是否与自己的地址相同。如果不相同，DHCP Server 不做任何处理只清除相应IP地址分配记录；如果相同，DHCP Server就会向DHCP Client响应一个DHCP ACK报文，并在选项字段中增加IP地址的使用租期信息。</li>
<li>DHCP Client接收到DHCP ACK报文后，检查DHCP Server分配的IP地址是否能够使用。如果可以使用，则DHCP Client成功获得IP地址并根据IP地址使用租期自动启动续延过程；如果DHCP Client 发现分配的IP地址已经被使用，则DHCP Client 向DHCP Server发出DHCP Decline报文，通知DHCP Server禁用这个IP地址，然后DHCP Client 开始新的地址申请过程。</li>
<li>DHCP Client在成功获取IP地址后，随时可以通过发送DHCP Release报文释放自己的IP地址，DHCP Server收到DHCP Release 报文后，会回收相应的IP地址并重新分配。  </li>
</ol>
<p>在使用租期超过50%时刻处，DHCP Client 会以单播形式向DHCP Server 发送DHCPRequest报文来续租IP地址。如果DHCP Client成功收到DHCP Server发送的DHCP ACK 报文，则按相应时间延长IP地址租期；如果没有收到DHCP Server发送的DHCP ACK报文，则DHCP Client 继续使用这个IP地址。   </p>
<p>在使用租期超过87.5%时刻处，DHCP Client会以广播形式向DHCP Server 发送DHCPRequest报文来续租IP地址。如果DHCP Client成功收到DHCP Server发送的DHCP ACK 报文，则按相应时间延长IP地址租期；如果没有收到DHCP Server发送的DHCP ACK报文，则DHCP Client继续使用这个IP地址，直到IP地址使用租期到期时，DHCP Client才会向DHCP Server发送DHCP Release报文来释放这个IP地址，并开始新的IP地址申请过程。</p>
]]></content>
      
        <categories>
            
            <category> 计算机网络 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[计算机网络知识点]]></title>
      <url>/2019/07/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      <content type="html"><![CDATA[<h1 id="你猜一个-TCP-连接上面能发多少个-HTTP-请求"><a href="#你猜一个-TCP-连接上面能发多少个-HTTP-请求" class="headerlink" title="你猜一个 TCP 连接上面能发多少个 HTTP 请求"></a>你猜一个 TCP 连接上面能发多少个 HTTP 请求</h1><ol>
<li>现代浏览器在与服务器建立了一个 TCP 连接后是否会在一个 HTTP 请求完成后断开？什么情况下会断开？  </li>
<li>一个 TCP 连接可以对应几个 HTTP 请求？  </li>
<li>一个 TCP 连接中 HTTP 请求发送可以一起发送么（比如一起发三个请求，再三个响应一起接收）？  </li>
<li>为什么有的时候刷新页面不需要重新建立 SSL 连接？  </li>
<li>浏览器对同一 Host 建立 TCP 连接到数量有没有限制？  </li>
</ol>
<blockquote>
<p>(<a href="https://zhuanlan.zhihu.com/p/61423830" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/61423830</a>)</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 计算机网络 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Java核心技术卷1 基础知识（4-6）]]></title>
      <url>/2019/07/04/Java/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B71%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%884-6%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="4-对象与类"><a href="#4-对象与类" class="headerlink" title="4. 对象与类"></a>4. 对象与类</h1><h2 id="4-1-面向对象程序设计概述"><a href="#4-1-面向对象程序设计概述" class="headerlink" title="4.1 面向对象程序设计概述"></a>4.1 面向对象程序设计概述</h2><h3 id="4-1-4-类之间的关系"><a href="#4-1-4-类之间的关系" class="headerlink" title="4.1.4 类之间的关系"></a>4.1.4 类之间的关系</h3><ul>
<li>依赖（use-a）</li>
<li>聚合（has-a）</li>
<li>继承（is-a）  </li>
</ul>
<h2 id="4-3-用户自定义类"><a href="#4-3-用户自定义类" class="headerlink" title="4.3 用户自定义类"></a>4.3 用户自定义类</h2><h3 id="4-3-5-隐式参数与显式参数"><a href="#4-3-5-隐式参数与显式参数" class="headerlink" title="4.3.5 隐式参数与显式参数"></a>4.3.5 隐式参数与显式参数</h3><p>在C++中，通常在类的外面定义方法：</p>
<pre><code class="C++">void Employee::raiseSalary(double byPercent) //C++, not Java
{
    ...
}
</code></pre>
<p>如果在类的内部定义方法，这个方法将自动地成为内联(inline)方法。</p>
<pre><code>class Employee
{
    ...
    int getNae(){ return name; } // inline in C++
}
</code></pre><p>在Java中，所有的方法都必须在类的内部定义，但并不表示他们是内联方法。是否将某个方法设置为内联方法是Java虚拟机的任务。即时编译器会监视调用那些简洁、经常被调用、没有被重载以及可优化的方法。  </p>
<hr>
<blockquote>
<p><strong>C++ 内联函数</strong><br>使用函数能够避免将相同代码重写多次的麻烦，还能减少可执行程序的体积，但也会带来程序运行时间上的开销。<br>函数调用在执行时，首先要在栈中为形参和局部变量分配存储空间，然后还要将实参的值复制给形参，接下来还要将函数的返回地址（该地址指明了函数执行结束后，程序应该回到哪里继续执行）放入栈中，最后才跳转到函数内部执行。这个过程是要耗费时间的。<br>另外，函数执行 return 语句返回时，需要从栈中回收形参和局部变量占用的存储空间，然后从栈中取出返回地址，再跳转到该地址继续执行，这个过程也要耗费时间。<br>总之，使用函数调用语句和直接把函数中的代码重新抄写一遍相比，节省了人力，但是带来了程序运行时间上的额外开销。<br>一般情况下，这个开销可以忽略不计。但是，如果一个函数内部没有几条语句，执行时间本来就非常短，那么这个函数调用产生的额外开销和函数本身执行的时间相比，就显得不能忽略了。假如这样的函数在一个循环中被上千万次地执行，函数调用导致的时间开销可能就会使得程序运行明显变慢。<br>作为特别注重程序执行效率，适合编写底层系统软件的高级程序设计语言，C++ 用 inline 关键字较好地解决了函数调用开销的问题。<br>在 C++ 中，可以在定义函数时，在返回值类型前面加上 inline 关键字。如：</p>
</blockquote>
<pre><code class="C++">inline int Max (int a, int b)
{
    if(a &gt; b)
        return a;
    return b;
}
</code></pre>
<blockquote>
<p>增加了 inline 关键字的函数称为“内联函数”。内联函数和普通函数的区别在于：当编译器处理调用内联函数的语句时，不会将该语句编译成函数调用的指令，而是直接将整个函数体的代码插人调用语句处，就像整个函数体在调用处被重写了一遍一样。<br>有了内联函数，就能像调用一个函数那样方便地重复使用一段代码，而不需要付出执行函数调用的额外开销。很显然，使用内联函数会使最终可执行程序的体积增加。以时间换取空间，或增加空间消耗来节省时间，这是计算机学科中常用的方法。<br>内联函数中的代码应该只是很简单、执行很快的几条语句。如果一个函数较为复杂，它执行的时间可能上万倍于函数调用的额外开销，那么将其作为内联函数处理的结果是付出让代码体积增加不少的代价，却只使速度提高了万分之一，这显然是不划算的。<br>有时函数看上去很简单，例如只有一个包含一两条语句的循环，但该循环的执行次数可能很多，要消耗大量时间，那么这种情况也不适合将其实现为内联函数。<br>另外，需要注意的是，调用内联函数的语句前必须已经出现内联函数的定义（即整个数体），而不能只出现内联函数的声明。</p>
<p><strong>C++三种类定义的内联函数</strong></p>
<ol>
<li>隐式内联</li>
</ol>
</blockquote>
<pre><code class="C++">class Person
{
public:
    Person(const string &amp;name)
    {
        Name = name;
    }
    void printName()//printName 定义在类里面是隐式内联函数
    {
        cout &lt;&lt; Name &lt;&lt; endl;
    }
private:
    string Name;
};
</code></pre>
<blockquote>
<ol>
<li>在类里面显示声明，在类外面定义</li>
</ol>
</blockquote>
<pre><code class="C++">class Person
{
public:
    Person(const string &amp;name)
    {
        Name = name;
    }
    inline void printName();//成员被函数前加了inline是显式内联函数
    //在类里面显式声明
private:
    string Name;
};
void Person::printName()
{//在类外面定义
    cout &lt;&lt; Name &lt;&lt; endl;
}
</code></pre>
<blockquote>
<ol>
<li>“追加”内联<br>表示在类里面没有显式声明，在类外显示定义了内联。</li>
</ol>
</blockquote>
<pre><code class="C++">class Person
{
public:
    Person(const string &amp;name)
    {
        Name = name;
    }
    void printName();
    //在类里面没有显式声明
private:
    string Name;
};
inline void Person::printName()//成员被函数前加了inline是显式内联函数
{//在类外面显式定义
    cout &lt;&lt; Name &lt;&lt; endl;
}
</code></pre>
<blockquote>
<p>在类外定义，且声明和定义都没有inline的不是内联函数。  </p>
</blockquote>
<h3 id="4-3-6-封装的优点"><a href="#4-3-6-封装的优点" class="headerlink" title="4.3.6 封装的优点"></a>4.3.6 封装的优点</h3><p>注意不要编写返回引用可变对象的访问器方法。  </p>
<pre><code class="Java">class Employee
{
    private Date hireDay;
    ...
    public Date getHireDay()
    {
        return hireDay; // Bad
    }
}
</code></pre>
<p>凭经验可知，如果需要返回一个可变数据域的拷贝，就应该使用clone。</p>
<pre><code class="Java">class Employee
{
    ...
    public Date getHireDay()
    {
        return (Date)hireDay.clone(); // Ok
    }
}
</code></pre>
<h3 id="4-3-7-基于类的访问权限"><a href="#4-3-7-基于类的访问权限" class="headerlink" title="4.3.7 基于类的访问权限"></a>4.3.7 基于类的访问权限</h3><p>一个方法可以访问所属类的所有对象的私有数据。 </p>
<pre><code class="Java">class Employee
{
    ...
    public boolean equals(Employee other)
    {
        return name.equals(other.name);
    }
}

// 调用方式
if(harry.equals(boss)) ...
</code></pre>
<h3 id="4-3-9-final实例域"><a href="#4-3-9-final实例域" class="headerlink" title="4.3.9 final实例域"></a>4.3.9 final实例域</h3><p>构建对象时必须初始化final实例域。也就是说，必须确保在每一个构造器执行之后，这个域的值被设置，并且在后面的操作中，不能够再对它进行修改。  </p>
<h2 id="4-4-静态域与静态方法"><a href="#4-4-静态域与静态方法" class="headerlink" title="4.4 静态域与静态方法"></a>4.4 静态域与静态方法</h2><h3 id="4-4-1-静态域"><a href="#4-4-1-静态域" class="headerlink" title="4.4.1 静态域"></a>4.4.1 静态域</h3><p>将域定义为static，则这个类的所有实例将共享这个域。即使这个类没有实例，静态域也存在。它属于类，而不属于任何独立的对象。  </p>
<h3 id="4-4-2-静态常量"><a href="#4-4-2-静态常量" class="headerlink" title="4.4.2 静态常量"></a>4.4.2 静态常量</h3><p>static加final  </p>
<pre><code class="Java">public class Math
{
    ...
    public static final double PI = 3.1415926;
    ,...
}
</code></pre>
<p>可以采用Math.PI的形式获得这个常量。</p>
<h3 id="4-4-3-静态方法"><a href="#4-4-3-静态方法" class="headerlink" title="4.4.3 静态方法"></a>4.4.3 静态方法</h3><p>静态方法是一种不能向对象实施操作的方法。不能访问实例域，但是可以访问自身类中的静态域。</p>
<pre><code class="Java">public static int getNextId()
{
    return nextId;  
}
// 可以通过类名调用这个方法
int n = Employee.getNextId();
</code></pre>
<p><strong>在下面两种情况下使用静态方法：</strong></p>
<ul>
<li>一个方法不需要访问对象状态，其所需参数都是通过显式参数提供（例如：Math.pow）。</li>
<li>一个方法只需要访问类的静态域（例如：Employee.getNextId）。</li>
</ul>
<h2 id="4-5-方法参数"><a href="#4-5-方法参数" class="headerlink" title="4.5 方法参数"></a>4.5 方法参数</h2><p>参数传递方法：  </p>
<ul>
<li>按值调用表示方法接受的是调用者提供的值。</li>
<li>按引用调用表示方法接受的是调用者提供的变量地址。  </li>
</ul>
<p>一个方法可以修改引用调用所对应的变量值，而不能修改传值调用所对应的变量值。<br>Java总是采用按值调用。方法得到的是所有参数值的一个拷贝，不能修改任何参数变量的内容。  </p>
<ul>
<li>一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）。</li>
<li>一个方法可以改变一个对象参数的状态。</li>
<li>一个方法不能让对象参数引用一个新的对象。  </li>
</ul>
<blockquote>
<p>C++有值调用和引用调用。引用参数标有&amp;符号。</p>
</blockquote>
<h2 id="4-6-对象构造"><a href="#4-6-对象构造" class="headerlink" title="4.6 对象构造"></a>4.6 对象构造</h2><h3 id="4-6-2-默认域初始化"><a href="#4-6-2-默认域初始化" class="headerlink" title="4.6.2 默认域初始化"></a>4.6.2 默认域初始化</h3><p>域与局部变量的主要不同点之一是，必须明确地初始化方法中的局部变量。但是，类中的域没有初始化，会自动初始化为默认值。</p>
<h3 id="4-6-7-初始化块"><a href="#4-6-7-初始化块" class="headerlink" title="4.6.7 初始化块"></a>4.6.7 初始化块</h3><blockquote>
<p>初始化数据域的方法：</p>
<ul>
<li>在构造器中设置值</li>
<li>在声明中赋值</li>
<li>初始化块<br>下面是调用构造器的具体处理步骤：</li>
</ul>
<ol>
<li>所有数据域被初始化为默认值。</li>
<li>按照在类声明中出现的次序，依次执行所有域初始化语句和初始化块。</li>
<li>如果构造器第一行调用了第二个构造器，则执行第二个构造器主体。</li>
<li>执行这个构造器的主体。</li>
</ol>
</blockquote>
<h1 id="5-继承"><a href="#5-继承" class="headerlink" title="5. 继承"></a>5. 继承</h1><h2 id="5-1-类、超类和子类"><a href="#5-1-类、超类和子类" class="headerlink" title="5.1 类、超类和子类"></a>5.1 类、超类和子类</h2><h3 id="5-1-3-子类构造器"><a href="#5-1-3-子类构造器" class="headerlink" title="5.1.3 子类构造器"></a>5.1.3 子类构造器</h3><p>关键字this有两个用途：一是引用隐式参数，二是调用该类其他的构造器。同样，super关键字也有两个用途：一是调用超类的方法，二是调用超类的构造器。在调用构造器的时候，这两个关键字的使用方式很相似。调用构造器的语句只能作为另一个构造器的第一条语句出现。构造参数既可以传递给本类（this）的其他构造器，也可以传递给超类（super）的构造器。  </p>
<blockquote>
<p>一个对象变量可以指示多种实际类型的现象被称为多态。在运行时能够自动地选择调用哪个方法的现象称为动态绑定。</p>
</blockquote>
<h3 id="5-1-5-多态"><a href="#5-1-5-多态" class="headerlink" title="5.1.5 多态"></a>5.1.5 多态</h3><p>在Java中，对象变量时多态的。一个Employee变量既可以引用一个Employee类对象，也可以引用一个Employee类的任何一个子类的对象（如manager）。  </p>
<pre><code class="Java">Manager boss = new Manager(...);
Employee[] staff = new Employee[3];
staff[0] = boss;
</code></pre>
<p>在这个例子中，变量staff[0]与boss引用同一个对象。但编译器将staff[0]看成Employee对象。这意味着，可以这样调用  </p>
<pre><code class="Java">boss.setBonus(5000) // OK
</code></pre>
<p>但不能这样调用  </p>
<pre><code class="Java">staff[0].setBonus(5000) // Error
</code></pre>
<h3 id="5-1-10-受保护访问"><a href="#5-1-10-受保护访问" class="headerlink" title="5.1.10 受保护访问"></a>5.1.10 受保护访问</h3><p>Java用于控制可见性的4个访问修饰符：  </p>
<ol>
<li>仅对本类可见——private</li>
<li>对所有类可见——public</li>
<li>对本包和所有子类可见——protected</li>
<li>对本包可见——默认，不需要修饰符  </li>
</ol>
<h2 id="5-2-Object：所有类的超类"><a href="#5-2-Object：所有类的超类" class="headerlink" title="5.2 Object：所有类的超类"></a>5.2 Object：所有类的超类</h2><h3 id="5-2-2-相等测试与继承"><a href="#5-2-2-相等测试与继承" class="headerlink" title="5.2.2 相等测试与继承"></a>5.2.2 相等测试与继承</h3><h1 id="6-接口、lambda表达式与内部类"><a href="#6-接口、lambda表达式与内部类" class="headerlink" title="6. 接口、lambda表达式与内部类"></a>6. 接口、lambda表达式与内部类</h1><h1 id="7-异常、断言和日志"><a href="#7-异常、断言和日志" class="headerlink" title="7. 异常、断言和日志"></a>7. 异常、断言和日志</h1>]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java核心技术卷1 基础知识（1-3）]]></title>
      <url>/2019/07/03/Java/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B71%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%881-3%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="1-Java程序设计概述"><a href="#1-Java程序设计概述" class="headerlink" title="1. Java程序设计概述"></a>1. Java程序设计概述</h1><p>Java剔除了C++中许多很少使用、难以理解、易混淆的特性，比如头文件、指针运算、结构、联合、操作符重载、虚基类等。</p>
<h1 id="3-Java的基本程序设计结构"><a href="#3-Java的基本程序设计结构" class="headerlink" title="3. Java的基本程序设计结构"></a>3. Java的基本程序设计结构</h1><h2 id="3-3-数据类型"><a href="#3-3-数据类型" class="headerlink" title="3.3 数据类型"></a>3.3 数据类型</h2><p>在Java中，一共有8种基本类型，其中有4中整型，2种浮点类型，1种用于表示Unicode编码的字符类型char和1种用于表示真值的boolean类型。  </p>
<h3 id="3-3-1-整型"><a href="#3-3-1-整型" class="headerlink" title="3.3.1 整型"></a>3.3.1 整型</h3><p>整型的范围与机器无关（C和C++与机器有关），int 4字节，long数值有一个后缀L或l，十六进制数值有一个前缀0X或0x，二进制前缀0b或0B，可以为数字加下划线，如用1_000_000表示一百万，只是为了更易读，Java编译器会去除这些下划线。  </p>
<h3 id="3-3-2-浮点型"><a href="#3-3-2-浮点型" class="headerlink" title="3.3.2 浮点型"></a>3.3.2 浮点型</h3><p>float数值有一个后缀F或f，double有一个后缀D或d，没有后缀的浮点数职默认为double。<br>浮点数采用二进制系统表示，无法精确的表示分数1/10，若不允许有任何舍入误差，就应该使用BigDecimal类。  </p>
<h3 id="3-3-3-char类型"><a href="#3-3-3-char类型" class="headerlink" title="3.3.3 char类型"></a>3.3.3 char类型</h3><p>char类型要用单引号括起来。’A’是字符常量，”A”是包含一个字符A的字符串。  </p>
<h3 id="3-3-4-boolean类型"><a href="#3-3-4-boolean类型" class="headerlink" title="3.3.4 boolean类型"></a>3.3.4 boolean类型</h3><p>在C++中，数值可以代替boolean值。值0相当于false，非0相当于true。在Java中，if(0)会编译不通过。  </p>
<h3 id="3-5-3-强制类型转换"><a href="#3-5-3-强制类型转换" class="headerlink" title="3.5.3 强制类型转换"></a>3.5.3 强制类型转换</h3><pre><code class="Java">double x = 9.997;
int nx = (int)x;
</code></pre>
<p>强制类型转换通过截断小数部分将浮点值转换为整型。  </p>
<pre><code class="Java">double x = 9.997;
int nx = (int)Math.round(x);
</code></pre>
<p>四舍五入。仍需要使用强制类型转换，因为round方法返回的结果为long类型。  </p>
<h3 id="3-5-4-结合赋值和运算符"><a href="#3-5-4-结合赋值和运算符" class="headerlink" title="3.5.4 结合赋值和运算符"></a>3.5.4 结合赋值和运算符</h3><pre><code class="Java">int x = 1;
x = x + 1.1;    //非法，需要使用强制类型转换
</code></pre>
<pre><code class="Java">int x = 1;
x += 1.1;    //合法，会自动强制类型转换
</code></pre>
<h2 id="3-6-字符串"><a href="#3-6-字符串" class="headerlink" title="3.6 字符串"></a>3.6 字符串</h2><h3 id="3-6-3-不可变字符串"><a href="#3-6-3-不可变字符串" class="headerlink" title="3.6.3 不可变字符串"></a>3.6.3 不可变字符串</h3><p>Java中的字符串是不可变的，不能把字符串看做字符型数组，而是相当于C++中的指针。  </p>
<h3 id="3-6-4-检测字符串是否相等"><a href="#3-6-4-检测字符串是否相等" class="headerlink" title="3.6.4 检测字符串是否相等"></a>3.6.4 检测字符串是否相等</h3><pre><code class="Java">&quot;Hello&quot;.equals(greeting);
&quot;Hello&quot;.equalsIgnoreCase(&quot;hello&quot;);  //true
</code></pre>
<p>不能使用==运算符检测两个字符串是否相等！这个运算符只能确定两个字符串是否放置在同一个位置上。  </p>
<h3 id="3-6-9-构建字符串"><a href="#3-6-9-构建字符串" class="headerlink" title="3.6.9 构建字符串"></a>3.6.9 构建字符串</h3><p>由较短的字符串构建字符串，采用字符串连接的方式效率比较低，每次连接都会构建一个新的String对象，既耗时，又浪费空间。。使用StringBuilder类可以避免这个问题。</p>
<pre><code class="Java">StringBuilder builder = new StringBuilder();
builder.append(ch);
builder.append(str);
String completedString = builder.toString();
</code></pre>
<h2 id="3-7-输入输出"><a href="#3-7-输入输出" class="headerlink" title="3.7 输入输出"></a>3.7 输入输出</h2><h3 id="3-7-3-文件输入与输出"><a href="#3-7-3-文件输入与输出" class="headerlink" title="3.7.3 文件输入与输出"></a>3.7.3 文件输入与输出</h3><pre><code class="Java">Scanner in = new Scanner(Paths.get(&quot;gmyfile.txt&quot;), &quot;UTF-8&quot;);
PrintWriter out = new PrintWriter(&quot;myfile.txt&quot;, &quot;UTF-8&quot;);
</code></pre>
<h2 id="3-8-控制流程"><a href="#3-8-控制流程" class="headerlink" title="3.8 控制流程"></a>3.8 控制流程</h2><h3 id="3-8-1-块作用域"><a href="#3-8-1-块作用域" class="headerlink" title="3.8.1 块作用域"></a>3.8.1 块作用域</h3><p>Java中不能在嵌套的两个块中声明同名的变量。<br>C++可以在嵌套的块中重定义一个变量。在内层定义的变量会覆盖在外层定义的变量。  </p>
<h3 id="3-8-5-多重选择：switch语句"><a href="#3-8-5-多重选择：switch语句" class="headerlink" title="3.8.5 多重选择：switch语句"></a>3.8.5 多重选择：switch语句</h3><p>switch()和case标签不能用浮点型。  </p>
<h2 id="3-9-大数值"><a href="#3-9-大数值" class="headerlink" title="3.9 大数值"></a>3.9 大数值</h2><p>BigDecimal  BigInteger  </p>
<h2 id="3-10-数组"><a href="#3-10-数组" class="headerlink" title="3.10 数组"></a>3.10 数组</h2><p>声明数组的两种形式：<br>int[] a;<br>或<br>int a[];<br>推荐第一种。<br>在数组初始化之前不能使用。<br>创建数字数组，所有元素都初始化为0。boolean数组初始化为false。对象数组初始化为null。  </p>
<pre><code class="Java">String[] names = new String[10];
</code></pre>
<p>一旦创建了数组，就不能再改变它的大小。如果要扩展数组的大小，就应该使用数组列表（array list）。  </p>
<h3 id="3-10-1-for-each-循环"><a href="#3-10-1-for-each-循环" class="headerlink" title="3.10.1 for each 循环"></a>3.10.1 for each 循环</h3><pre><code class="Java">for (int element: a)
    System.out.println(element);
</code></pre>
<h3 id="3-10-2-数组初始化以及匿名数组"><a href="#3-10-2-数组初始化以及匿名数组" class="headerlink" title="3.10.2 数组初始化以及匿名数组"></a>3.10.2 数组初始化以及匿名数组</h3><pre><code class="Java">int[] a = {2,3,4,5};
a = new int[]{2,3,4,5};
</code></pre>
<h3 id="3-10-3-数组拷贝"><a href="#3-10-3-数组拷贝" class="headerlink" title="3.10.3 数组拷贝"></a>3.10.3 数组拷贝</h3><p>两个变量引用了同一个数组</p>
<pre><code class="Java">int[] b = a;
b[5] = 12;// now a[5] is alse 12
</code></pre>
<p>将一个数组的所有值拷贝到一个新的数组中去，要使用Arrays类的copyOf方法：</p>
<pre><code class="Java">int[] b = Arrays.copyOf(a, a.length);
</code></pre>
<p>这个方法可以用来增加数组的大小。或者只拷贝前面部分元素。  </p>
<h3 id="3-10-6-多维数组"><a href="#3-10-6-多维数组" class="headerlink" title="3.10.6 多维数组"></a>3.10.6 多维数组</h3><pre><code class="Java">//二维数组遍历
int[][] a = 
    {
        {1,2,3,4},
        {1,2,3,4},
        {1,2,3,4},
        {1,2,3,4}
    };

for(int i = 0; i &lt; a.length; i++)
{
    for(int j = 0; j &lt; a[i].length; j++)
    {
        ...
    }
}
// 或
for (int[] row : a)
    for(int value : row)
        ...
</code></pre>
<pre><code class="Java">//快速打印二维数组
System.out.println(Arrays.deepToString(a));
</code></pre>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SDNMTD]]></title>
      <url>/2019/06/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/SDNMTD/</url>
      <content type="html"><![CDATA[<h1 id="软件定义网络-移动目标防御（SDNMTD）"><a href="#软件定义网络-移动目标防御（SDNMTD）" class="headerlink" title="软件定义网络-移动目标防御（SDNMTD）"></a>软件定义网络-移动目标防御（SDNMTD）</h1><h3 id="DHCP服务"><a href="#DHCP服务" class="headerlink" title="DHCP服务"></a>DHCP服务</h3><p>SDNMTD设备提供的DHCP服务与普通的DHCP服务有两点不同。其一，在成功分配IP地址的同时，SDNMTD设备需要记录所分配的主机信息，同时为其随机生成一个虚拟IP地址，并将主机信息记录在设备本地数据库中，为真假IP映射做准备；其二，SDNMTD设备提供的DHCP服务会通过设置不同掩码或者不同网络号的方式将局域网内所有主机分配在不同的网段，使他们无法通过真实IP地址相互通信，从而阻止黑客在内网根据本机IP地址和子网掩码对同一网段所有IP地址进行逐个扫描。</p>
<h3 id="IP地址映射"><a href="#IP地址映射" class="headerlink" title="IP地址映射"></a>IP地址映射</h3><p>由于普通交换机不可由控制器控制，因此无法阻止其广播行为，例如Client与Server可以直接通过普通交换机通信而不经过SDNMTD设备（Client广播的ARP请求经过普通交换机被Server收到并直接回复），由此导致SDNMTD设备无法对局域网内所有主机发送的包进行分析过滤。为解决该问题，需要将虚拟IP地址配置为与该局域网内真实IP地址不同的另一私网地址，在此情况下，由于作为目的IP的虚拟IP地址与本机IP处于不同网段，因此局域网内主机会将数据包发向网关，串联在网关链路上的SDNMTD设备一定会收到主机发送的数据包（Client广播的ARP请求目的为网关IP，因此其他所有设备收到该ARP请求都会自动丢弃）。</p>
<h3 id="ARP请求"><a href="#ARP请求" class="headerlink" title="ARP请求"></a>ARP请求</h3><p>在传统的局域网中，主机之间首次通信时首先将目的IP与本机的子网掩码作与运算，判断是否处于同一网段，若目的IP与本机IP处于同一网段，主机将会广播ARP请求获取目的IP对应的MAC地址，并由局域网内的对应主机发回ARP响应；若处于不同网段，则会广播ARP请求获取默认网关的MAC地址，由网关回复ARP响应。利用后者原理，可使所有主机发送的包都“途经”SDNMTD设备，正如在5.1.1小节中的第二部分分析的在真实局域网环境中（图5-2拓扑）数据包的转发过程——当虚拟IP地址与真实IP地址处在不同网段时，主机只会广播请求ARP解析默认网关的MAC地址，其他所有主机收到广播的ARP请求都会因为IP不匹配而自动丢弃。<br>这里实际的ARP请求与响应只是源主机和控制器之间的通信，控制器发回的ARP响应只是自己的MAC地址。  </p>
<h3 id="虚拟IP地址跳变"><a href="#虚拟IP地址跳变" class="headerlink" title="虚拟IP地址跳变"></a>虚拟IP地址跳变</h3><p>在跳变处理的最后一步，既可以选择下发新流表，也可以选择不下发。前者的优点是虚拟IP地址改变后新数据包可以直接根据OVS流表转发而不用再转至控制器处理，降低了虚拟IP地址跳变的延迟开销，缺点是需要为每一对客户端和服务器下发双向流表，当局域网中客户端和服务器数量较多时，需要统一下发的流表数量众多，占用较多的流表资源，增加流表匹配时间，且部分流表在对应客户端和服务器未通信时是不需使用的，造成流表资源浪费；而后者的方法是跳变后每次客户端与服务器通信时根据ICMP报文处理流程转发首个ICMP报文至控制器，再通过分析下发相应双向流表，此方法的优点是仅会为正在通信的一对客户端和服务器下发双向流表，节约流表资源，缺点是对于跳变后的首个ICMP报文需要转发至控制器，导致会增加一定延迟时间。根据上述分析，在客户端服务器数量少的局域网中采用统一下发流表的方式更为合适，在客户端服务器数量多但正在通信的客户端服务器数量少的情况下亦可采用不统一下发流表的方式。然而在真实企业局域网中，需要与之频繁通信的核心服务器数量较少，因此采用统一下发流表的方法造成的流表浪费开销可以接受，并且能够有效地减少虚拟IP跳变引起的延迟，因此在本实验中，采用统一下发新流表的方式。  </p>
<h3 id="传输层通信保障"><a href="#传输层通信保障" class="headerlink" title="传输层通信保障"></a>传输层通信保障</h3><h4 id="传输层通信中断原因"><a href="#传输层通信中断原因" class="headerlink" title="传输层通信中断原因"></a>传输层通信中断原因</h4><p>在传输层，客户端与服务器使用套接字“IP地址，端口号”作为通信的端点。而在本课题所研究的局域网中，客户端使用通过域名解析获得的服务器虚拟IP进行通信，因此以客户端的“视角”，其发送的请求的源套接字为“Client rIP, Client Port”， 目的套接字为“Server vIP, Server Port”；而以服务器的“视角”，其收到的请求的源套接字为“Client vIP, Client Port”，目的套接字为“Server rIP, Server Port”。在真实环境中，由于服务器虚拟IP地址改变后需要客户端重新进行域名解析，因此服务器虚拟IP的改变必然会使正在进行的通信中断，因此在实验中服务器的虚拟IP改变频率极低可认为不变。因此对于客户端来说，源和目的套接字均未改变，而对于服务器来说，虚拟IP地址跳变必然会改变源套接字中的Client vIP，因而导致传输层通信中断。  </p>
<h4 id="TCP通信保障方法"><a href="#TCP通信保障方法" class="headerlink" title="TCP通信保障方法"></a>TCP通信保障方法</h4><p>每当捕获到TCP连接请求时，为该连接添加一对优先级高于IP层流表的临时流表，并在捕获到TCP断连请求时删除对应临时流表。<br>临时流表仅供该TCP连接使用，不影响使用Ping命令时客户端虚拟IP的动态跳变。</p>
]]></content>
      
        <categories>
            
            <category> 计算机网络 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> SDN </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[matlab 与 python 转换]]></title>
      <url>/2019/06/25/%E6%9D%82%E9%A1%B9/matlab%20%E4%B8%8E%20python%20%E8%BD%AC%E6%8D%A2/</url>
      <content type="html"><![CDATA[<h3 id="取最大值索引"><a href="#取最大值索引" class="headerlink" title="取最大值索引"></a>取最大值索引</h3><pre><code class="matlab">% matlab
[~,y(i)]=max(x(i,:));    % 取最大值的索引
</code></pre>
<pre><code class="python"># python
y[i-1] = np.argmax(x[i-1])
</code></pre>
<h3 id="python-与-matlab-产生相同的随机数"><a href="#python-与-matlab-产生相同的随机数" class="headerlink" title="python 与 matlab 产生相同的随机数"></a>python 与 matlab 产生相同的随机数</h3><pre><code class="matlab">rand(&#39;twister&#39;, 1337);
b2=2*rand(N1+1,N2)-1;
</code></pre>
<pre><code class="python">np.random.rand(1337)
# numpy产生的随机数是按列排的，需要转置两次
b2 = 2 * np.random.rand(N2, N1 + 1) - 1
b2 = b2.T
</code></pre>
<h3 id="numpy-避免显示科学计数法"><a href="#numpy-避免显示科学计数法" class="headerlink" title="numpy 避免显示科学计数法"></a>numpy 避免显示科学计数法</h3><pre><code class="python">np.set_printoptions(suppress=True)
</code></pre>
<h3 id="正态标准化"><a href="#正态标准化" class="headerlink" title="正态标准化"></a>正态标准化</h3><pre><code class="matlab">train_x = zscore(train_x&#39;)&#39;;
</code></pre>
<pre><code class="python"># 正态标准化  ddof=1 is equal to matlab !!!
train_x = stats.zscore(train_x.T, ddof=1).T
</code></pre>
<h3 id="矩阵拼接"><a href="#矩阵拼接" class="headerlink" title="矩阵拼接"></a>矩阵拼接</h3><pre><code class="matlab">H1 = [train_x .1 * ones(size(train_x,1),1)];
</code></pre>
<pre><code class="python">temp = 0.1 * np.ones((train_x.shape[0], 1))
H1 = np.concatenate((train_x, temp), axis=1)
</code></pre>
<h3 id="归一化（区间缩放）"><a href="#归一化（区间缩放）" class="headerlink" title="归一化（区间缩放）"></a>归一化（区间缩放）</h3><pre><code class="matlab">% 默认为[-1,1]
[T1,ps1]  =  mapminmax(T1&#39;,0,1);
TT1 =  mapminmax(&#39;apply&#39;,TT1&#39;,ps1)&#39;;
</code></pre>
<pre><code class="python"># 默认为[0,1]
scaler1 = MinMaxScaler(feature_range=(0, 1))
T1 = scaler1.fit_transform(T1)
</code></pre>
]]></content>
      
        <categories>
            
            <category> 杂项 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> matlab python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[归一化与标准化]]></title>
      <url>/2019/06/20/%E6%95%B0%E5%AD%A6/%E5%BD%92%E4%B8%80%E5%8C%96%E4%B8%8E%E6%A0%87%E5%87%86%E5%8C%96/</url>
      <content type="html"><![CDATA[<h2 id="归一化"><a href="#归一化" class="headerlink" title="归一化"></a>归一化</h2><p>利用数据的最大值、最小值特征，将数据缩放到新的区间上。</p>
<p>$$ v_{i}^{‘} = \frac{v_{i}-min_{A}}{max_{A}-min_{A}}(newMax_{A}-newMin_{A}) + newMin_{A} $$</p>
<h2 id="标准化"><a href="#标准化" class="headerlink" title="标准化"></a>标准化</h2><h3 id="0-1-标准化"><a href="#0-1-标准化" class="headerlink" title="[0,1]标准化"></a>[0,1]标准化</h3><p>将数据压缩到0~1之间  </p>
<p>$$ x = \frac{x - min(x)}{max(x) - min(x)} $$ </p>
<h3 id="z-score标准化（正态标准化）"><a href="#z-score标准化（正态标准化）" class="headerlink" title="z-score标准化（正态标准化）"></a>z-score标准化（正态标准化）</h3><p>分数与平均数的差再除以标准差,标准化后的数据是均值为0，方差为1的正太分布。  </p>
<p>$$ x = \frac{x - mean}{std} $$</p>
<p>标准分数可以回答这样一个问题：“一个给定分数距离平均数多少个标准差？”在平均数之上的分数会得到一个正的标准分数，在平均数之下的分数会得到一个负的标准分数。</p>
]]></content>
      
        <categories>
            
            <category> 数学 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[机器学习7-]]></title>
      <url>/2019/05/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A07-/</url>
      <content type="html"><![CDATA[<h1 id="第七章-Logistic-回归"><a href="#第七章-Logistic-回归" class="headerlink" title="第七章 Logistic 回归"></a>第七章 Logistic 回归</h1><ul>
<li>不要将线性回归用于分类问题。</li>
<li>逻辑回归实际上是分类问题，尽管叫做回归（由于历史原因）。</li>
<li>为了使 h(x) 在 0-1 区间内（<strong>有百分之多少的概率为1或者0</strong>），引入 logistic function (sigmoid function)</li>
</ul>
<p>$$ g(z) = \frac{1}{1 + e^{-z}} $$</p>
<h2 id="决策界限-decision-boundary"><a href="#决策界限-decision-boundary" class="headerlink" title="决策界限(decision boundary)"></a>决策界限(decision boundary)</h2><h2 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h2><p>对于线性回归模型，我们定义的代价函数是所有模型误差的平方和。 </p>
<p>$$ J=\frac{1}{2m}\sum_{i=1}^{n}(h_{\theta}(x^{(i)})-y^{(i)})^2 $$</p>
<p>但在逻辑回归模型中，继续沿用这个定义，将  </p>
<p>$$ h(x) = \frac{1}{1 + e^{-\theta^TX}} $$</p>
<p>带入这样的代价函数中会得到一个非凸函数（有许多局部最小值），影响梯度下降算法寻找全局最小值。<br>所以要重新定义逻辑回归的代价函数，引入log函数。</p>
<h2 id="高级优化"><a href="#高级优化" class="headerlink" title="高级优化"></a>高级优化</h2><ul>
<li>共轭梯度法</li>
<li>BFGS（变尺度法）</li>
<li>L-BFGS（限制变尺度法）</li>
</ul>
<p>这些算法的运行速度通常远远超过梯度下降，所以如果机器学习的问题很大时，可以用这些算法。</p>
<h1 id="第八章-正则化-Regularization"><a href="#第八章-正则化-Regularization" class="headerlink" title="第八章 正则化 (Regularization)"></a>第八章 正则化 (Regularization)</h1><h3 id="处理过拟合"><a href="#处理过拟合" class="headerlink" title="处理过拟合"></a>处理过拟合</h3><ul>
<li>丢弃一些无用（或相关性低）的特征。可以是手工选择保留哪些特征，或者使用一些模型选择的算法来帮忙（如PCA）</li>
<li>正则化。保留所有特征，但是减少参数的大小。</li>
</ul>
<h3 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h3><p>为了使假设函数尽量平滑，避免过拟合，要修改代价函数，为参数θ设置一点惩罚（乘上一个较大数），从而导致选择较小的参数。</p>
<p>$$ J(\theta) = \frac{1}{2m}[\sum_{i=1}^m(h_\theta(x^{(i)})-y^{(i)})^2 - \lambda\sum_{j=1}^{n}\theta_j^2] $$</p>
<p>其中λ又称正则化参数。</p>
]]></content>
      
        <categories>
            
            <category> 机器学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MongoDB学习笔记]]></title>
      <url>/2019/05/24/MongoDB/MongoDB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h1 id="1-初识-MongoDB"><a href="#1-初识-MongoDB" class="headerlink" title="1. 初识 MongoDB"></a>1. 初识 MongoDB</h1><h2 id="1-1-MongoDB的特点"><a href="#1-1-MongoDB的特点" class="headerlink" title="1.1 MongoDB的特点"></a>1.1 MongoDB的特点</h2><ol>
<li>数据存储格式为BSON（一种JSON的扩展）</li>
<li>面向集合存储，没有固定的表头。</li>
<li>模式自由。可以存键不一样的文档，可以轻松增减字段。</li>
<li>支持复制和故障恢复。从节点备份主节点的数据。</li>
<li>二进制数据存储方式，=。可以将图片甚至视频转换成二进制存储到数据库中。</li>
<li>自动分片。实现海量数据分布式存储。</li>
<li>使用内存映射存储引擎。</li>
</ol>
<h2 id="1-2-MongDB应用场景"><a href="#1-2-MongDB应用场景" class="headerlink" title="1.2 MongDB应用场景"></a>1.2 MongDB应用场景</h2><h3 id="1-2-1-MongoDB适应场景"><a href="#1-2-1-MongoDB适应场景" class="headerlink" title="1.2.1 MongoDB适应场景"></a>1.2.1 MongoDB适应场景</h3><ol>
<li>网站数据<br>实时插入、更新与查询。迭代更新快、需求变更多、以对象数据为主的网站应用。</li>
<li>信息基础设施的缓存层</li>
<li>大尺寸、低价值的数据<br>关系型数据库要先创建表格，设计表结构，进行数据清理，才能存入。MongoDB可以随意存储，留着以后处理。</li>
<li>高伸缩性的场景<br>网站数据量大，可自动分片。</li>
</ol>
<h3 id="1-2-2-MongoDB不适合的场景"><a href="#1-2-2-MongoDB不适合的场景" class="headerlink" title="1.2.2 MongoDB不适合的场景"></a>1.2.2 MongoDB不适合的场景</h3><ol>
<li>高度事务性的系统<br>传统的关系型数据库目前还是更适应于需要大量原子性复杂实物的系统，如银行或会计系统。支持事务，当原子性操作失败时数据能够回滚。MongoDB不支持此事务。</li>
<li>传统的商业智能应用<br>针对特定问题的BI数据库需要<strong>高度优化</strong>的查询方式，数据仓库是更好的选择。</li>
<li>使用SQL方便时  </li>
<li>MongoDB的查询方式是JSON类型的查询方式，虽然查询也比较灵活，但如果使用SQL统计比较方便时，不适合使用MongoDB。</li>
</ol>
<h1 id="2-MongoDB的结构"><a href="#2-MongoDB的结构" class="headerlink" title="2. MongoDB的结构"></a>2. MongoDB的结构</h1><h2 id="2-1-子集合"><a href="#2-1-子集合" class="headerlink" title="2.1 子集合"></a>2.1 子集合</h2><h2 id="2-2-固定集合-Capped"><a href="#2-2-固定集合-Capped" class="headerlink" title="2.2 固定集合(Capped)"></a>2.2 固定集合(Capped)</h2><h3 id="2-2-1-Capped-特点"><a href="#2-2-1-Capped-特点" class="headerlink" title="2.2.1 Capped 特点"></a>2.2.1 Capped 特点</h3><ol>
<li>有着固定大小，如果空间不足，淘汰最早的数据。</li>
<li>顺序插入。</li>
<li>可以插入和更新，不允许删除（可以调用drop()删除所有行）。</li>
</ol>
<h3 id="2-2-2-Capped-应用场景"><a href="#2-2-2-Capped-应用场景" class="headerlink" title="2.2.2 Capped 应用场景"></a>2.2.2 Capped 应用场景</h3><ol>
<li>存储日志信息。</li>
<li>缓存一些少量的文档。</li>
</ol>
<h2 id="2-3-文档"><a href="#2-3-文档" class="headerlink" title="2.3 文档"></a>2.3 文档</h2><ul>
<li><strong>文档中的键值对是有序的，前后顺序不同就是不同的文档！！！</strong></li>
</ul>
<h3 id="2-3-1-自动关联内嵌文档DBRef"><a href="#2-3-1-自动关联内嵌文档DBRef" class="headerlink" title="2.3.1 自动关联内嵌文档DBRef"></a>2.3.1 自动关联内嵌文档DBRef</h3><p>DBRef存储关联id，自动关联指定集合中的对应文档，可以当做普通内嵌文档那样读取，修改时也只要修改指定集合中的对应文档，则所有引用了对应文档的文档也会得到更新。  </p>
<h1 id="3-MongoDB的大文件存储规范GridFs"><a href="#3-MongoDB的大文件存储规范GridFs" class="headerlink" title="3. MongoDB的大文件存储规范GridFs"></a>3. MongoDB的大文件存储规范GridFs</h1><p>MongoDB支持二进制数据类型，能存储文件，但是单个BSON对象最大不能超过16MB。存储更大的文件，要用GridFS。  </p>
<h2 id="3-1-GridFS应用场景"><a href="#3-1-GridFS应用场景" class="headerlink" title="3.1 GridFS应用场景"></a>3.1 GridFS应用场景</h2><ol>
<li>有大量的上传图片，类似于CDN的功能，一些静态文件也可放置于MongoDB中，方便统一管理和备份。  </li>
<li>很多大文件需要存放，单台服务器放不下的情况，可以考虑GridFS，因为MongoDB可以部署集群。</li>
<li>文件的备份，文件系统访问的故障转移和修复。比如小型网盘，方便管理，检查重复文件也比较方便。</li>
</ol>
<h2 id="3-2-GridFS的局限性"><a href="#3-2-GridFS的局限性" class="headerlink" title="3.2 GridFS的局限性"></a>3.2 GridFS的局限性</h2><ol>
<li>工作集<br>GridFS的文件会影响内存工作集。 </li>
<li>性能<br>文件服务性能会慢于从Web服务器或者文件系统中提供本地文件服务的性能。  </li>
<li>原子更新<br>GridFS没有提供对文件的原子更新方式。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> MongoDB </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MongoDB </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[机器学习1-6]]></title>
      <url>/2019/05/20/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A01-6/</url>
      <content type="html"><![CDATA[<h1 id="第一章-绪论：初识机器学习"><a href="#第一章-绪论：初识机器学习" class="headerlink" title="第一章 绪论：初识机器学习"></a>第一章 绪论：初识机器学习</h1><h2 id="监督学习-Supervised-Learning"><a href="#监督学习-Supervised-Learning" class="headerlink" title="监督学习(Supervised Learning)"></a>监督学习(Supervised Learning)</h2><p>给出正确答案，得到更多的正确答案。</p>
<h3 id="回归问题-Regression"><a href="#回归问题-Regression" class="headerlink" title="回归问题(Regression)"></a>回归问题(Regression)</h3><p>用离散值来预测连续值（房子面积与价格的关系），输出连续值。</p>
<h3 id="分类问题-Classification"><a href="#分类问题-Classification" class="headerlink" title="分类问题(Classification)"></a>分类问题(Classification)</h3><p>输出离散值（是否患癌症）</p>
<h2 id="无监督学习-Unsupervised-Learning"><a href="#无监督学习-Unsupervised-Learning" class="headerlink" title="无监督学习(Unsupervised Learning)"></a>无监督学习(Unsupervised Learning)</h2><h3 id="聚类-Clustering"><a href="#聚类-Clustering" class="headerlink" title="聚类(Clustering)"></a>聚类(Clustering)</h3><h1 id="第二章：单变量线性回归"><a href="#第二章：单变量线性回归" class="headerlink" title="第二章：单变量线性回归"></a>第二章：单变量线性回归</h1><h3 id="假设函数h-hypothesis"><a href="#假设函数h-hypothesis" class="headerlink" title="假设函数h(hypothesis)"></a>假设函数h(hypothesis)</h3><p>$$ h_{\theta}(x) = \theta_{0} + \theta_{1}x $$</p>
<p>x到y的线性函数，即要求的结果</p>
<h3 id="单变量线性回归-Univariate-linear-regression"><a href="#单变量线性回归-Univariate-linear-regression" class="headerlink" title="单变量线性回归(Univariate linear regression)"></a>单变量线性回归(Univariate linear regression)</h3><h3 id="代价函数J-cost-function"><a href="#代价函数J-cost-function" class="headerlink" title="代价函数J(cost function)"></a>代价函数J(cost function)</h3><p>$$ J=\frac{1}{2m}\sum_{i=1}^{n}(h_{\theta}(x^{(i)})-y^{(i)})^2 $$</p>
<blockquote>
<p>除以2m而不是m是为了后续数学计算的方便。因为这里无论除以2m还是m，代价函数最优化的结果θ都是相同的。如果是2m，后面代价函数对θ求导，可以把2约去。    </p>
</blockquote>
<p>平方误差代价函数——预测值减真实值的平方和，取平均。对于大多数回归问题都比较适用。</p>
<ul>
<li>单变量代价函数是二维的线（如抛物线），可以直接取到最低点，两个变量的代价函数是三维的曲面（高度表示代价），可用二维的等高线来表示。</li>
</ul>
<h3 id="梯度下降-gradient-descent"><a href="#梯度下降-gradient-descent" class="headerlink" title="梯度下降(gradient descent)"></a>梯度下降(gradient descent)</h3><p>$$ \theta_j = \theta_j - \alpha\frac{1}{m}\sum_{i=1}^{m}(h_\theta(x^{(i)})-y^{(i)})x_j^{(i)} $$</p>
<h3 id="凸函数-convex-function"><a href="#凸函数-convex-function" class="headerlink" title="凸函数(convex function)"></a>凸函数(convex function)</h3><p>没有局部最优，只有全局最优</p>
<h3 id="批量梯度下降-batch-gradient-descent"><a href="#批量梯度下降-batch-gradient-descent" class="headerlink" title="批量梯度下降(batch gradient descent)"></a>批量梯度下降(batch gradient descent)</h3><p>在梯度下降的每一步，都用到了所有训练样本（求和运算）</p>
<h1 id="第三章：线性代数回顾"><a href="#第三章：线性代数回顾" class="headerlink" title="第三章：线性代数回顾"></a>第三章：线性代数回顾</h1><ul>
<li>矩阵乘法满足结合律，不满足交换律</li>
</ul>
<h3 id="单位矩阵-identity-matrix"><a href="#单位矩阵-identity-matrix" class="headerlink" title="单位矩阵(identity matrix)"></a>单位矩阵(identity matrix)</h3><h3 id="奇异矩阵-singular-matrix"><a href="#奇异矩阵-singular-matrix" class="headerlink" title="奇异矩阵(singular matrix)"></a>奇异矩阵(singular matrix)</h3><p>也叫退化矩阵(degenerate matrix)，指没有逆矩阵的矩阵。</p>
<h1 id="第四章：配置"><a href="#第四章：配置" class="headerlink" title="第四章：配置"></a>第四章：配置</h1><h1 id="第五章：多变量线性回归"><a href="#第五章：多变量线性回归" class="headerlink" title="第五章：多变量线性回归"></a>第五章：多变量线性回归</h1><h3 id="特征缩放-Feature-Scaling"><a href="#特征缩放-Feature-Scaling" class="headerlink" title="特征缩放(Feature Scaling)"></a>特征缩放(Feature Scaling)</h3><p>使各个特征在相似的大小范围内，从而得到的等高线图更圆，梯度下降算法可以更快地收敛。<br>一般地，把特征缩放到-1到1（或-3到3，-1/3到1/3）的范围内。所有特征范围不需要完全相同，接近就可。</p>
<ul>
<li>均值归一化<br>(特征值-均值)/特征值范围  （或者标准差）<br>得到新范围大致为-0.5~0.5<br>总之，特征缩放不需要太精确，只是为了让梯度下降，能够运行得快一点而已（收敛所需要的迭代次数更少）。</li>
</ul>
<h3 id="学习率α的调整"><a href="#学习率α的调整" class="headerlink" title="学习率α的调整"></a>学习率α的调整</h3><p>画出代价函数J与迭代次数n的关系图，来看梯度下降算法的收敛情况。通常，只要学习率α足够小，就一定会收敛。通过调整学习率（依次取3倍的值），取得最大可能值，使收敛速度尽可能快。</p>
<h3 id="正规方程法-normal-equation-method"><a href="#正规方程法-normal-equation-method" class="headerlink" title="正规方程法(normal equation method)"></a>正规方程法(normal equation method)</h3><p>不需要特征缩放</p>
<table>
<thead>
<tr>
<th>梯度下降法</th>
<th>正规方程法</th>
</tr>
</thead>
<tbody>
<tr>
<td>需要选择学习率α</td>
<td>不需要选择学习率</td>
</tr>
<tr>
<td>需要多次迭代</td>
<td>不需要迭代</td>
</tr>
<tr>
<td>即便n很大也能很好地运行</td>
<td>n很大会很慢</td>
</tr>
</tbody>
</table>
<p>当n是几千以下，用正规方程法。<br>当n是数万以上，用梯度下降法。</p>
<ul>
<li>正规方程法要求矩阵的逆，如果矩阵不可逆，看看特征里面是否有线性相关的特征或多余的特征，将其删除。</li>
</ul>
<h1 id="第六章-Octave-Matlab-教程"><a href="#第六章-Octave-Matlab-教程" class="headerlink" title="第六章 Octave/Matlab 教程"></a>第六章 Octave/Matlab 教程</h1><h3 id="向量化-vectorization"><a href="#向量化-vectorization" class="headerlink" title="向量化(vectorization)"></a>向量化(vectorization)</h3><p>在梯度下降算法中使用向量比自己写循环更高效。</p>
]]></content>
      
        <categories>
            
            <category> 机器学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux 与 MongoDB 的一些命令]]></title>
      <url>/2019/05/14/%E6%9D%82%E9%A1%B9/Linux%20%E4%B8%8E%20MongoDB%20%E7%9A%84%E4%B8%80%E4%BA%9B%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<h2 id="后台运行MongoDB备份"><a href="#后台运行MongoDB备份" class="headerlink" title="后台运行MongoDB备份"></a>后台运行MongoDB备份</h2><pre><code>nohup mongodump -d Ais -o dump20190404 --gzip &gt;dump.out &amp;
// 后台备份，避免ssh断开导致程序退出，输出日志在dump.out里
</code></pre><h2 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h2><pre><code>ps -ef|grep mongo
</code></pre><h2 id="查看进程启动的精确时间和启动后所流逝的时间"><a href="#查看进程启动的精确时间和启动后所流逝的时间" class="headerlink" title="查看进程启动的精确时间和启动后所流逝的时间"></a>查看进程启动的精确时间和启动后所流逝的时间</h2><pre><code>ps -eo pid,lstart,etime,cmd | grep calDu..
</code></pre><p>ps命令将某个进程显示出来<br>grep命令是查找<br>-e 显示所有进程。<br>-f 全格式。<br>中间的|是管道命令   是指ps命令与grep同时执行。<br>PS是LINUX下最常用的也是非常强大的进程查看命令。<br>grep命令是查找，是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。<br>以下这条命令是检查java   进程是否存在：ps -ef |grep java</p>
<p>字段含义如下：<br>UID       PID       PPID      C     STIME    TTY       TIME         CMD</p>
<p>zzw      14124   13991      0     00:38      pts/0      00:00:00    grep –color=auto dae</p>
<p>UID      ：程序被该 UID 所拥有</p>
<p>PID      ：就是这个程序的 ID </p>
<p>PPID    ：则是其上级父程序的ID</p>
<p>C          ：CPU使用的资源百分比</p>
<p>STIME ：系统启动时间</p>
<p>TTY     ：登入者的终端机位置</p>
<p>TIME   ：使用掉的CPU时间。</p>
<p>CMD   ：所下达的是什么指令</p>
<h2 id="利用ssh传输文件"><a href="#利用ssh传输文件" class="headerlink" title="利用ssh传输文件"></a>利用ssh传输文件</h2><p>1、从服务器上下载文件</p>
<pre><code>scp username@servername:/path/filename /var/www/local_dir（本地目录）
</code></pre><p> 例如scp root@192.168.0.101:/var/www/test.txt  把192.168.0.101上的/var/www/test.txt 的文件下载到/var/www/local_dir（本地目录）</p>
<p>2、上传本地文件到服务器</p>
<pre><code>scp /path/filename username@servername:/path
</code></pre><p>例如scp /var/www/test.php  root@192.168.0.101:/var/www/  把本机/var/www/目录下的test.php文件上传到192.168.0.101这台服务器上的/var/www/目录中</p>
<p>3、从服务器下载整个目录</p>
<pre><code>scp -r username@servername:/var/www/remote_dir/（远程目录） /var/www/local_dir（本地目录）
</code></pre><p>例如:scp -r root@192.168.0.101:/var/www/test  /var/www/  </p>
<p>4、上传目录到服务器</p>
<pre><code>scp  -r local_dir username@servername:remote_dir
</code></pre><p>例如：scp -r test  root@192.168.0.101:/var/www/   把当前目录下的test目录上传到服务器的/var/www/ 目录</p>
<h2 id="查看目前文件系统的可用空间及使用情况"><a href="#查看目前文件系统的可用空间及使用情况" class="headerlink" title="查看目前文件系统的可用空间及使用情况"></a>查看目前文件系统的可用空间及使用情况</h2><p>df -h</p>
<h2 id="查看当前文件夹大小"><a href="#查看当前文件夹大小" class="headerlink" title="查看当前文件夹大小"></a>查看当前文件夹大小</h2><p>du -sh</p>
<h2 id="查看内存信息"><a href="#查看内存信息" class="headerlink" title="查看内存信息"></a>查看内存信息</h2><p>free -h<br>top</p>
<h2 id="重命名文件或文件夹"><a href="#重命名文件或文件夹" class="headerlink" title="重命名文件或文件夹"></a>重命名文件或文件夹</h2><p>mv A B</p>
<h2 id="删除文件夹"><a href="#删除文件夹" class="headerlink" title="删除文件夹"></a>删除文件夹</h2><p>rm -rf</p>
<h2 id="新建文件夹"><a href="#新建文件夹" class="headerlink" title="新建文件夹"></a>新建文件夹</h2><p>mkdir 文件名</p>
<h2 id="screen"><a href="#screen" class="headerlink" title="screen"></a>screen</h2><ul>
<li>screen 打开新窗口</li>
<li>screen -S session_name 打开带名字窗口</li>
<li>ctrl+a d 退出当前窗口（后台运行）</li>
<li>screen -r 重新进入窗口</li>
<li>screen -ls 列出所有窗口</li>
<li>screen -X -S [session # you want to kill] quit<br>screen -wipe  删除窗口</li>
<li>ctrl+a  :quit 删除窗口</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 杂项 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux MongoDB </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Excel]]></title>
      <url>/2019/04/20/%E6%9D%82%E9%A1%B9/Excel/</url>
      <content type="html"><![CDATA[<h2 id="Excel批量搜索并删除内容"><a href="#Excel批量搜索并删除内容" class="headerlink" title="Excel批量搜索并删除内容"></a>Excel批量搜索并删除内容</h2><p>(<a href="https://jingyan.baidu.com/article/574c521916f4816c8d9dc1a7.html" target="_blank" rel="external">https://jingyan.baidu.com/article/574c521916f4816c8d9dc1a7.html</a>)</p>
<h2 id="批量删除csv文件的前几行"><a href="#批量删除csv文件的前几行" class="headerlink" title="批量删除csv文件的前几行"></a>批量删除csv文件的前几行</h2><p>(<a href="http://www.bathome.net/thread-40024-1-1.html" target="_blank" rel="external">http://www.bathome.net/thread-40024-1-1.html</a>)</p>
<h2 id="多个csv表合并在一个表中"><a href="#多个csv表合并在一个表中" class="headerlink" title="多个csv表合并在一个表中"></a>多个csv表合并在一个表中</h2><p>(<a href="https://jingyan.baidu.com/article/1709ad8074d1b54634c4f00b.html" target="_blank" rel="external">https://jingyan.baidu.com/article/1709ad8074d1b54634c4f00b.html</a>)</p>
]]></content>
      
        <categories>
            
            <category> 杂项 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Tips]]></title>
      <url>/2019/04/03/JavaScript/Tips/</url>
      <content type="html"><![CDATA[<h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><ul>
<li><p>实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制</p>
<pre><code class="JS">Object.prototype.clone = function(){

  var o = this.constructor === Array ? [] : {};

  for(var e in this){

      o[e] = typeof this[e] === &quot;object&quot; ? this[e].clone() : this[e];

  }

  return o;
}
</code></pre>
</li>
</ul>
<h2 id="对象的拷贝"><a href="#对象的拷贝" class="headerlink" title="对象的拷贝"></a>对象的拷贝</h2><p>如果要拷贝一个对象，需要做到下面两件事情。<br>确保拷贝后的对象，与原对象具有同样的原型。<br>确保拷贝后的对象，与原对象具有同样的实例属性。</p>
<pre><code class="JS">function copyObject(orig) {
  return Object.create(
    Object.getPrototypeOf(orig),
    Object.getOwnPropertyDescriptors(orig)
  );
}
</code></pre>
<h2 id="类与普通构造函数的区别"><a href="#类与普通构造函数的区别" class="headerlink" title="类与普通构造函数的区别"></a>类与普通构造函数的区别</h2><ul>
<li>类的内部所有定义的方法，都是不可枚举的（non-enumerable）。</li>
</ul>
<pre><code class="JS">class Point {
  constructor(x, y) {
    // ...
  }

  toString() {
    // ...
  }
}

Object.keys(Point.prototype)
// []
Object.getOwnPropertyNames(Point.prototype)
// [&quot;constructor&quot;,&quot;toString&quot;]
</code></pre>
<p>上面代码中，toString方法是Point类内部定义的方法，它是不可枚举的。这一点与 ES5 的行为不一致。</p>
<pre><code class="JS">var Point = function (x, y) {
  // ...
};

Point.prototype.toString = function() {
  // ...
};

Object.keys(Point.prototype)
// [&quot;toString&quot;]
Object.getOwnPropertyNames(Point.prototype)
// [&quot;constructor&quot;,&quot;toString&quot;]
</code></pre>
<p>上面代码采用 ES5 的写法，toString方法就是可枚举的。</p>
<ul>
<li>类必须使用new调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用new也可以执行。</li>
</ul>
<pre><code class="JS">class Foo {
  constructor() {
    return Object.create(null);
  }
}

Foo()
// TypeError: Class constructor Foo cannot be invoked without &#39;new&#39;
</code></pre>
<h2 id="原型链-prototype、-proto-、constructor"><a href="#原型链-prototype、-proto-、constructor" class="headerlink" title="原型链 prototype、__proto__、constructor"></a>原型链 prototype、__proto__、constructor</h2><p>我们需要牢记两点：</p>
<ol>
<li><strong>proto</strong>和constructor属性是对象所独有的；</li>
<li>prototype属性是函数所独有的，因为函数也是一种对象，所以函数也拥有<strong>proto</strong>和constructor属性。</li>
</ol>
<p><strong>proto</strong>属性的作用就是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的<strong>proto</strong>属性所指向的那个对象（父对象）里找，一直找，直到<strong>proto</strong>属性的终点null，然后返回undefined，通过<strong>proto</strong>属性将对象连接起来的这条链路即我们所谓的原型链。</p>
<p>prototype属性的作用就是让该函数所实例化的对象们都可以找到公用的属性和方法，即f1.<strong>proto</strong> === Foo.prototype。</p>
<p>constructor属性的含义就是指向该对象的构造函数，所有函数（此时看成对象了）最终的构造函数都指向Function。</p>
<p><a href="https://blog.csdn.net/cc18868876837/article/details/81211729" target="_blank" rel="external">https://blog.csdn.net/cc18868876837/article/details/81211729</a></p>
<h2 id="获取原型对象的方法比较"><a href="#获取原型对象的方法比较" class="headerlink" title="获取原型对象的方法比较"></a>获取原型对象的方法比较</h2><p>如前所述，<strong>proto</strong>属性指向当前对象的原型对象，即构造函数的prototype属性。</p>
<pre><code class="JS">var obj = new Object();

obj.__proto__ === Object.prototype
// true
obj.__proto__ === obj.constructor.prototype
// true
</code></pre>
<p>上面代码首先新建了一个对象obj，它的<strong>proto</strong>属性，指向构造函数（Object或obj.constructor）的prototype属性。</p>
<p>因此，获取实例对象obj的原型对象，有三种方法。</p>
<pre><code class="JS">obj.__proto__
obj.constructor.prototype
Object.getPrototypeOf(obj)
</code></pre>
<p>上面三种方法之中，前两种都不是很可靠。<strong>proto</strong>属性只有浏览器才需要部署，其他环境可以不部署。而obj.constructor.prototype在手动改变原型对象时，可能会失效。因此，推荐使用第三种Object.getPrototypeOf方法，获取原型对象。</p>
<h2 id="new过程"><a href="#new过程" class="headerlink" title="new过程"></a>new过程</h2><p>使用new命令时，它后面的函数依次执行下面的步骤。</p>
<ol>
<li>创建一个空对象，作为将要返回的对象实例。</li>
<li>将这个空对象的原型，指向构造函数的prototype属性。</li>
<li>将这个空对象赋值给函数内部的this关键字。</li>
<li>开始执行构造函数内部的代码。</li>
</ol>
<h2 id="作用域提升"><a href="#作用域提升" class="headerlink" title="作用域提升"></a>作用域提升</h2><h3 id="变量被提升"><a href="#变量被提升" class="headerlink" title="变量被提升"></a>变量被提升</h3><p>对JavaScript解释器而言，所有的函数和变量声明都会被提升到最前面, 并且变量声明永远在前面，赋值在声明过程之后。比如:</p>
<pre><code class="JS">var x = 10;
function x(){};
console.log(x); // 10
</code></pre>
<p>实际上被解释为:</p>
<pre><code class="JS">var x;
function x(){};
x = 10;
console.log(x); // 10
</code></pre>
<h3 id="函数被提升"><a href="#函数被提升" class="headerlink" title="函数被提升"></a>函数被提升</h3><p>函数的声明方式主要由两种：声明式和变量式。</p>
<p><strong>声明式会自动将声明放在前面并且执行赋值过程。而变量式则是先将声明提升，然后到赋值处再执行赋值。</strong> a比如:</p>
<pre><code class="JS">function test() {
    foo(); // TypeError &quot;foo is not a function&quot;
    bar(); // &quot;this will run!&quot;
    var foo = function () { // function expression assigned to local variable &#39;foo&#39;
        alert(&quot;this won&#39;t run!&quot;);
    }
    function bar() { // function declaration, given the name &#39;bar&#39;
        alert(&quot;this will run!&quot;);
    }
}
test();
</code></pre>
<p>实际上等价于:</p>
<pre><code class="JS">function test() {
    var foo;
    var bar;
    bar = function () { // function declaration, given the name &#39;bar&#39;
        alert(&quot;this will run!&quot;);
    }

    foo(); // TypeError &quot;foo is not a function&quot;
    bar(); // &quot;this will run!&quot;

    foo = function () { // function expression assigned to local variable &#39;foo&#39;
        alert(&quot;this won&#39;t run!&quot;);
    }
}
test();
</code></pre>
<p>主要注意的地方：带有命名的函数变量式声明，是不会提升到作用域范围内的，比如:</p>
<pre><code class="JS">var baz = function spam() {};
baz(); // vaild
spam(); // ReferenceError &quot;spam is not defined&quot;
</code></pre>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[头条广告]]></title>
      <url>/2019/03/21/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%A4%B4%E6%9D%A1%E5%B9%BF%E5%91%8A/</url>
      <content type="html"><![CDATA[<h2 id="tcp-三次握手与四次挥手"><a href="#tcp-三次握手与四次挥手" class="headerlink" title="tcp 三次握手与四次挥手"></a>tcp 三次握手与四次挥手</h2><p>挥手时不是立即断开，而是等待两个ttl</p>
<h2 id="css里的box-sizing概念"><a href="#css里的box-sizing概念" class="headerlink" title="css里的box-sizing概念"></a>css里的box-sizing概念</h2><h2 id="html-语义化"><a href="#html-语义化" class="headerlink" title="html 语义化"></a>html 语义化</h2><h2 id="js-中的微任务与宏任务"><a href="#js-中的微任务与宏任务" class="headerlink" title="js 中的微任务与宏任务"></a>js 中的微任务与宏任务</h2><h2 id="js-小数的存储以及处理"><a href="#js-小数的存储以及处理" class="headerlink" title="js 小数的存储以及处理"></a>js 小数的存储以及处理</h2>]]></content>
      
        <categories>
            
            <category> 面试题 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Iterator 和 for...of 循环]]></title>
      <url>/2019/03/20/ECMAScript6/Iterator%20%E5%92%8C%20for...of%20%E5%BE%AA%E7%8E%AF/</url>
      <content type="html"><![CDATA[<h2 id="Iterator-和-for…of-循环"><a href="#Iterator-和-for…of-循环" class="headerlink" title="Iterator 和 for…of 循环"></a>Iterator 和 for…of 循环</h2><h3 id="与其他遍历语法的比较"><a href="#与其他遍历语法的比较" class="headerlink" title="与其他遍历语法的比较"></a>与其他遍历语法的比较</h3><p>以数组为例，JavaScript 提供多种遍历语法。最原始的写法就是for循环。</p>
<pre><code class="JS">for (var index = 0; index &lt; myArray.length; index++) {
  console.log(myArray[index]);
}
</code></pre>
<p>这种写法比较麻烦，因此数组提供内置的forEach方法。</p>
<pre><code class="JS">myArray.forEach(function (value) {
  console.log(value);
});
</code></pre>
<p>这种写法的问题在于， <strong>无法中途跳出forEach循环，break命令或return命令都不能奏效。</strong></p>
<p>for…in循环可以遍历数组的键名。</p>
<pre><code class="JS">for (var index in myArray) {
  console.log(myArray[index]);
}
</code></pre>
<p>for…in循环有几个缺点。</p>
<ul>
<li>数组的键名是数字，但是for…in循环是以字符串作为键名“0”、“1”、“2”等等。</li>
<li>for…in循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键。</li>
<li>某些情况下，for…in循环会以任意顺序遍历键名。<br>总之，for…in循环主要是为遍历对象而设计的，不适用于遍历数组。</li>
</ul>
<p>for…of循环相比上面几种做法，有一些显著的优点。</p>
<pre><code class="JS">for (let value of myArray) {
  console.log(value);
}
</code></pre>
<ul>
<li>有着同for…in一样的简洁语法，但是没有for…in那些缺点。</li>
<li>不同于forEach方法，它可以与break、continue和return配合使用。</li>
<li>提供了遍历所有数据结构的统一操作接口。<br>下面是一个使用 break 语句，跳出for…of循环的例子。</li>
</ul>
<pre><code class="JS">for (var n of fibonacci) {
  if (n &gt; 1000)
    break;
  console.log(n);
}
</code></pre>
<p>上面的例子，会输出斐波纳契数列小于等于 1000 的项。如果当前项大于 1000，就会使用break语句跳出for…of循环。</p>
]]></content>
      
        <categories>
            
            <category> ECMAScript 6 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ECMAScript 6 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[async 函数]]></title>
      <url>/2019/03/20/ECMAScript6/async%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<h2 id="1-含义"><a href="#1-含义" class="headerlink" title="1. 含义"></a>1. 含义</h2><p>ES2017 标准引入了 async 函数，使得异步操作变得更加方便。</p>
<p>async 函数是什么？一句话，它就是 Generator 函数的语法糖。</p>
<p>前文有一个 Generator 函数，依次读取两个文件。</p>
<pre><code class="JS">const fs = require(&#39;fs&#39;);

const readFile = function (fileName) {
  return new Promise(function (resolve, reject) {
    fs.readFile(fileName, function(error, data) {
      if (error) return reject(error);
      resolve(data);
    });
  });
};

const gen = function* () {
  const f1 = yield readFile(&#39;/etc/fstab&#39;);
  const f2 = yield readFile(&#39;/etc/shells&#39;);
  console.log(f1.toString());
  console.log(f2.toString());
};
</code></pre>
<p>上面代码的函数gen可以写成async函数，就是下面这样。</p>
<pre><code class="JS">const asyncReadFile = async function () {
  const f1 = await readFile(&#39;/etc/fstab&#39;);
  const f2 = await readFile(&#39;/etc/shells&#39;);
  console.log(f1.toString());
  console.log(f2.toString());
};
</code></pre>
<p>一比较就会发现，async函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await，仅此而已。</p>
<p>async函数对 Generator 函数的改进，体现在以下四点。</p>
<p>（1）内置执行器。</p>
<p>Generator 函数的执行必须靠执行器，所以才有了co模块，而async函数自带执行器。也就是说，async函数的执行，与普通函数一模一样，只要一行。</p>
<pre><code class="JS">asyncReadFile();
</code></pre>
<p>上面的代码调用了asyncReadFile函数，然后它就会自动执行，输出最后结果。这完全不像 Generator 函数，需要调用next方法，或者用co模块，才能真正执行，得到最后结果。</p>
<p>（2）更好的语义。</p>
<p>async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。</p>
<p>（3）更广的适用性。</p>
<p>co模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）。</p>
<p>（4）返回值是 Promise。</p>
<p>async函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作。</p>
<p>进一步说，async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。</p>
<h2 id="2-基本用法"><a href="#2-基本用法" class="headerlink" title="2. 基本用法"></a>2. 基本用法</h2><p>async函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。</p>
<p>async 函数有多种使用形式。</p>
<pre><code class="JS">// 函数声明
async function foo() {}

// 函数表达式
const foo = async function () {};

// 对象的方法
let obj = { async foo() {} };
obj.foo().then(...)

// Class 的方法
class Storage {
  constructor() {
    this.cachePromise = caches.open(&#39;avatars&#39;);
  }

  async getAvatar(name) {
    const cache = await this.cachePromise;
    return cache.match(`/avatars/${name}.jpg`);
  }
}

const storage = new Storage();
storage.getAvatar(&#39;jake&#39;).then(…);

// 箭头函数
const foo = async () =&gt; {};
</code></pre>
<h3 id="3-语法"><a href="#3-语法" class="headerlink" title="3. 语法"></a>3. 语法</h3><p>async函数的语法规则总体上比较简单，难点是错误处理机制。</p>
<h4 id="返回-Promise-对象"><a href="#返回-Promise-对象" class="headerlink" title="返回 Promise 对象"></a>返回 Promise 对象</h4><p>async函数返回一个 Promise 对象。</p>
<p>async函数内部return语句返回的值，会成为then方法回调函数的参数。</p>
<pre><code class="JS">async function f() {
  return &#39;hello world&#39;;
}

f().then(v =&gt; console.log(v))
// &quot;hello world&quot;
</code></pre>
<p>上面代码中，函数f内部return命令返回的值，会被then方法回调函数接收到。</p>
<p>async函数内部抛出错误，会导致返回的 Promise 对象变为reject状态。抛出的错误对象会被catch方法回调函数接收到。</p>
<pre><code class="JS">async function f() {
  throw new Error(&#39;出错了&#39;);
}

f().then(
  v =&gt; console.log(v),
  e =&gt; console.log(e)
)
// Error: 出错了
</code></pre>
<h3 id="Promise-对象的状态变化"><a href="#Promise-对象的状态变化" class="headerlink" title="Promise 对象的状态变化"></a>Promise 对象的状态变化</h3><p>async函数返回的 Promise 对象，必须等到内部所有await命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到return语句或者抛出错误。也就是说，只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数。</p>
<p>下面是一个例子。</p>
<pre><code class="JS">async function getTitle(url) {
  let response = await fetch(url);
  let html = await response.text();
  return html.match(/&lt;title&gt;([\s\S]+)&lt;\/title&gt;/i)[1];
}
getTitle(&#39;https://tc39.github.io/ecma262/&#39;).then(console.log)
// &quot;ECMAScript 2017 Language Specification&quot;
</code></pre>
<p>上面代码中，函数getTitle内部有三个操作：抓取网页、取出文本、匹配页面标题。只有这三个操作全部完成，才会执行then方法里面的console.log。</p>
<h3 id="await命令"><a href="#await命令" class="headerlink" title="await命令"></a>await命令</h3><p>await命令后面的 Promise 对象如果变为reject状态，则reject的参数会被catch方法的回调函数接收到。</p>
<pre><code class="JS">async function f() {
  await Promise.reject(&#39;出错了&#39;);
}

f()
.then(v =&gt; console.log(v))
.catch(e =&gt; console.log(e))
// 出错了
</code></pre>
<p><strong>注意，上面代码中，await语句前面没有return，但是reject方法的参数依然传入了catch方法的回调函数。这里如果在await前面加上return，效果是一样的。</strong></p>
<p><strong>任何一个await语句后面的 Promise 对象变为reject状态，那么整个async函数都会中断执行。</strong></p>
<pre><code class="JS">async function f() {
  await Promise.reject(&#39;出错了&#39;);
  await Promise.resolve(&#39;hello world&#39;); // 不会执行
}
</code></pre>
<p>上面代码中，第二个await语句是不会执行的，因为第一个await语句状态变成了reject。</p>
<p>有时，我们希望即使前一个异步操作失败，也不要中断后面的异步操作。这时可以将第一个await放在try…catch结构里面，这样不管这个异步操作是否成功，第二个await都会执行。</p>
<pre><code class="JS">async function f() {
  try {
    await Promise.reject(&#39;出错了&#39;);
  } catch(e) {
  }
  return await Promise.resolve(&#39;hello world&#39;);
}

f()
.then(v =&gt; console.log(v))
// hello world
</code></pre>
<p>另一种方法是await后面的 Promise 对象再跟一个catch方法，处理前面可能出现的错误。</p>
<pre><code class="JS">async function f() {
  await Promise.reject(&#39;出错了&#39;)
    .catch(e =&gt; console.log(e));
  return await Promise.resolve(&#39;hello world&#39;);
}

f()
.then(v =&gt; console.log(v))
// 出错了
// hello world
</code></pre>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>如果await后面的异步操作出错，那么等同于async函数返回的 Promise 对象被reject。</p>
<pre><code class="JS">async function f() {
  await new Promise(function (resolve, reject) {
    throw new Error(&#39;出错了&#39;);
  });
}

f()
.then(v =&gt; console.log(v))
.catch(e =&gt; console.log(e))
// Error：出错了
</code></pre>
<p>上面代码中，async函数f执行后，await后面的 Promise 对象会抛出一个错误对象，导致catch方法的回调函数被调用，它的参数就是抛出的错误对象。具体的执行机制，可以参考后文的“async 函数的实现原理”。</p>
<p>防止出错的方法，也是将其放在try…catch代码块之中。</p>
<pre><code class="JS">async function f() {
  try {
    await new Promise(function (resolve, reject) {
      throw new Error(&#39;出错了&#39;);
    });
  } catch(e) {
  }
  return await(&#39;hello world&#39;);
}
</code></pre>
<p>如果有多个await命令，可以统一放在try…catch结构中。</p>
<pre><code class="JS">async function main() {
  try {
    const val1 = await firstStep();
    const val2 = await secondStep(val1);
    const val3 = await thirdStep(val1, val2);

    console.log(&#39;Final: &#39;, val3);
  }
  catch (err) {
    console.error(err);
  }
}
</code></pre>
<p>下面的例子使用try…catch结构，实现多次重复尝试。</p>
<pre><code class="JS">const superagent = require(&#39;superagent&#39;);
const NUM_RETRIES = 3;

async function test() {
  let i;
  for (i = 0; i &lt; NUM_RETRIES; ++i) {
    try {
      await superagent.get(&#39;http://google.com/this-throws-an-error&#39;);
      break;
    } catch(err) {}
  }
  console.log(i); // 3
}

test();
</code></pre>
<p>上面代码中，如果await操作成功，就会使用break语句退出循环；如果失败，会被catch语句捕捉，然后进入下一轮循环。</p>
<h3 id="使用注意点"><a href="#使用注意点" class="headerlink" title="使用注意点"></a>使用注意点</h3><p>第一点，前面已经说过，await命令后面的Promise对象，运行结果可能是rejected，所以最好把await命令放在try…catch代码块中。</p>
<pre><code class="JS">async function myFunction() {
  try {
    await somethingThatReturnsAPromise();
  } catch (err) {
    console.log(err);
  }
}

// 另一种写法

async function myFunction() {
  await somethingThatReturnsAPromise()
  .catch(function (err) {
    console.log(err);
  });
}
</code></pre>
<p>第二点，多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。</p>
<pre><code class="JS">let foo = await getFoo();
let bar = await getBar();
</code></pre>
<p>上面代码中，getFoo和getBar是两个独立的异步操作（即互不依赖），被写成继发关系。这样比较耗时，因为只有getFoo完成以后，才会执行getBar，完全可以让它们同时触发。</p>
<pre><code class="JS">// 写法一
let [foo, bar] = await Promise.all([getFoo(), getBar()]);

// 写法二
let fooPromise = getFoo();
let barPromise = getBar();
let foo = await fooPromise;
let bar = await barPromise;
</code></pre>
<p>上面两种写法，getFoo和getBar都是同时触发，这样就会缩短程序的执行时间。</p>
<p>第三点，await命令只能用在async函数之中，如果用在普通函数，就会报错。</p>
<pre><code class="JS">async function dbFuc(db) {
  let docs = [{}, {}, {}];

  // 报错
  docs.forEach(function (doc) {
    await db.post(doc);
  });
}
</code></pre>
<p>上面代码会报错，因为await用在普通函数之中了。但是，如果将forEach方法的参数改成async函数，也有问题。</p>
<pre><code class="JS">function dbFuc(db) { //这里不需要 async
  let docs = [{}, {}, {}];

  // 可能得到错误结果
  docs.forEach(async function (doc) {
    await db.post(doc);
  });
}
</code></pre>
<p>上面代码可能不会正常工作，原因是这时三个db.post操作将是并发执行，也就是同时执行，而不是继发执行。正确的写法是采用for循环。</p>
<pre><code class="JS">async function dbFuc(db) {
  let docs = [{}, {}, {}];

  for (let doc of docs) {
    await db.post(doc);
  }
}
</code></pre>
<p>如果确实希望多个请求并发执行，可以使用Promise.all方法。当三个请求都会resolved时，下面两种写法效果相同。</p>
<pre><code class="JS">async function dbFuc(db) {
  let docs = [{}, {}, {}];
  let promises = docs.map((doc) =&gt; db.post(doc));

  let results = await Promise.all(promises);
  console.log(results);
}

// 或者使用下面的写法

async function dbFuc(db) {
  let docs = [{}, {}, {}];
  let promises = docs.map((doc) =&gt; db.post(doc));

  let results = [];
  for (let promise of promises) {
    results.push(await promise);
  }
  console.log(results);
}
</code></pre>
<p>第四点，async 函数可以保留运行堆栈。</p>
<pre><code class="JS">const a = () =&gt; {
  b().then(() =&gt; c());
};
</code></pre>
<p>上面代码中，函数a内部运行了一个异步任务b()。当b()运行的时候，函数a()不会中断，而是继续执行。等到b()运行结束，可能a()早就运行结束了，b()所在的上下文环境已经消失了。如果b()或c()报错，错误堆栈将不包括a()。</p>
<p>现在将这个例子改成async函数。</p>
<pre><code class="JS">const a = async () =&gt; {
  await b();
  c();
};
</code></pre>
<p>上面代码中，b()运行的时候，a()是暂停执行，上下文环境都保存着。一旦b()或c()报错，错误堆栈将包括a()。</p>
<h2 id="5-与其他异步处理方法的比较"><a href="#5-与其他异步处理方法的比较" class="headerlink" title="5. 与其他异步处理方法的比较"></a>5. 与其他异步处理方法的比较</h2><p>我们通过一个例子，来看 async 函数与 Promise、Generator 函数的比较。</p>
<p>假定某个 DOM 元素上面，部署了一系列的动画，前一个动画结束，才能开始后一个。如果当中有一个动画出错，就不再往下执行，返回上一个成功执行的动画的返回值。</p>
<p>首先是 Promise 的写法。</p>
<pre><code class="JS">function chainAnimationsPromise(elem, animations) {

  // 变量ret用来保存上一个动画的返回值
  let ret = null;

  // 新建一个空的Promise
  let p = Promise.resolve();

  // 使用then方法，添加所有动画
  for(let anim of animations) {
    p = p.then(function(val) {
      ret = val;
      return anim(elem);
    });
  }

  // 返回一个部署了错误捕捉机制的Promise
  return p.catch(function(e) {
    /* 忽略错误，继续执行 */
  }).then(function() {
    return ret;
  });

}
</code></pre>
<p>虽然 Promise 的写法比回调函数的写法大大改进，但是一眼看上去，代码完全都是 Promise 的 API（then、catch等等），操作本身的语义反而不容易看出来。</p>
<p>接着是 Generator 函数的写法。</p>
<pre><code class="JS">function chainAnimationsGenerator(elem, animations) {

  return spawn(function*() {
    let ret = null;
    try {
      for(let anim of animations) {
        ret = yield anim(elem);
      }
    } catch(e) {
      /* 忽略错误，继续执行 */
    }
    return ret;
  });

}
</code></pre>
<p>上面代码使用 Generator 函数遍历了每个动画，语义比 Promise 写法更清晰，用户定义的操作全部都出现在spawn函数的内部。这个写法的问题在于，必须有一个任务运行器，自动执行 Generator 函数，上面代码的spawn函数就是自动执行器，它返回一个 Promise 对象，而且必须保证yield语句后面的表达式，必须返回一个 Promise。</p>
<p>最后是 async 函数的写法。</p>
<pre><code class="JS">async function chainAnimationsAsync(elem, animations) {
  let ret = null;
  try {
    for(let anim of animations) {
      ret = await anim(elem);
    }
  } catch(e) {
    /* 忽略错误，继续执行 */
  }
  return ret;
}
</code></pre>
<p>可以看到 Async 函数的实现最简洁，最符合语义，几乎没有语义不相关的代码。它将 Generator 写法中的自动执行器，改在语言层面提供，不暴露给用户，因此代码量最少。如果使用 Generator 写法，自动执行器需要用户自己提供。</p>
<h2 id="6-实例：按顺序完成异步操作"><a href="#6-实例：按顺序完成异步操作" class="headerlink" title="6. 实例：按顺序完成异步操作"></a>6. 实例：按顺序完成异步操作</h2><p>实际开发中，经常遇到一组异步操作，需要按照顺序完成。比如，依次远程读取一组 URL，然后按照读取的顺序输出结果。</p>
<p>Promise 的写法如下。</p>
<pre><code class="JS">function logInOrder(urls) {
  // 远程读取所有URL
  const textPromises = urls.map(url =&gt; {
    return fetch(url).then(response =&gt; response.text());
  });

  // 按次序输出
  textPromises.reduce((chain, textPromise) =&gt; {
    return chain.then(() =&gt; textPromise)
      .then(text =&gt; console.log(text));
  }, Promise.resolve());
}
</code></pre>
<p>上面代码使用fetch方法，同时远程读取一组 URL。每个fetch操作都返回一个 Promise 对象，放入textPromises数组。然后，reduce方法依次处理每个 Promise 对象，然后使用then，将所有 Promise 对象连起来，因此就可以依次输出结果。</p>
<p>这种写法不太直观，可读性比较差。下面是 async 函数实现。</p>
<pre><code class="JS">async function logInOrder(urls) {
  for (const url of urls) {
    const response = await fetch(url);
    console.log(await response.text());
  }
}
</code></pre>
<p>上面代码确实大大简化，问题是所有远程操作都是继发。只有前一个 URL 返回结果，才会去读取下一个 URL，这样做效率很差，非常浪费时间。我们需要的是并发发出远程请求。</p>
<pre><code class="JS">async function logInOrder(urls) {
  // 并发读取远程URL
  const textPromises = urls.map(async url =&gt; {
    const response = await fetch(url);
    return response.text();
  });

  // 按次序输出
  for (const textPromise of textPromises) {
    console.log(await textPromise);
  }
}
</code></pre>
<p>上面代码中， <strong>虽然map方法的参数是async函数，但它是并发执行的，因为只有async函数内部是继发执行，外部不受影响。后面的for..of循环内部使用了await，因此实现了按顺序输出。</strong></p>
]]></content>
      
        <categories>
            
            <category> ECMAScript 6 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ECMAScript 6 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript 中的事件绑定]]></title>
      <url>/2019/03/20/JavaScript/JavaScript%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A/</url>
      <content type="html"><![CDATA[<h2 id="1-监听函数"><a href="#1-监听函数" class="headerlink" title="1. 监听函数"></a>1. 监听函数</h2><p>浏览器的事件模型，就是通过监听函数（listener）对事件做出反应。事件发生后，浏览器监听到了这个事件，就会执行对应的监听函数。这是事件驱动编程模式（event-driven）的主要编程方式。</p>
<p>JavaScript 有三种方法，可以为事件绑定监听函数。</p>
<h3 id="1-1-HTML-的-on-属性"><a href="#1-1-HTML-的-on-属性" class="headerlink" title="1.1. HTML 的 on- 属性"></a>1.1. HTML 的 on- 属性</h3><p>HTML 语言允许在元素的属性中，直接定义某些事件的监听代码。</p>
<pre><code class="html">&lt;body onload=&quot;doSomething()&quot;&gt;
&lt;div onclick=&quot;console.log(&#39;触发事件&#39;)&quot;&gt;
</code></pre>
<p>上面代码为body节点的load事件、div节点的click事件，指定了监听代码。一旦事件发生，就会执行这段代码。</p>
<p>元素的事件监听属性，都是on加上事件名，比如onload就是on + load，表示load事件的监听代码。</p>
<p>注意，这些属性的值是将会执行的代码，而不是一个函数。</p>
<pre><code class="html">&lt;!-- 正确 --&gt;
&lt;body onload=&quot;doSomething()&quot;&gt;

&lt;!-- 错误 --&gt;
&lt;body onload=&quot;doSomething&quot;&gt;
</code></pre>
<p>一旦指定的事件发生，on-属性的值是原样传入 JavaScript 引擎执行。因此如果要执行函数，不要忘记加上一对圆括号。</p>
<p><strong>使用这个方法指定的监听代码，只会在冒泡阶段触发。</strong></p>
<pre><code class="html">&lt;div onClick=&quot;console.log(2)&quot;&gt;
  &lt;button onClick=&quot;console.log(1)&quot;&gt;点击&lt;/button&gt;
&lt;/div&gt;
</code></pre>
<p>上面代码中，&lt;button&gt;是&lt;div&gt;的子元素。&lt;button&gt;的click事件，也会触发&lt;div&gt;的click事件。由于on-属性的监听代码，只在冒泡阶段触发，所以点击结果是先输出1，再输出2，即事件从子元素开始冒泡到父元素。</p>
<p>直接设置on-属性，与通过元素节点的setAttribute方法设置on-属性，效果是一样的。</p>
<pre><code class="JS">el.setAttribute(&#39;onclick&#39;, &#39;doSomething()&#39;);
// 等同于
// &lt;Element onclick=&quot;doSomething()&quot;&gt;
</code></pre>
<h3 id="1-2-元素节点的事件属性"><a href="#1-2-元素节点的事件属性" class="headerlink" title="1.2. 元素节点的事件属性"></a>1.2. 元素节点的事件属性</h3><p>元素节点对象的事件属性，同样可以指定监听函数。</p>
<pre><code class="JS">window.onload = doSomething;

div.onclick = function (event) {
  console.log(&#39;触发事件&#39;);
};
</code></pre>
<p>使用这个方法指定的监听函数，也是只会在冒泡阶段触发。</p>
<p><strong>注意，这种方法与 HTML 的on-属性的差异是，它的值是函数名（doSomething），而不像后者，必须给出完整的监听代码（doSomething()）。</strong></p>
<h3 id="1-3-EventTarget-addEventListener"><a href="#1-3-EventTarget-addEventListener" class="headerlink" title="1.3. EventTarget.addEventListener()"></a>1.3. EventTarget.addEventListener()</h3><p>所有 DOM 节点实例都有addEventListener方法，用来为该节点定义事件的监听函数。</p>
<pre><code class="JS">window.addEventListener(&#39;load&#39;, doSomething, false);
</code></pre>
<p>addEventListener方法的详细介绍，参见EventTarget章节。</p>
<h3 id="1-4-小结"><a href="#1-4-小结" class="headerlink" title="1.4. 小结"></a>1.4. 小结</h3><p>上面三种方法，第一种“HTML 的 on- 属性”，违反了 HTML 与 JavaScript 代码相分离的原则，将两者写在一起，不利于代码分工，因此不推荐使用。</p>
<p>第二种“元素节点的事件属性”的缺点在于， <strong>同一个事件只能定义一个监听函数</strong> ，也就是说，如果定义两次onclick属性，后一次定义会覆盖前一次。因此，也不推荐使用。</p>
<p>第三种EventTarget.addEventListener是推荐的指定监听函数的方法。它有如下优点：</p>
<ul>
<li>同一个事件可以添加多个监听函数。  </li>
<li>能够指定在哪个阶段（捕获阶段还是冒泡阶段）触发监听函数。  </li>
<li>除了 DOM 节点，其他对象（比如window、XMLHttpRequest等）也有这个接口，它等于是整个 JavaScript 统一的监听函数接口。</li>
</ul>
<h2 id="2-事件的传播"><a href="#2-事件的传播" class="headerlink" title="2. 事件的传播"></a>2. 事件的传播</h2><p>一个事件发生后，会在子元素和父元素之间传播（propagation）。这种传播分成三个阶段。</p>
<p>第一阶段：从window对象传导到目标节点（上层传到底层），称为“捕获阶段”（capture phase）。 </p>
<p>第二阶段：在目标节点上触发，称为“目标阶段”（target phase）。</p>
<p>第三阶段：从目标节点传导回window对象（从底层传回上层），称为“冒泡阶段”（bubbling phase）。<br>这种三阶段的传播模型，使得同一个事件会在多个节点上触发。</p>
<pre><code class="html">&lt;div&gt;
  &lt;p&gt;点击&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<p>上面代码中，&lt;div&gt;节点之中有一个&lt;p&gt;节点。</p>
<p>如果对这两个节点，都设置click事件的监听函数（每个节点的捕获阶段和监听阶段，各设置一个监听函数），共计设置四个监听函数。然后，对&lt;p&gt;点击，click事件会触发四次。</p>
<pre><code class="js">var phases = {
  1: &#39;capture&#39;,
  2: &#39;target&#39;,
  3: &#39;bubble&#39;
};

var div = document.querySelector(&#39;div&#39;);
var p = document.querySelector(&#39;p&#39;);

div.addEventListener(&#39;click&#39;, callback, true);
p.addEventListener(&#39;click&#39;, callback, true);
div.addEventListener(&#39;click&#39;, callback, false);
p.addEventListener(&#39;click&#39;, callback, false);

function callback(event) {
  var tag = event.currentTarget.tagName;
  var phase = phases[event.eventPhase];
  console.log(&quot;Tag: &#39;&quot; + tag + &quot;&#39;. EventPhase: &#39;&quot; + phase + &quot;&#39;&quot;);
}

// 点击以后的结果
// Tag: &#39;DIV&#39;. EventPhase: &#39;capture&#39;
// Tag: &#39;P&#39;. EventPhase: &#39;target&#39;
// Tag: &#39;P&#39;. EventPhase: &#39;target&#39;
// Tag: &#39;DIV&#39;. EventPhase: &#39;bubble&#39;
</code></pre>
<p>上面代码表示，click事件被触发了四次：&lt;div&gt;节点的捕获阶段和冒泡阶段各1次，&lt;p&gt;节点的目标阶段触发了2次。</p>
<p>捕获阶段：事件从&lt;div&gt;向&lt;p&gt;传播时，触发&lt;div&gt;的click事件；<br>目标阶段：事件从&lt;div&gt;到达&lt;p&gt;时，触发&lt;p&gt;的click事件；<br>冒泡阶段：事件从&lt;p&gt;传回&lt;div&gt;时，再次触发&lt;div&gt;的click事件。<br>其中，&lt;p&gt;节点有两个监听函数（addEventListener方法第三个参数的不同，会导致绑定两个监听函数），因此它们都会因为click事件触发一次。所以，&lt;p&gt;会在target阶段有两次输出。</p>
<p>注意，浏览器总是假定click事件的目标节点，就是点击位置嵌套最深的那个节点（本例是&lt;div&gt;节点里面的&lt;p&gt;节点）。所以，&lt;p&gt;节点的捕获阶段和冒泡阶段，都会显示为target阶段。</p>
<p>事件传播的最上层对象是window，接着依次是document，html（document.documentElement）和body（document.body）。也就是说，上例的事件传播顺序，在捕获阶段依次为window、document、html、body、div、p，在冒泡阶段依次为p、div、body、html、document、window。</p>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[网易有道]]></title>
      <url>/2019/03/19/%E9%9D%A2%E8%AF%95%E9%A2%98/%E7%BD%91%E6%98%93%E6%9C%89%E9%81%93/</url>
      <content type="html"><![CDATA[<h2 id="bind-函数的实现"><a href="#bind-函数的实现" class="headerlink" title="bind()函数的实现"></a>bind()函数的实现</h2><pre><code class="JS">Function.prototype.bind = function(context){
    var self = this;

    return function(){
    return self.apply(context, arguments);
    };
}
</code></pre>
<p>通常老版本的浏览器不支持bind()方法，这时就需要用到下面的方法重构：</p>
<pre><code class="JS">Function.prototype.bind = Function.prototype.bind || function(context){
    var self = this;

    return function(){
    return self.apply(context, arguments);
    };
}
</code></pre>
<h2 id="在Promise之前有哪些异步编程方法"><a href="#在Promise之前有哪些异步编程方法" class="headerlink" title="在Promise之前有哪些异步编程方法"></a>在Promise之前有哪些异步编程方法</h2><p>回调函数、事件监听、发布订阅</p>
<h2 id="cookie是放在请求头还是请求体里"><a href="#cookie是放在请求头还是请求体里" class="headerlink" title="cookie是放在请求头还是请求体里"></a>cookie是放在请求头还是请求体里</h2><p>请求头</p>
<h2 id="请求头里关于缓存的字段"><a href="#请求头里关于缓存的字段" class="headerlink" title="请求头里关于缓存的字段"></a>请求头里关于缓存的字段</h2><h2 id="react-rooter如何保证刷新部分组件，而不改变页面"><a href="#react-rooter如何保证刷新部分组件，而不改变页面" class="headerlink" title="react-rooter如何保证刷新部分组件，而不改变页面"></a>react-rooter如何保证刷新部分组件，而不改变页面</h2><p><a href="http://react-guide.github.io/react-router-cn/index.html" target="_blank" rel="external">http://react-guide.github.io/react-router-cn/index.html</a></p>
]]></content>
      
        <categories>
            
            <category> 面试题 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Web 优化]]></title>
      <url>/2019/03/18/%E5%89%8D%E7%AB%AF/Web%20%E4%BC%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<h2 id="1-JavaScript-压缩和模块打包"><a href="#1-JavaScript-压缩和模块打包" class="headerlink" title="1. JavaScript 压缩和模块打包"></a>1. JavaScript 压缩和模块打包</h2><p>JavaScript 应用是以源码形式进行分发的，而源码解析的效率是要比字节码低的。</p>
<p>另一方面，模块打包则用于将不同脚本打包在一起并放进同一文件。 <strong>更少的 HTTP 请求</strong> 和 <strong>单个文件解析</strong> 都可以减少加载时间。</p>
<p>也可以使用 Webpack 打包 CSS 文件以及合并图片。</p>
<h2 id="2-按需加载资源"><a href="#2-按需加载资源" class="headerlink" title="2. 按需加载资源"></a>2. 按需加载资源</h2><p>资源（特别是图片）的按需加载或者说惰性加载，可以有助于你的 Web 应用在整体上获得更好的性能。对于使用大量图片的页面来说惰性加载有着显著的三个好处：</p>
<ul>
<li>减少向服务器发出的并发请求数量（这就使得页面的其他部分获得更快的加载时间）</li>
<li>减少浏览器的内存使用率（更少的图片，更少的内存）</li>
<li>减少服务器端的负载</li>
</ul>
<p>一个非常好的实践范例就像 Goggle Images 的搜索工具一样。点击前面的链接并且滑动页面滚动条就可以看到效果了。</p>
<h2 id="3-在使用-DOM-操作库时用上-array-ids"><a href="#3-在使用-DOM-操作库时用上-array-ids" class="headerlink" title="3. 在使用 DOM 操作库时用上 array-ids"></a>3. 在使用 DOM 操作库时用上 array-ids</h2><p>此特性背后的主要概念就是尽可能多地重用已有的节点。Array ids 使得 DOM 操作引擎可以「知道」在什么时候某个节点可以被映射到数组当中的某个元素。没有 array-ids 或者 track-by 的话，大部分库都会进行重新排序而摧毁已有的节点并重新创建新的。这就非常损耗性能了。</p>
<h2 id="4-缓存"><a href="#4-缓存" class="headerlink" title="4. 缓存"></a>4. 缓存</h2><h2 id="5-启用-HTTP-2"><a href="#5-启用-HTTP-2" class="headerlink" title="5. 启用 HTTP/2"></a>5. 启用 HTTP/2</h2><h2 id="6-使用负载均衡方案"><a href="#6-使用负载均衡方案" class="headerlink" title="6. 使用负载均衡方案"></a>6. 使用负载均衡方案</h2><p>我们在之前讨论缓存的时候简要提到了内容分发网络（CDNs）。把负载分配到不同的服务器（甚至于不同的地理区域）可以给你的用户提供更好的延迟时间。</p>
<h2 id="7-服务器端渲染"><a href="#7-服务器端渲染" class="headerlink" title="7. 服务器端渲染"></a>7. 服务器端渲染</h2><p>将尽可能多的计算放在服务器端执行。</p>
<hr>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ol>
<li>PC优化手段在Mobile侧同样适用</li>
<li>在Mobile侧我们提出三秒种渲染完成首屏指标</li>
<li>基于第二点，首屏加载3秒完成或使用Loading</li>
<li>基于联通3G网络平均338KB/s(2.71Mb/s)，所以首屏资源不应超过1014KB</li>
<li>Mobile侧因手机配置原因，除加载外渲染速度也是优化重点</li>
<li>基于第五点，要合理处理代码减少渲染损耗</li>
<li>基于第二、第五点，所有影响首屏加载和渲染的代码应在处理逻辑中后置</li>
<li>加载完成后用户交互使用时也需注意性能</li>
</ol>
<h2 id="加载优化"><a href="#加载优化" class="headerlink" title="加载优化"></a>加载优化</h2><p>加载过程是最为耗时的过程，可能会占到总耗时的80%时间，因此是优化的重点</p>
<h3 id="减少HTTP请求"><a href="#减少HTTP请求" class="headerlink" title="减少HTTP请求"></a>减少HTTP请求</h3><p>因为手机浏览器同时响应请求为4个请求（Android支持4个，iOS 5后可支持6个），所以要尽量减少页面的请求数，首次加载同时请求数不能超过4个。</p>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>使用缓存可以减少向服务器的请求数，节省加载时间，所以所有静态资源都要在服务器端设置缓存，并且尽量使用长Cache（长Cache资源的更新可使用时间戳）</p>
<ul>
<li>缓存一切可缓存的资源</li>
<li>使用长Cache（使用时间戳更新Cache）</li>
<li>使用外联式引用CSS、JavaScript</li>
</ul>
<h3 id="压缩HTML、CSS、JavaScript"><a href="#压缩HTML、CSS、JavaScript" class="headerlink" title="压缩HTML、CSS、JavaScript"></a>压缩HTML、CSS、JavaScript</h3><p>减少资源大小可以加快网页显示速度，所以要对HTML、CSS、JavaScript等进行代码压缩，并在服务器端设置GZip</p>
<ul>
<li>压缩（例如，多余的空格、换行符和缩进）</li>
<li>启用GZip</li>
</ul>
<h3 id="无阻塞"><a href="#无阻塞" class="headerlink" title="无阻塞"></a>无阻塞</h3><p>写在HTML头部的JavaScript（无异步），和写在HTML标签中的Style会阻塞页面的渲染，因此CSS放在页面头部并使用Link方式引入，避免在HTML标签中写Style，JavaScript放在页面尾部或使用异步方式加载</p>
<h3 id="使用首屏加载"><a href="#使用首屏加载" class="headerlink" title="使用首屏加载"></a>使用首屏加载</h3><p>首屏的快速显示，可以大大提升用户对页面速度的感知，因此应尽量针对首屏的快速显示做优化</p>
<h3 id="按需加载"><a href="#按需加载" class="headerlink" title="按需加载"></a>按需加载</h3><p>将不影响首屏的资源和当前屏幕资源不用的资源放到用户需要时才加载，可以大大提升重要资源的显示速度和降低总体流量，但按需加载会导致大量重绘，影响渲染性能。</p>
<ul>
<li>LazyLoad</li>
<li>滚屏加载</li>
<li>通过Media Query加载</li>
</ul>
<h3 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h3><p>大型重资源页面（如游戏）可使用增加Loading的方法，资源加载完成后再显示页面。但Loading时间过长，会造成用户流失 对用户行为分析，可以在当前页加载下一页资源，提升速度</p>
<ul>
<li>可感知Loading(如进入空间游戏的Loading)</li>
<li>不可感知的Loading（如提前加载下一页）</li>
</ul>
<h3 id="压缩图片"><a href="#压缩图片" class="headerlink" title="压缩图片"></a>压缩图片</h3><p>图片是最占流量的资源，因此尽量避免使用他，使用时选择最合适的格式（实现需求的前提下，以大小判断），合适的大小，然后使用智图压缩，同时在代码中用Srcset来按需显示</p>
<ul>
<li>使用智图（ <a href="http://zhitu.tencent.com/" target="_blank" rel="external">http://zhitu.tencent.com/</a> ）</li>
<li>使用其它方式代替图片(1. 使用CSS3 2. 使用SVG 3. 使用IconFont)</li>
<li>使用Srcset</li>
<li>选择合适的图片(1. webP优于JPG 2. PNG8优于GIF)<br>选择合适的大小（1. 首次加载不大于1014KB 2. 不宽于640（基于手机屏幕一般宽度））</li>
</ul>
<h3 id="减少Cookie"><a href="#减少Cookie" class="headerlink" title="减少Cookie"></a>减少Cookie</h3><p>Cookie会影响加载速度，所以静态资源域名不使用Cookie</p>
<h3 id="避免重定向"><a href="#避免重定向" class="headerlink" title="避免重定向"></a>避免重定向</h3><p>重定向会影响加载速度，所以在服务器正确设置避免重定向</p>
<h3 id="异步加载第三方资源"><a href="#异步加载第三方资源" class="headerlink" title="异步加载第三方资源"></a>异步加载第三方资源</h3><p>第三方资源不可控会影响页面的加载和显示，因此要异步加载第三方资源</p>
<h2 id="JavaScript优化"><a href="#JavaScript优化" class="headerlink" title="JavaScript优化"></a>JavaScript优化</h2><p>脚本处理不当会阻塞页面加载、渲染，因此在使用时需当注意:</p>
<ul>
<li>CSS写在头部，JavaScript写在尾部或异步</li>
<li>避免图片和iFrame等的空Src: 空Src会重新加载当前页面，影响速度和效率</li>
<li>尽量避免重设图片大小: 重设图片大小是指在页面、CSS、JavaScript等中多次重置图片大小，多次重设图片大小会引发图片的多次重绘，影响性能</li>
<li>图片尽量避免使用DataURL: DataURL图片没有使用图片的压缩算法文件会变大，并且要解码后再渲染，加载慢耗时长</li>
</ul>
<h2 id="CSS优化"><a href="#CSS优化" class="headerlink" title="CSS优化"></a>CSS优化</h2><h3 id="尽量避免写在HTML标签中写Style属性"><a href="#尽量避免写在HTML标签中写Style属性" class="headerlink" title="尽量避免写在HTML标签中写Style属性"></a>尽量避免写在HTML标签中写Style属性</h3><h3 id="避免CSS表达式"><a href="#避免CSS表达式" class="headerlink" title="避免CSS表达式"></a>避免CSS表达式</h3><p>CSS表达式的执行需跳出CSS树的渲染，因此请避免CSS表达式</p>
<h3 id="移除空的CSS规则"><a href="#移除空的CSS规则" class="headerlink" title="移除空的CSS规则"></a>移除空的CSS规则</h3><p>空的CSS规则增加了CSS文件的大小，且影响CSS树的执行，所以需移除空的CSS规则</p>
<h3 id="正确使用Display的属性"><a href="#正确使用Display的属性" class="headerlink" title="正确使用Display的属性"></a>正确使用Display的属性</h3><p>Display属性会影响页面的渲染，因此请合理使用:</p>
<p>a) display:inline后不应该再使用width、height、margin、padding以及float b) display:inline-block后不应该再使用float c) display:block后不应该再使用vertical-align d) display:table-*后不应该再使用margin或者float</p>
<h3 id="不滥用Float"><a href="#不滥用Float" class="headerlink" title="不滥用Float"></a>不滥用Float</h3><p>Float在渲染时计算量比较大，尽量减少使用</p>
<h3 id="不滥用Web字体"><a href="#不滥用Web字体" class="headerlink" title="不滥用Web字体"></a>不滥用Web字体</h3><p>Web字体需要下载，解析，重绘当前页面，尽量减少使用</p>
<h3 id="不声明过多的Font-size"><a href="#不声明过多的Font-size" class="headerlink" title="不声明过多的Font-size"></a>不声明过多的Font-size</h3><p>过多的Font-size引发CSS树的效率</p>
<h3 id="值为0时不需要任何单位"><a href="#值为0时不需要任何单位" class="headerlink" title="值为0时不需要任何单位"></a>值为0时不需要任何单位</h3><p>为了浏览器的兼容性和性能，值为0时不要带单位</p>
<h3 id="标准化各种浏览器前缀"><a href="#标准化各种浏览器前缀" class="headerlink" title="标准化各种浏览器前缀"></a>标准化各种浏览器前缀</h3><ul>
<li>无前缀应放在最后</li>
<li>CSS动画只用 （-webkit- 无前缀）两种即可</li>
<li>其它前缀为 -webkit- -moz- -ms- 无前缀 四种，（-o-Opera浏览器改用blink内核，所以淘汰）<h3 id="避免让选择符看起来像正则表达式"><a href="#避免让选择符看起来像正则表达式" class="headerlink" title="避免让选择符看起来像正则表达式"></a>避免让选择符看起来像正则表达式</h3>高级选择器执行耗时长且不易读懂，避免使用</li>
</ul>
<h2 id="JavaScript执行优化"><a href="#JavaScript执行优化" class="headerlink" title="JavaScript执行优化"></a>JavaScript执行优化</h2><h3 id="减少重绘和回流"><a href="#减少重绘和回流" class="headerlink" title="减少重绘和回流"></a>减少重绘和回流</h3><ul>
<li>避免不必要的Dom操作</li>
<li>尽量改变Class而不是Style，使用classList代替className</li>
<li>避免使用document.write</li>
<li>减少drawImage</li>
</ul>
<h3 id="缓存Dom选择与计算"><a href="#缓存Dom选择与计算" class="headerlink" title="缓存Dom选择与计算"></a>缓存Dom选择与计算</h3><p>每次Dom选择都要计算，缓存它</p>
<h3 id="缓存列表-length"><a href="#缓存列表-length" class="headerlink" title="缓存列表.length"></a>缓存列表.length</h3><p>每次.length都要计算，用一个变量保存这个值</p>
<h3 id="尽量使用事件代理，避免批量绑定事件"><a href="#尽量使用事件代理，避免批量绑定事件" class="headerlink" title="尽量使用事件代理，避免批量绑定事件"></a>尽量使用事件代理，避免批量绑定事件</h3><h3 id="尽量使用ID选择器"><a href="#尽量使用ID选择器" class="headerlink" title="尽量使用ID选择器"></a>尽量使用ID选择器</h3><h3 id="TOUCH事件优化"><a href="#TOUCH事件优化" class="headerlink" title="TOUCH事件优化"></a>TOUCH事件优化</h3><p>使用touchstart、touchend代替click，因快影响速度快。但应注意Touch响应过快，易引发误操作</p>
<h2 id="渲染优化"><a href="#渲染优化" class="headerlink" title="渲染优化"></a>渲染优化</h2><h3 id="HTML使用Viewport"><a href="#HTML使用Viewport" class="headerlink" title="HTML使用Viewport"></a>HTML使用Viewport</h3><p>Viewport可以加速页面的渲染，请使用以下代码</p>
<pre><code class="html">&lt;meta name=”viewport” content=”width=device-width, initial-scale=1″&gt;
</code></pre>
<h3 id="减少Dom节点"><a href="#减少Dom节点" class="headerlink" title="减少Dom节点"></a>减少Dom节点</h3><p>Dom节点太多影响页面的渲染，应尽量减少Dom节点</p>
<h3 id="动画优化"><a href="#动画优化" class="headerlink" title="动画优化"></a>动画优化</h3><ul>
<li>尽量使用CSS3动画</li>
<li>合理使用requestAnimationFrame动画代替setTimeout</li>
<li>适当使用Canvas动画 5个元素以内使用css动画，5个以上使用Canvas动画（iOS8可使用webGL）</li>
</ul>
<h3 id="高频事件优化"><a href="#高频事件优化" class="headerlink" title="高频事件优化"></a>高频事件优化</h3><p>Touchmove、Scroll 事件可导致多次渲染</p>
<ul>
<li>使用requestAnimationFrame监听帧变化，使得在正确的时间进行渲染</li>
<li>增加响应变化的时间间隔，减少重绘次数</li>
</ul>
<h3 id="GPU加速"><a href="#GPU加速" class="headerlink" title="GPU加速"></a>GPU加速</h3><p>CSS中以下属性（CSS3 transitions、CSS3 3D transforms、Opacity、Canvas、WebGL、Video）来触发GPU渲染，请合理使用, 过渡使用会引发手机过耗电增加</p>
]]></content>
      
        <categories>
            
            <category> 前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Web 优化 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[215. 数组中的第K个最大元素（Kth Largest Element in an Array）]]></title>
      <url>/2019/03/17/LeetCode-JavaScript/215.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0%EF%BC%88Kth%20Largest%20Element%20in%20an%20Array%EF%BC%89/</url>
      <content type="html"><![CDATA[<h2 id="215-数组中的第K个最大元素（Kth-Largest-Element-in-an-Array）"><a href="#215-数组中的第K个最大元素（Kth-Largest-Element-in-an-Array）" class="headerlink" title="215. 数组中的第K个最大元素（Kth Largest Element in an Array）"></a>215. 数组中的第K个最大元素（Kth Largest Element in an Array）</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p>
<p>示例 1:</p>
<pre><code class="JS">输入: [3,2,1,5,6,4] 和 k = 2
输出: 5
</code></pre>
<p>示例 2:</p>
<pre><code class="JS">输入: [3,2,3,1,2,4,5,5,6] 和 k = 4
输出: 4
</code></pre>
<p>说明: </p>
<p>你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h4><p>类似快排 O(nlogn)</p>
<pre><code class="JS">/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var findKthLargest = function(nums, k) {
    function quickSelect(nums, l, r, k){
        let i=l, j=r;
        let mid = nums[r];

        /* 
        let temp;
        while(i&lt;j){
            while(i&lt;j &amp;&amp; nums[i]&gt;=mid) ++i;
            temp = nums[i];
            nums[i] = nums[j];
            nums[j] = temp;
            while(i&lt;j &amp;&amp; nums[j]&lt;=mid) --j;
            temp  = nums[j];
            nums[j] = nums[i];
            nums[i] = temp;
        }
        */
        //这里每次交换都会有三次赋值，而mid这个值是不需要每次都移动的，只需要最终赋值一次，所以可简写为下面的代码。

        while(i&lt;j){
            while(i&lt;j &amp;&amp; nums[i]&gt;=mid) ++i;
            nums[j] = nums[i];
            while(i&lt;j &amp;&amp; nums[j]&lt;=mid) --j;
            nums[i] = nums[j];
        }
        nums[i] = mid;


        if(i === k-1) return nums[i];
        if(i &gt; k-1) return quickSelect(nums, l, i-1, k);
        if(i &lt; k-1) return quickSelect(nums, i+1, r, k);
    }

    return quickSelect(nums, 0, nums.length-1, k);

};
</code></pre>
<h4 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h4><p>堆排序</p>
<p>取第k个最大元素，建容量为k的堆，存储最大的k个元素，使用小顶堆，可以从堆顶直接获取第k大元素。初始化时将数组前k个元素分别插入堆。</p>
<p>然后从k+1遍历数组，当元素大于堆顶元素时，移除堆顶元素，插入数组元素。时间复杂度O(n*logk)</p>
<pre><code class="JS">/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var findKthLargest = function(nums, k) {
    let heap = [];
    for(let i=0; i&lt;k; i++) insert(heap, nums[i]);
    for(let i=k; i&lt;nums.length; i++){
        if(nums[i] &gt; heap[0]){
            removeMin(heap);
            insert(heap, nums[i]);
        }
    }
    return heap[0];


    function leftIndex(index) {
        return 2*index+1;
    }
    function rightIndex(index) {
        return 2*index+2;
    }
    function parentIndex(index) {
        if(index === 0) return 0;
        return Math.floor((index-1)/2);
    }
    function insert(heap, num) {
        heap.push(num);
        upheap(heap, heap.length-1);
    }
    function upheap(heap, k) {
        let index = k, parent = parentIndex(k);
        while(heap[parent] &gt; heap[index]){
            let temp = heap[parent];
            heap[parent] = heap[index];
            heap[index] = temp;
            index = parent;
            parent = parentIndex(index);
        }
    }
    function removeMin(heap) {
        heap[0] = heap[heap.length-1];
        heap.pop();
        downheap(heap, 0);
    }
    function downheap(heap, k) {
        let smallestIndex = k, leftindex = leftIndex(k), rightindex = rightIndex(k);
        if(leftindex &lt; heap.length &amp;&amp; heap[leftindex] &lt; heap[smallestIndex]) smallestIndex = leftindex;
        if(rightindex &lt; heap.length &amp;&amp; heap[rightindex] &lt; heap[smallestIndex]) smallestIndex = rightindex;
        if(smallestIndex !== k){
            let temp = heap[k];
            heap[k] = heap[smallestIndex];
            heap[smallestIndex] = temp;
            downheap(heap, smallestIndex);
        }
    }

};
</code></pre>
]]></content>
      
        <categories>
            
            <category> LeetCode-JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Http 协议]]></title>
      <url>/2019/03/17/%E5%89%8D%E7%AB%AF/Http%20%E5%8D%8F%E8%AE%AE/</url>
      <content type="html"><![CDATA[<h2 id="HTTP简介"><a href="#HTTP简介" class="headerlink" title="HTTP简介"></a>HTTP简介</h2><p>HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。。</p>
<p>HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。</p>
<p>HTTP默认端口号为80，但是你也可以改为8080或者其他端口。</p>
<p><strong>HTTP三点注意事项：</strong></p>
<ul>
<li>HTTP是无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</li>
<li>HTTP是媒体独立的：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。</li>
<li>HTTP是无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</li>
</ul>
<h2 id="HTTP请求方法"><a href="#HTTP请求方法" class="headerlink" title="HTTP请求方法"></a>HTTP请求方法</h2><p>根据HTTP标准，HTTP请求可以使用多种请求方法。</p>
<p>HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。</p>
<p>HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。</p>
<ol>
<li>GET: 请求指定的页面信息，并返回实体主体。</li>
<li>HEAD: 类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头</li>
<li>POST: 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。</li>
<li>PUT: 从客户端向服务器传送的数据取代指定的文档的内容。</li>
<li>DELETE: 请求服务器删除指定的页面。</li>
<li>CONNECT: HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</li>
<li>OPTIONS: 允许客户端查看服务器的性能。</li>
<li>TRACE: 回显服务器收到的请求，主要用于测试或诊断。</li>
</ol>
<h2 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h2><p>下面是常见的HTTP状态码：</p>
<ul>
<li>200 - 请求成功</li>
<li>301 - 资源（网页等）被永久转移到其它URL</li>
<li>404 - 请求的资源（网页等）不存在</li>
<li>500 - 内部服务器错误  </li>
</ul>
<p><strong>HTTP状态码分类</strong> </p>
<p>HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP状态码共分为5种类型：</p>
<ul>
<li>1**　信息，服务器收到请求，需要请求者继续执行操作</li>
<li>2**　成功，操作被成功接收并处理</li>
<li>3**　重定向，需要进一步的操作以完成请求</li>
<li>4**　客户端错误，请求包含语法错误或无法完成请求</li>
<li>5**　服务器错误，服务器在处理请求的过程中发生了错误</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Http </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[144. 二叉树的前序遍历（Binary Tree Preorder Traversal）]]></title>
      <url>/2019/03/14/LeetCode-JavaScript/144.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88Binary%20Tree%20Preorder%20Traversal%EF%BC%89/</url>
      <content type="html"><![CDATA[<h2 id="144-二叉树的前序遍历（Binary-Tree-Preorder-Traversal）"><a href="#144-二叉树的前序遍历（Binary-Tree-Preorder-Traversal）" class="headerlink" title="144. 二叉树的前序遍历（Binary Tree Preorder Traversal）"></a>144. 二叉树的前序遍历（Binary Tree Preorder Traversal）</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个二叉树，返回它的 前序 遍历。</p>
<p> 示例:</p>
<pre><code>输入: [1,null,2,3]  
   1
    \
     2
    /
   3 

输出: [1,2,3]
</code></pre><p>进阶: 递归算法很简单，你可以通过迭代算法完成吗？</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h4><p>递归</p>
<pre><code class="JS">/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var preorderTraversal = function(root) {
    let result = [];
    preorder(root);
    return result;

    function preorder(node){
        if(!node) return;
        result.push(node.val);
        preorder(node.left);
        preorder(node.right);
    }
};
</code></pre>
<h4 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h4><p>迭代：栈，先让根节点入栈，然后根节点出栈，右子树入栈，左子树入栈，这样出栈顺序即为 根，左子树，右子树。</p>
<p>后序遍历同理，让根节点出栈，左子树入栈，右子树入栈，则出栈顺序为根，右子树，左子树。然后逆序，即为后序：左，右，中。</p>
<p>中序遍历另见94题。</p>
<pre><code class="JS">/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var preorderTraversal = function(root) {
    if(!root) return [];
    let stack = [];
    let result = [];
    stack.push(root)
    while(stack.length){
        let node = stack.pop();
        result.push(node.val);
        if(node.right) stack.push(node.right);
        if(node.left) stack.push(node.left);
    }
    return result;
};
</code></pre>
]]></content>
      
        <categories>
            
            <category> LeetCode-JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Module 的语法]]></title>
      <url>/2019/03/14/ECMAScript6/Module%20%E7%9A%84%E8%AF%AD%E6%B3%95/</url>
      <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的require、Python 的import，甚至就连 CSS 都有@import，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。</p>
<p>在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。</p>
<p>ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。</p>
<pre><code class="JS">// CommonJS模块
let { stat, exists, readFile } = require(&#39;fs&#39;);

// 等同于
let _fs = require(&#39;fs&#39;);
let stat = _fs.stat;
let exists = _fs.exists;
let readfile = _fs.readfile;
</code></pre>
<p><strong>上面代码的实质是整体加载fs模块（即加载fs的所有方法），生成一个对象（_fs），然后再从这个对象上面读取 3 个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。</strong></p>
<p>ES6 模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入。</p>
<pre><code class="JS">// ES6模块
import { stat, exists, readFile } from &#39;fs&#39;;
</code></pre>
<p>上面代码的实质是从fs模块加载 3 个方法，其他方法不加载。这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。当然，这也导致了没法引用 ES6 模块本身，因为它不是对象。</p>
<p>由于 ES6 模块是编译时加载，使得静态分析成为可能。有了它，就能进一步拓宽 JavaScript 的语法，比如引入宏（macro）和类型检验（type system）这些只能靠静态分析实现的功能。</p>
]]></content>
      
        <categories>
            
            <category> ECMAScript 6 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ECMAScript 6 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Generator 函数的异步应用]]></title>
      <url>/2019/03/14/ECMAScript6/Generator%20%E5%87%BD%E6%95%B0%E7%9A%84%E5%BC%82%E6%AD%A5%E5%BA%94%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>异步编程对 JavaScript 语言太重要。JavaScript 语言的执行环境是“单线程”的，如果没有异步编程，根本没法用，非卡死不可。本章主要介绍 Generator 函数如何完成异步操作。</p>
<h2 id="1-传统方法"><a href="#1-传统方法" class="headerlink" title="1. 传统方法"></a>1. 传统方法</h2><p>ES6 诞生以前，异步编程的方法，大概有下面四种。</p>
<ul>
<li>回调函数</li>
<li>事件监听</li>
<li>发布/订阅</li>
<li>Promise 对象</li>
</ul>
<h2 id="2-基本概念"><a href="#2-基本概念" class="headerlink" title="2. 基本概念"></a>2. 基本概念</h2><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>所谓”异步”，简单说就是一个任务不是连续完成的，可以理解成该任务被人为分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。</p>
<p>比如，有一个任务是读取文件进行处理，任务的第一段是向操作系统发出请求，要求读取文件。然后，程序执行其他任务，等到操作系统返回文件，再接着执行任务的第二段（处理文件）。这种不连续的执行，就叫做异步。</p>
<p>相应地，连续的执行就叫做同步。由于是连续执行，不能插入其他任务，所以操作系统从硬盘读取文件的这段时间，程序只能干等着。</p>
<h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>JavaScript 语言对异步编程的实现，就是回调函数。所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。回调函数的英语名字callback，直译过来就是”重新调用”。</p>
<p>读取文件进行处理，是这样写的。</p>
<pre><code class="JS">fs.readFile(&#39;/etc/passwd&#39;, &#39;utf-8&#39;, function (err, data) {
  if (err) throw err;
  console.log(data);
});
</code></pre>
<p>上面代码中，readFile函数的第三个参数，就是回调函数，也就是任务的第二段。等到操作系统返回了/etc/passwd这个文件以后，回调函数才会执行。</p>
<p>一个有趣的问题是，为什么 Node 约定， <strong>回调函数的第一个参数，必须是错误对象err（如果没有错误，该参数就是null）？</strong></p>
<p>原因是执行分成两段，第一段执行完以后，任务所在的上下文环境就已经结束了。在这以后抛出的错误，原来的上下文环境已经无法捕捉，只能当作参数，传入第二段。</p>
<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>回调函数本身并没有问题，它的问题出现在多个回调函数嵌套。假定读取A文件之后，再读取B文件，代码如下。</p>
<pre><code class="JS">fs.readFile(fileA, &#39;utf-8&#39;, function (err, data) {
  fs.readFile(fileB, &#39;utf-8&#39;, function (err, data) {
    // ...
  });
});
</code></pre>
<p>不难想象，如果依次读取两个以上的文件，就会出现多重嵌套。代码不是纵向发展，而是横向发展，很快就会乱成一团，无法管理。因为多个异步操作形成了强耦合，只要有一个操作需要修改，它的上层回调函数和下层回调函数，可能都要跟着修改。这种情况就称为”回调函数地狱”（callback hell）。</p>
<p>Promise 对象就是为了解决这个问题而提出的。它不是新的语法功能，而是一种新的写法，允许将回调函数的嵌套，改成链式调用。采用 Promise，连续读取多个文件，写法如下。</p>
<pre><code class="JS">var readFile = require(&#39;fs-readfile-promise&#39;);

readFile(fileA)
.then(function (data) {
  console.log(data.toString());
})
.then(function () {
  return readFile(fileB);
})
.then(function (data) {
  console.log(data.toString());
})
.catch(function (err) {
  console.log(err);
});
</code></pre>
<p>上面代码中，我使用了fs-readfile-promise模块，它的作用就是返回一个 Promise 版本的readFile函数。Promise 提供then方法加载回调函数，catch方法捕捉执行过程中抛出的错误。</p>
<p>可以看到，Promise 的写法只是回调函数的改进，使用then方法以后，异步任务的两段执行看得更清楚了，除此以外，并无新意。</p>
<p>Promise 的最大问题是代码冗余，原来的任务被 Promise 包装了一下，不管什么操作，一眼看去都是一堆then，原来的语义变得很不清楚。</p>
<p>那么，有没有更好的写法呢？</p>
<h2 id="3-Generator-函数"><a href="#3-Generator-函数" class="headerlink" title="3. Generator 函数"></a>3. Generator 函数</h2><h2 id="4-Thunk-函数"><a href="#4-Thunk-函数" class="headerlink" title="4. Thunk 函数"></a>4. Thunk 函数</h2><h2 id="5-co-模块"><a href="#5-co-模块" class="headerlink" title="5. co 模块"></a>5. co 模块</h2>]]></content>
      
        <categories>
            
            <category> ECMAScript 6 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ECMAScript 6 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[94. 二叉树的中序遍历（Binary Tree Inorder Traversal）]]></title>
      <url>/2019/03/14/LeetCode-JavaScript/94.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88Binary%20Tree%20Inorder%20Traversal%EF%BC%89/</url>
      <content type="html"><![CDATA[<h2 id="94-二叉树的中序遍历（Binary-Tree-Inorder-Traversal）"><a href="#94-二叉树的中序遍历（Binary-Tree-Inorder-Traversal）" class="headerlink" title="94. 二叉树的中序遍历（Binary Tree Inorder Traversal）"></a>94. 二叉树的中序遍历（Binary Tree Inorder Traversal）</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个二叉树，返回它的中序 遍历。</p>
<p>示例:</p>
<pre><code>输入: [1,null,2,3]
   1
    \
     2
    /
   3

输出: [1,3,2]
</code></pre><p>进阶: 递归算法很简单，你可以通过迭代算法完成吗？</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h4><p>递归</p>
<pre><code class="JS">/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var inorderTraversal = function(root) {
    let result = [];
    inorder(root);
    return result;

    function inorder(root){
        if(root === null) return;
        inorder(root.left);
        result.push(root.val);
        inorder(root.right);
    }
};
</code></pre>
<h4 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h4><p>迭代：栈</p>
<p>前序遍历是取当前节点，再取左子树，栈中存放右子树。<br>中序遍历是存放当前节点，先取左子树，取出栈中节点后再遍历右子树。</p>
<pre><code class="JS">/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var inorderTraversal = function(root) {
    if(!root) return [];
    let stack = [];
    let result = [];
    let curNode = root;
    while(curNode || stack.length){    //stack存放未求值的节点
        if(curNode){
            stack.push(curNode);
            curNode = curNode.left;
        }
        else{
            curNode = stack.pop();    //栈顶是curNode的父节点
            result.push(curNode.val);
            curNode = curNode.right;
        }
    }
    return result;
};
</code></pre>
]]></content>
      
        <categories>
            
            <category> LeetCode-JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[98. 验证二叉搜索树（Validate Binary Search Tree）]]></title>
      <url>/2019/03/13/LeetCode-JavaScript/98.%20%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%88Validate%20Binary%20Search%20Tree%EF%BC%89/</url>
      <content type="html"><![CDATA[<h2 id="98-验证二叉搜索树（Validate-Binary-Search-Tree）"><a href="#98-验证二叉搜索树（Validate-Binary-Search-Tree）" class="headerlink" title="98. 验证二叉搜索树（Validate Binary Search Tree）"></a>98. 验证二叉搜索树（Validate Binary Search Tree）</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p>
<p>假设一个二叉搜索树具有如下特征：</p>
<p>节点的左子树只包含小于当前节点的数。<br>节点的右子树只包含大于当前节点的数。<br>所有左子树和右子树自身必须也是二叉搜索树。</p>
<p>示例 1:</p>
<pre><code>输入:
    2
   / \
  1   3
输出: true
</code></pre><p>示例 2:</p>
<pre><code>输入:
    5
   / \
  1   4
     / \
    3   6
输出: false
解释: 输入为: [5,1,4,null,null,3,6]。
     根节点的值为 5 ，但是其右子节点值为 4 。
</code></pre><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>解法一<br>递归判断每个节点的值是否满足</p>
<pre><code class="JS">/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isValidBST = function(root) {
    if(!root) return true;
    return isValid(root.left, -Infinity, root.val) &amp;&amp; isValid(root.right, root.val, Infinity);

    function isValid(root, min, max){
        if(root === null) return true;
        if(root.val &gt; min &amp;&amp; root.val &lt; max){
            return isValid(root.left, min, root.val) &amp;&amp; isValid(root.right, root.val, max);
        } 
        else return false;
    }
};
</code></pre>
<p>解法二<br>中序遍历得到的节点值一定是递增的</p>
<pre><code class="JS">/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isValidBST = function(root) {
    let maxVal = -Infinity;
    return inorder(root);

    function inorder(root){
        if(!root) return true;
        if(!inorder(root.left)) return false;
        if(root.val &lt;= maxVal) return false;
        maxVal = root.val;
        if(!inorder(root.right)) return false;
        return true;
    }
};
</code></pre>
]]></content>
      
        <categories>
            
            <category> LeetCode-JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[102. 二叉树的层次遍历（ Binary Tree Level Order Traversal）]]></title>
      <url>/2019/03/13/LeetCode-JavaScript/102.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%EF%BC%88%20Binary%20Tree%20Level%20Order%20Traversal%EF%BC%89/</url>
      <content type="html"><![CDATA[<h2 id="102-二叉树的层次遍历（-Binary-Tree-Level-Order-Traversal）"><a href="#102-二叉树的层次遍历（-Binary-Tree-Level-Order-Traversal）" class="headerlink" title="102. 二叉树的层次遍历（ Binary Tree Level Order Traversal）"></a>102. 二叉树的层次遍历（ Binary Tree Level Order Traversal）</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。</p>
<p>例如:<br>给定二叉树: [3,9,20,null,null,15,7],</p>
<pre><code>    3
   / \
  9  20
    /  \
   15   7
</code></pre><p>返回其层次遍历结果：</p>
<pre><code>[
  [3],
  [9,20],
  [15,7]
]
</code></pre><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h4><p>递归：中序遍历</p>
<pre><code class="JS">/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var levelOrder = function(root) {
    let results = [];
    let level = 0;
    travel(root, 0);
    return results;

    function travel(root, n){
        if(!root) return;
        if(!results[n]) results[n] = [root.val];
        else results[n].push(root.val);
        travel(root.left, n+1);
        travel(root.right, n+1);
    }
};
</code></pre>
<h4 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h4><p>队列：依次取出每层的所有节点（shift），存储节点值，并将子树加入队列（push）</p>
<pre><code class="JS">/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var levelOrder = function(root) {
    if(!root) return [];
    let queue = [];
    let results = [];
    queue.push(root);
    while(queue.length){
        let length = queue.length;
        let curRes = [];
        for(let i=0; i&lt;length; i++){
            let node = queue.shift();
            curRes.push(node.val);
            if(node.left) queue.push(node.left);
            if(node.right) queue.push(node.right);
        }
        results.push(curRes);
    }
    return results;
};
</code></pre>
]]></content>
      
        <categories>
            
            <category> LeetCode-JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[95. 不同的二叉搜索树 II （Unique Binary Search Trees II）]]></title>
      <url>/2019/03/13/LeetCode-JavaScript/95.%20%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%20II%20%EF%BC%88Unique%20Binary%20Search%20Trees%20II%EF%BC%89/</url>
      <content type="html"><![CDATA[<h2 id="95-不同的二叉搜索树-II-（Unique-Binary-Search-Trees-II）"><a href="#95-不同的二叉搜索树-II-（Unique-Binary-Search-Trees-II）" class="headerlink" title="95. 不同的二叉搜索树 II （Unique Binary Search Trees II）"></a>95. 不同的二叉搜索树 II （Unique Binary Search Trees II）</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个整数 n，生成所有由 1 … n 为节点所组成的二叉搜索树。</p>
<p>示例:</p>
<pre><code>输入: 3
输出:
[
  [1,null,3,2],
  [3,2,null,1],
  [3,1,null,null,2],
  [2,1,3],
  [1,null,2,null,3]
]
解释:
以上的输出对应以下 5 种不同结构的二叉搜索树：

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
</code></pre><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="JS">/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {number} n
 * @return {TreeNode[]}
 */
var generateTrees = function(n) {
    let results = new Array(n+1).fill(undefined).map(()=&gt;[]);
    if(n===0) return [];
    results[0].push(null);
    for(let i=1; i&lt;n+1; i++){  //求i个节点的所有组合
        for(let j=1; j&lt;i+1; j++){  //其中第j个节点作为根节点
            results[j-1].forEach(left =&gt;{  //左子树的所有组合
                results[i-j].forEach(right =&gt;{  //右子树的所有组合
                    let root = new TreeNode(j);
                    root.left = left;
                    root.right = cloneTree(right, j);  //右子树偏移j
                    results[i].push(root);
                })

            })
        }
    }
    return results[n];


    function cloneTree(root, offset){
        if(!root) return null;
        let newRoot = new TreeNode(root.val+offset);
        newRoot.left = cloneTree(root.left, offset);
        newRoot.right = cloneTree(root.right, offset);
        return newRoot;
    }
};
</code></pre>
]]></content>
      
        <categories>
            
            <category> LeetCode-JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[96. 不同的二叉搜索树（Unique Binary Search Trees）]]></title>
      <url>/2019/03/13/LeetCode-JavaScript/96.%20%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%88Unique%20Binary%20Search%20Trees%EF%BC%89/</url>
      <content type="html"><![CDATA[<h2 id="96-不同的二叉搜索树（Unique-Binary-Search-Trees）"><a href="#96-不同的二叉搜索树（Unique-Binary-Search-Trees）" class="headerlink" title="96. 不同的二叉搜索树（Unique Binary Search Trees）"></a>96. 不同的二叉搜索树（Unique Binary Search Trees）</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？</p>
<p>示例:</p>
<pre><code>输入: 3
输出: 5
解释:
给定 n = 3, 一共有 5 种不同结构的二叉搜索树:

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
</code></pre><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><ol>
<li>迭代<pre><code class="JS">/**
* @param {number} n
* @return {number}
*/
var numTrees = function(n) {
 let results = [0, 1, 2];
 for(let i=3; i&lt;=n; i++){
     results[i] = 0;
     for(let j=2; j&lt;i; j++){  //j的范围是2到i-1,排除了只有左子树或只有右子树的情况（这两种情况不能左右子树数量相乘，是相加，需单独计算）
         results[i] += results[j-1]*results[i-j];
     }
     results[i] += results[i-1]*2;  //加上只有左子树或只有右子树的情况
 }
 return results[n];
};
</code></pre>
执行用时 : 92 ms</li>
<li>递归<pre><code class="JS">/**
* @param {number} n
* @return {number}
*/
var numTrees = function(n) {
 if(n === 0) return 0;
 if(n === 1) return 1;
 let result = 0;
 for(let i = 1; i&lt;=n; i++){
     let left = numTrees(i-1);
     let right = numTrees(n-i);
     if(left * right === 0) result = result + left + right;
     else result += left*right;
 }
 return result;
};
</code></pre>
执行用时：8136 ms</li>
</ol>
]]></content>
      
        <categories>
            
            <category> LeetCode-JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Promise 对象]]></title>
      <url>/2019/03/11/ECMAScript6/Promise%20%E5%AF%B9%E8%B1%A1/</url>
      <content type="html"><![CDATA[<h2 id="1-Promise-的含义"><a href="#1-Promise-的含义" class="headerlink" title="1. Promise 的含义"></a>1. Promise 的含义</h2><p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。</p>
<p>所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p>
<p>Promise对象有以下两个特点。</p>
<p>（1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</p>
<p>（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>ES6 规定，Promise对象是一个构造函数，用来生成Promise实例。</p>
<p>下面代码创造了一个Promise实例。</p>
<pre><code class="JS">const promise = new Promise(function(resolve, reject) {
  // ... some code

  if (/* 异步操作成功 */){
    resolve(value);
  } else {
    reject(error);
  }
});
</code></pre>
<p>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。</p>
<p>resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p>
<p>Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。</p>
<pre><code class="JS">promise.then(function(value) {
  // success
}, function(error) {
  // failure
});
</code></pre>
<p>then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。</p>
<p>下面是一个Promise对象的简单例子。</p>
<pre><code class="JS">function timeout(ms) {
  return new Promise((resolve, reject) =&gt; {
    setTimeout(resolve, ms, &#39;done&#39;);
  });
}

timeout(100).then((value) =&gt; {
  console.log(value);
});
</code></pre>
<p>上面代码中，timeout方法返回一个Promise实例，表示一段时间以后才会发生的结果。过了指定的时间（ms参数）以后，Promise实例的状态变为resolved，就会触发then方法绑定的回调函数。</p>
<p>Promise 新建后就会立即执行。</p>
<pre><code class="JS">let promise = new Promise(function(resolve, reject) {
  console.log(&#39;Promise&#39;);
  resolve();
});

promise.then(function() {
  console.log(&#39;resolved.&#39;);
});

console.log(&#39;Hi!&#39;);

// Promise
// Hi!
// resolved
</code></pre>
<p>上面代码中，Promise 新建后立即执行，所以首先输出的是Promise。然后，then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以resolved最后输出。</p>
<hr>
<p>如果调用resolve函数和reject函数时带有参数，那么它们的参数会被传递给回调函数。reject函数的参数通常是Error对象的实例，表示抛出的错误；resolve函数的参数除了正常的值以外，还可能是另一个 Promise 实例，比如像下面这样。</p>
<pre><code class="JS">const p1 = new Promise(function (resolve, reject) {
  // ...
});

const p2 = new Promise(function (resolve, reject) {
  // ...
  resolve(p1);
})
</code></pre>
<p>上面代码中，p1和p2都是 Promise 的实例，但是p2的resolve方法将p1作为参数，即一个异步操作的结果是返回另一个异步操作。</p>
<p>注意，这时p1的状态就会传递给p2，也就是说，p1的状态决定了p2的状态。如果p1的状态是pending，那么p2的回调函数就会等待p1的状态改变；如果p1的状态已经是resolved或者rejected，那么p2的回调函数将会立刻执行。</p>
<hr>
<p>注意，调用resolve或reject并不会终结 Promise 的参数函数的执行。</p>
<pre><code class="JS">new Promise((resolve, reject) =&gt; {
  resolve(1);
  console.log(2);
}).then(r =&gt; {
  console.log(r);
});
// 2
// 1
</code></pre>
<p>上面代码中，调用resolve(1)以后，后面的console.log(2)还是会执行，并且会首先打印出来。这是因为立即 resolved 的 Promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务。</p>
<p>一般来说，调用resolve或reject以后，Promise 的使命就完成了，后继操作应该放到then方法里面，而不应该直接写在resolve或reject的后面。所以，最好在它们前面加上return语句，这样就不会有意外。</p>
<pre><code class="JS">new Promise((resolve, reject) =&gt; {
  return resolve(1);
  // 后面的语句不会执行
  console.log(2);
})
</code></pre>
<h2 id="3-Promise-prototype-then"><a href="#3-Promise-prototype-then" class="headerlink" title="3. Promise.prototype.then()"></a>3. Promise.prototype.then()</h2><p>then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。</p>
<pre><code class="JS">getJSON(&quot;/posts.json&quot;).then(function(json) {
  return json.post;
}).then(function(post) {
  // ...
});
</code></pre>
<p>上面的代码使用then方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。</p>
<h2 id="4-Promise-prototype-catch"><a href="#4-Promise-prototype-catch" class="headerlink" title="4. Promise.prototype.catch()"></a>4. Promise.prototype.catch()</h2><p>Promise.prototype.catch方法是.then(null, rejection)或.then(undefined, rejection)的别名，用于指定发生错误时的回调函数。</p>
<pre><code class="JS">getJSON(&#39;/posts.json&#39;).then(function(posts) {
  // ...
}).catch(function(error) {
  // 处理 getJSON 和 前一个回调函数运行时发生的错误
  console.log(&#39;发生错误！&#39;, error);
});
</code></pre>
<p>上面代码中，getJSON方法返回一个 Promise 对象，如果该对象状态变为resolved，则会调用then方法指定的回调函数；如果异步操作抛出错误，状态就会变为rejected，就会调用catch方法指定的回调函数，处理这个错误。另外，then方法指定的回调函数，如果运行中抛出错误，也会被catch方法捕获。</p>
<pre><code class="JS">p.then((val) =&gt; console.log(&#39;fulfilled:&#39;, val))
  .catch((err) =&gt; console.log(&#39;rejected&#39;, err));

// 等同于
p.then((val) =&gt; console.log(&#39;fulfilled:&#39;, val))
  .then(null, (err) =&gt; console.log(&quot;rejected:&quot;, err));
</code></pre>
<p>下面是一个例子。</p>
<pre><code class="JS">const promise = new Promise(function(resolve, reject) {
  throw new Error(&#39;test&#39;);
});
promise.catch(function(error) {
  console.log(error);
});
// Error: test
</code></pre>
<p>上面代码中，promise抛出一个错误，就被catch方法指定的回调函数捕获。注意，上面的写法与下面两种写法是等价的。</p>
<pre><code class="JS">// 写法一
const promise = new Promise(function(resolve, reject) {
  try {
    throw new Error(&#39;test&#39;);
  } catch(e) {
    reject(e);
  }
});
promise.catch(function(error) {
  console.log(error);
});

// 写法二
const promise = new Promise(function(resolve, reject) {
  reject(new Error(&#39;test&#39;));
});
promise.catch(function(error) {
  console.log(error);
});
</code></pre>
<p>比较上面两种写法，可以发现reject方法的作用，等同于抛出错误。</p>
<p><strong>如果 Promise 状态已经变成resolved，再抛出错误是无效的。</strong></p>
<pre><code class="JS">const promise = new Promise(function(resolve, reject) {
  resolve(&#39;ok&#39;);
  throw new Error(&#39;test&#39;);
});
promise
  .then(function(value) { console.log(value) })
  .catch(function(error) { console.log(error) });
// ok
</code></pre>
<p>上面代码中，Promise 在resolve语句后面，再抛出错误，不会被捕获，等于没有抛出。因为 Promise 的状态一旦改变，就永久保持该状态，不会再变了。</p>
<p><strong>Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。</strong> 也就是说，错误总是会被下一个catch语句捕获。</p>
<pre><code class="JS">getJSON(&#39;/post/1.json&#39;).then(function(post) {
  return getJSON(post.commentURL);
}).then(function(comments) {
  // some code
}).catch(function(error) {
  // 处理前面三个Promise产生的错误
});
</code></pre>
<p>上面代码中，一共有三个 Promise 对象：一个由getJSON产生，两个由then产生。它们之中任何一个抛出的错误，都会被最后一个catch捕获。</p>
<p><strong>一般来说，不要在then方法里面定义 Reject 状态的回调函数（即then的第二个参数），总是使用catch方法。</strong></p>
<pre><code class="JS">// bad
promise
  .then(function(data) {
    // success
  }, function(err) {
    // error
  });

// good
promise
  .then(function(data) { //cb
    // success
  })
  .catch(function(err) {
    // error
  });
</code></pre>
<p>上面代码中，第二种写法要好于第一种写法，理由是第二种写法可以捕获前面then方法执行中的错误，也更接近同步的写法（try/catch）。因此，建议总是使用catch方法，而不使用then方法的第二个参数。</p>
<p>跟传统的try/catch代码块不同的是，如果没有使用catch方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码，即不会有任何反应。</p>
<pre><code class="JS">const someAsyncThing = function() {
  return new Promise(function(resolve, reject) {
    // 下面一行会报错，因为x没有声明
    resolve(x + 2);
  });
};

someAsyncThing().then(function() {
  console.log(&#39;everything is great&#39;);
});

setTimeout(() =&gt; { console.log(123) }, 2000);
// Uncaught (in promise) ReferenceError: x is not defined
// 123
</code></pre>
<p>上面代码中，someAsyncThing函数产生的 Promise 对象，内部有语法错误。浏览器运行到这一行，会打印出错误提示ReferenceError: x is not defined，但是不会退出进程、终止脚本执行，2 秒之后还是会输出123。这就是说， <strong>Promise 内部的错误不会影响到 Promise 外部的代码，通俗的说法就是“Promise 会吃掉错误”。</strong></p>
<h2 id="5-Promise-prototype-finally"><a href="#5-Promise-prototype-finally" class="headerlink" title="5. Promise.prototype.finally()"></a>5. Promise.prototype.finally()</h2><p>finally方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。</p>
<pre><code class="JS">promise
.then(result =&gt; {···})
.catch(error =&gt; {···})
.finally(() =&gt; {···});
</code></pre>
<p>上面代码中，不管promise最后的状态，在执行完then或catch指定的回调函数以后，都会执行finally方法指定的回调函数。</p>
<p>下面是一个例子，服务器使用 Promise 处理请求，然后使用finally方法关掉服务器。</p>
<pre><code class="JS">server.listen(port)
  .then(function () {
    // ...
  })
  .finally(server.stop);
</code></pre>
<p>finally方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是fulfilled还是rejected。这表明，finally方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。</p>
<p>finally本质上是then方法的特例。</p>
<h2 id="6-Promise-all"><a href="#6-Promise-all" class="headerlink" title="6. Promise.all()"></a>6. Promise.all()</h2><p>Promise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。</p>
<pre><code class="JS">const p = Promise.all([p1, p2, p3]);
</code></pre>
<p>上面代码中，Promise.all方法接受一个数组作为参数，p1、p2、p3都是 Promise 实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。（Promise.all方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。）</p>
<p>p的状态由p1、p2、p3决定，分成两种情况。</p>
<p>（1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。</p>
<p>（2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。</p>
<p>下面是一个具体的例子。</p>
<pre><code class="JS">const databasePromise = connectDatabase();

const booksPromise = databasePromise
  .then(findAllBooks);

const userPromise = databasePromise
  .then(getCurrentUser);

Promise.all([
  booksPromise,
  userPromise
])
.then(([books, user]) =&gt; pickTopRecommendations(books, user));
</code></pre>
<p>上面代码中， <strong>booksPromise和userPromise是两个异步操作，只有等到它们的结果都返回了，才会触发pickTopRecommendations这个回调函数。</strong></p>
<p>注意，如果作为参数的 Promise 实例，自己定义了catch方法，那么它一旦被rejected，并不会触发Promise.all()的catch方法。</p>
<pre><code class="JS">const p1 = new Promise((resolve, reject) =&gt; {
  resolve(&#39;hello&#39;);
})
.then(result =&gt; result)
.catch(e =&gt; e);

const p2 = new Promise((resolve, reject) =&gt; {
  throw new Error(&#39;报错了&#39;);
})
.then(result =&gt; result)
.catch(e =&gt; e);

Promise.all([p1, p2])
.then(result =&gt; console.log(result))
.catch(e =&gt; console.log(e));
// [&quot;hello&quot;, Error: 报错了]
</code></pre>
<p>上面代码中，p1会resolved，p2首先会rejected，但是p2有自己的catch方法，该方法返回的是一个新的 Promise 实例，p2指向的实际上是这个实例。该实例执行完catch方法后，也会变成resolved，导致Promise.all()方法参数里面的两个实例都会resolved，因此会调用then方法指定的回调函数，而不会调用catch方法指定的回调函数。</p>
<h2 id="7-Promise-race"><a href="#7-Promise-race" class="headerlink" title="7. Promise.race()"></a>7. Promise.race()</h2><p>Promise.race方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。</p>
<pre><code class="JS">const p = Promise.race([p1, p2, p3]);
</code></pre>
<p>上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。</p>
<p>Promise.race方法的参数与Promise.all方法一样，如果不是 Promise 实例，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。</p>
<p>下面是一个例子，如果指定时间内没有获得结果，就将 Promise 的状态变为reject，否则变为resolve。</p>
<pre><code class="JS">const p = Promise.race([
  fetch(&#39;/resource-that-may-take-a-while&#39;),
  new Promise(function (resolve, reject) {
    setTimeout(() =&gt; reject(new Error(&#39;request timeout&#39;)), 5000)
  })
]);

p
.then(console.log)
.catch(console.error);
</code></pre>
<p>上面代码中，如果 5 秒之内fetch方法无法返回结果，变量p的状态就会变为rejected，从而触发catch方法指定的回调函数。</p>
<h2 id="8-Promise-resolve"><a href="#8-Promise-resolve" class="headerlink" title="8. Promise.resolve()"></a>8. Promise.resolve()</h2><h2 id="9-Promise-reject"><a href="#9-Promise-reject" class="headerlink" title="9. Promise.reject()"></a>9. Promise.reject()</h2><h2 id="10-Promise-try"><a href="#10-Promise-try" class="headerlink" title="10. Promise.try()"></a>10. Promise.try()</h2>]]></content>
      
        <categories>
            
            <category> ECMAScript 6 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ECMAScript 6 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[技巧]]></title>
      <url>/2019/03/08/LeetCode-JavaScript/%E6%8A%80%E5%B7%A7/</url>
      <content type="html"><![CDATA[<h2 id="in-和-of-在数组中的区别"><a href="#in-和-of-在数组中的区别" class="headerlink" title="in 和 of 在数组中的区别"></a>in 和 of 在数组中的区别</h2><pre><code class="JS">let a = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];
for(let key in a){
    console.log(key);  //1,2,3
}

for(let value of a){
    console.log(value);  //a,b,c
}
</code></pre>
<h2 id="Map的赋值方式"><a href="#Map的赋值方式" class="headerlink" title="Map的赋值方式"></a>Map的赋值方式</h2><pre><code class="JS">let m = new Map();
m[&#39;a&#39;] = &#39;b&#39;;
m.has(&#39;a&#39;);  //false

m.set(&#39;c&#39;,&#39;d&#39;);
m.has(&#39;c&#39;);  //true
</code></pre>
<h2 id="矩阵划分"><a href="#矩阵划分" class="headerlink" title="矩阵划分"></a>矩阵划分</h2><pre><code class="JS">0 0 0 1 1 1 2 2 2
0 0 0 1 1 1 2 2 2
0 0 0 1 1 1 2 2 2
3 3 3 4 4 4 5 5 5
3 3 3 4 4 4 5 5 5
3 3 3 4 4 4 5 5 5
6 6 6 7 7 7 8 8 8
6 6 6 7 7 7 8 8 8
6 6 6 7 7 7 8 8 8
</code></pre>
<p>9x9的数组，划分为3x3的方阵</p>
<pre><code class="JS">index = Math.floor(i/3)+Math.floor(j/3)*3;
</code></pre>
<h2 id="链表结构"><a href="#链表结构" class="headerlink" title="链表结构"></a>链表结构</h2><pre><code class="JS">// Definition for singly-linked list.
function ListNode(val) {
    this.val = val;
    this.next = null;
}
let l1 = new ListNode(1);
let l2 = new ListNode(2);
l1.next = l2;
</code></pre>
<h2 id="生成多维数组"><a href="#生成多维数组" class="headerlink" title="生成多维数组"></a>生成多维数组</h2><pre><code class="JS">let n=3, m=4, i=0;
const a = new Array(n).fill(undefined).map(() =&gt; new Array(m).fill(i++));
//a = [ [ 0, 0, 0, 0 ], [ 1, 1, 1, 1 ], [ 2, 2, 2, 2 ] ]
</code></pre>
]]></content>
      
        <categories>
            
            <category> LeetCode-JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[39. 组合总和（Combination Sum）]]></title>
      <url>/2019/03/06/LeetCode-JavaScript/39.%20%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%EF%BC%88Combination%20Sum%EF%BC%89/</url>
      <content type="html"><![CDATA[<h2 id="39-组合总和（Combination-Sum）"><a href="#39-组合总和（Combination-Sum）" class="headerlink" title="39. 组合总和（Combination Sum）"></a>39. 组合总和（Combination Sum）</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>
<p>candidates 中的数字可以无限制重复被选取。</p>
<p>说明：</p>
<p>所有数字（包括 target）都是正整数。<br>解集不能包含重复的组合。<br>示例 1:</p>
<pre><code>输入: candidates = [2,3,6,7], target = 7,
所求解集为:
[
  [7],
  [2,2,3]
]
</code></pre><p>示例 2:</p>
<pre><code>输入: candidates = [2,3,5], target = 8,
所求解集为:
[
  [2,2,2,2],
  [2,3,3],
  [3,5]
]
</code></pre><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code class="JS">/**
 * @param {number[]} candidates
 * @param {number} target
 * @return {number[][]}
 */
var combinationSum = function(candidates, target) {
    let results = [], buffer = [];
    candidates.sort((a,b)=&gt;a-b);
    search(0, target);
    return results;

    function search(startIdx, target){
        if(target === 0) {
            results.push(buffer.slice());  //找到一解，加入解集
            return;
        }
        if(target &lt; 0) return;  //当前和已大于目标值
        if(startIdx === candidates.length) return;  //数组遍历到末尾
        buffer.push(candidates[startIdx]);
        search(startIdx, target-candidates[startIdx]);
        buffer.pop();
        search(startIdx+1, target);  
    }

};
</code></pre>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>数组元素可以重复使用，要固定某个值或某几个值，然后判断剩下元素是否可以构成剩余目标值。<br>判断过程同上，还是要固定某几个值。<br>由于元素可无限使用，不能逐一遍历，且每个循环方法类似，考虑回溯法。<br>将当前值压入堆栈，用剩余元素求解；然后当前值出栈，下一元素入栈。</p>
]]></content>
      
        <categories>
            
            <category> LeetCode-JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Set和Map数据结构]]></title>
      <url>/2019/03/04/ECMAScript6/Set%20%E5%92%8C%20Map%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      <content type="html"><![CDATA[<h2 id="1-Set"><a href="#1-Set" class="headerlink" title="1. Set"></a>1. Set</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。</p>
<p>Set本身是一个构造函数，用来生成 Set 数据结构。</p>
<pre><code class="JS">const s = new Set();

[2, 3, 5, 4, 5, 2, 2].forEach(x =&gt; s.add(x));

for (let i of s) {
  console.log(i);
}
// 2 3 5 4
</code></pre>
<p>上面代码通过add()方法向 Set 结构加入成员，结果表明 Set 结构不会添加重复的值。</p>
<p>Set函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。</p>
<pre><code class="JS">// 例一
const set = new Set([1, 2, 3, 4, 4]);
[...set]
// [1, 2, 3, 4]

// 例二
const items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);
items.size // 5

// 例三
const set = new Set(document.querySelectorAll(&#39;div&#39;));
set.size // 56

// 类似于
const set = new Set();
document
 .querySelectorAll(&#39;div&#39;)
 .forEach(div =&gt; set.add(div));
set.size // 56
</code></pre>
<p>上面代码中，例一和例二都是Set函数接受数组作为参数，例三是接受类似数组的对象作为参数。</p>
<p>上面代码也展示了一种去除数组重复成员的方法。</p>
<pre><code class="JS">// 去除数组的重复成员
[...new Set(array)]
</code></pre>
<p>上面的方法也可以用于，去除字符串里面的重复字符。</p>
<pre><code class="JS">[...new Set(&#39;ababbc&#39;)].join(&#39;&#39;)
// &quot;abc&quot;
</code></pre>
<p>向 Set 加入值的时候，不会发生类型转换，所以5和”5”是两个不同的值。Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于精确相等运算符（===），主要的区别是NaN等于自身，而精确相等运算符认为NaN不等于自身。</p>
<pre><code class="JS">let set = new Set();
let a = NaN;
let b = NaN;
set.add(a);
set.add(b);
set // Set {NaN}
</code></pre>
<p>上面代码向 Set 实例添加了两个NaN，但是只能加入一个。这表明，在 Set 内部，两个NaN是相等。</p>
<p>另外，两个对象总是不相等的。</p>
<pre><code class="JS">let set = new Set();

set.add({});
set.size // 1

set.add({});
set.size // 2
</code></pre>
<p>上面代码表示，由于两个空对象不相等，所以它们被视为两个值。</p>
<h2 id="2-Map"><a href="#2-Map" class="headerlink" title="2. Map"></a>2. Map</h2><h3 id="含义和基本用法"><a href="#含义和基本用法" class="headerlink" title="含义和基本用法"></a>含义和基本用法</h3><p>JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。</p>
<pre><code class="JS">const data = {};
const element = document.getElementById(&#39;myDiv&#39;);

data[element] = &#39;metadata&#39;;
data[&#39;[object HTMLDivElement]&#39;] // &quot;metadata&quot;
</code></pre>
<p>上面代码原意是将一个 DOM 节点作为对象data的键，但是由于对象只接受字符串作为键名，所以element被自动转为字符串[object HTMLDivElement]。</p>
<p>为了解决这个问题，ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。</p>
<pre><code class="JS">const m = new Map();
const o = {p: &#39;Hello World&#39;};

m.set(o, &#39;content&#39;)
m.get(o) // &quot;content&quot;

m.has(o) // true
m.delete(o) // true
m.has(o) // false
</code></pre>
<p>上面代码使用 Map 结构的set方法，将对象o当作m的一个键，然后又使用get方法读取这个键，接着使用delete方法删除了这个键。</p>
<p>上面的例子展示了如何向 Map 添加成员。作为构造函数，Map 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。</p>
<pre><code class="JS">const map = new Map([
  [&#39;name&#39;, &#39;张三&#39;],
  [&#39;title&#39;, &#39;Author&#39;]
]);

map.size // 2
map.has(&#39;name&#39;) // true
map.get(&#39;name&#39;) // &quot;张三&quot;
map.has(&#39;title&#39;) // true
map.get(&#39;title&#39;) // &quot;Author&quot;
</code></pre>
<p>上面代码在新建 Map 实例时，就指定了两个键name和title。</p>
<p>Map构造函数接受数组作为参数，实际上执行的是下面的算法。</p>
<pre><code class="JS">const items = [
  [&#39;name&#39;, &#39;张三&#39;],
  [&#39;title&#39;, &#39;Author&#39;]
];

const map = new Map();

items.forEach(
  ([key, value]) =&gt; map.set(key, value)
);
</code></pre>
<p>事实上，不仅仅是数组，任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构（详见《Iterator》一章）都可以当作Map构造函数的参数。这就是说，Set和Map都可以用来生成新的 Map。</p>
<pre><code class="JS">const set = new Set([
  [&#39;foo&#39;, 1],
  [&#39;bar&#39;, 2]
]);
const m1 = new Map(set);
m1.get(&#39;foo&#39;) // 1

const m2 = new Map([[&#39;baz&#39;, 3]]);
const m3 = new Map(m2);
m3.get(&#39;baz&#39;) // 3
</code></pre>
<p>上面代码中，我们分别使用 Set 对象和 Map 对象，当作Map构造函数的参数，结果都生成了新的 Map 对象。</p>
<p>注意，只有对同一个对象的引用，Map 结构才将其视为同一个键。这一点要非常小心。</p>
<pre><code class="JS">const map = new Map();

map.set([&#39;a&#39;], 555);
map.get([&#39;a&#39;]) // undefined
</code></pre>
<p>上面代码的set和get方法，表面是针对同一个键，但实际上这是两个值，内存地址是不一样的，因此get方法无法读取该键，返回undefined。</p>
<p>同理，同样的值的两个实例，在 Map 结构中被视为两个键。</p>
<pre><code class="JS">const map = new Map();

const k1 = [&#39;a&#39;];
const k2 = [&#39;a&#39;];

map
.set(k1, 111)
.set(k2, 222);

map.get(k1) // 111
map.get(k2) // 222
</code></pre>
<p>上面代码中，变量k1和k2的值是一样的，但是它们在 Map 结构中被视为两个键。</p>
<h3 id="与其他数据结构的互相转换"><a href="#与其他数据结构的互相转换" class="headerlink" title="与其他数据结构的互相转换"></a>与其他数据结构的互相转换</h3><h4 id="（1）Map-转为数组"><a href="#（1）Map-转为数组" class="headerlink" title="（1）Map 转为数组"></a>（1）Map 转为数组</h4><p>前面已经提过，Map 转为数组最方便的方法，就是使用扩展运算符（…）。</p>
<pre><code class="JS">const myMap = new Map()
  .set(true, 7)
  .set({foo: 3}, [&#39;abc&#39;]);
[...myMap]
// [ [ true, 7 ], [ { foo: 3 }, [ &#39;abc&#39; ] ] ]
</code></pre>
<h4 id="（2）数组-转为-Map"><a href="#（2）数组-转为-Map" class="headerlink" title="（2）数组 转为 Map"></a>（2）数组 转为 Map</h4><p>将数组传入 Map 构造函数，就可以转为 Map。</p>
<pre><code class="JS">new Map([
  [true, 7],
  [{foo: 3}, [&#39;abc&#39;]]
])
// Map {
//   true =&gt; 7,
//   Object {foo: 3} =&gt; [&#39;abc&#39;]
// }
</code></pre>
<h4 id="（3）Map-转为对象"><a href="#（3）Map-转为对象" class="headerlink" title="（3）Map 转为对象"></a>（3）Map 转为对象</h4><p>如果所有 Map 的键都是字符串，它可以无损地转为对象。</p>
<pre><code class="JS">function strMapToObj(strMap) {
  let obj = Object.create(null);
  for (let [k,v] of strMap) {
    obj[k] = v;
  }
  return obj;
}

const myMap = new Map()
  .set(&#39;yes&#39;, true)
  .set(&#39;no&#39;, false);
strMapToObj(myMap)
// { yes: true, no: false }
</code></pre>
<p>如果有非字符串的键名，那么这个键名会被转成字符串，再作为对象的键名。</p>
<h4 id="（4）对象转为-Map"><a href="#（4）对象转为-Map" class="headerlink" title="（4）对象转为 Map"></a>（4）对象转为 Map</h4><pre><code class="JS">function objToStrMap(obj) {
  let strMap = new Map();
  for (let k of Object.keys(obj)) {
    strMap.set(k, obj[k]);
  }
  return strMap;
}

objToStrMap({yes: true, no: false})
// Map {&quot;yes&quot; =&gt; true, &quot;no&quot; =&gt; false}
</code></pre>
<h4 id="（5）Map-转为-JSON"><a href="#（5）Map-转为-JSON" class="headerlink" title="（5）Map 转为 JSON"></a>（5）Map 转为 JSON</h4><p>Map 转为 JSON 要区分两种情况。一种情况是，Map 的键名都是字符串，这时可以选择转为对象 JSON。</p>
<pre><code class="JS">function strMapToJson(strMap) {
  return JSON.stringify(strMapToObj(strMap));
}

let myMap = new Map().set(&#39;yes&#39;, true).set(&#39;no&#39;, false);
strMapToJson(myMap)
// &#39;{&quot;yes&quot;:true,&quot;no&quot;:false}&#39;
</code></pre>
<p>另一种情况是，Map 的键名有非字符串，这时可以选择转为数组 JSON。</p>
<pre><code class="JS">function mapToArrayJson(map) {
  return JSON.stringify([...map]);
}

let myMap = new Map().set(true, 7).set({foo: 3}, [&#39;abc&#39;]);
mapToArrayJson(myMap)
// &#39;[[true,7],[{&quot;foo&quot;:3},[&quot;abc&quot;]]]&#39;
</code></pre>
<h4 id="（6）JSON-转为-Map"><a href="#（6）JSON-转为-Map" class="headerlink" title="（6）JSON 转为 Map"></a>（6）JSON 转为 Map</h4><p>JSON 转为 Map，正常情况下，所有键名都是字符串。</p>
<pre><code class="JS">function jsonToStrMap(jsonStr) {
  return objToStrMap(JSON.parse(jsonStr));
}

jsonToStrMap(&#39;{&quot;yes&quot;: true, &quot;no&quot;: false}&#39;)
// Map {&#39;yes&#39; =&gt; true, &#39;no&#39; =&gt; false}
</code></pre>
<p>但是，有一种特殊情况，整个 JSON 就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为 Map。这往往是 Map 转为数组 JSON 的逆操作。</p>
<pre><code class="JS">function jsonToMap(jsonStr) {
  return new Map(JSON.parse(jsonStr));
}

jsonToMap(&#39;[[true,7],[{&quot;foo&quot;:3},[&quot;abc&quot;]]]&#39;)
// Map {true =&gt; 7, Object {foo: 3} =&gt; [&#39;abc&#39;]}
</code></pre>
]]></content>
      
        <categories>
            
            <category> ECMAScript 6 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ECMAScript 6 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[对象的扩展]]></title>
      <url>/2019/03/04/ECMAScript6/%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95/</url>
      <content type="html"><![CDATA[<h2 id="1-属性的简洁表示法"><a href="#1-属性的简洁表示法" class="headerlink" title="1. 属性的简洁表示法"></a>1. 属性的简洁表示法</h2><p>ES6 允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。</p>
<pre><code class="JS">const foo = &#39;bar&#39;;
const baz = {foo};
baz // {foo: &quot;bar&quot;}

// 等同于
const baz = {foo: foo};
</code></pre>
<p>除了属性简写，方法也可以简写。</p>
<pre><code class="JS">const o = {
  method() {
    return &quot;Hello!&quot;;
  }
};

// 等同于

const o = {
  method: function() {
    return &quot;Hello!&quot;;
  }
};
</code></pre>
<p>注意，简洁写法的属性名总是字符串，这会导致一些看上去比较奇怪的结果。</p>
<pre><code class="JS">const obj = {
  class () {}
};

// 等同于

var obj = {
  &#39;class&#39;: function() {}
};
</code></pre>
<p>上面代码中，class是字符串，所以不会因为它属于关键字，而导致语法解析报错。</p>
<h2 id="2-属性名表达式"><a href="#2-属性名表达式" class="headerlink" title="2. 属性名表达式"></a>2. 属性名表达式</h2><p>JavaScript 定义对象的属性，有两种方法。</p>
<pre><code class="JS">// 方法一
obj.foo = true;

// 方法二
obj[&#39;a&#39; + &#39;bc&#39;] = 123;
</code></pre>
<p>上面代码的方法一是直接用标识符作为属性名，方法二是用表达式作为属性名，这时要将表达式放在方括号之内。</p>
<p>但是，如果使用字面量方式定义对象（使用大括号），在 ES5 中只能使用方法一（标识符）定义属性。</p>
<pre><code class="JS">var obj = {
  foo: true,
  abc: 123
};
</code></pre>
<p>ES6 允许字面量定义对象时，用方法二（表达式）作为对象的属性名，即把表达式放在方括号内。</p>
<pre><code class="JS">let propKey = &#39;foo&#39;;

let obj = {
  [propKey]: true,
  [&#39;a&#39; + &#39;bc&#39;]: 123
};
</code></pre>
<p>表达式还可以用于定义方法名。</p>
<pre><code class="JS">let obj = {
  [&#39;h&#39; + &#39;ello&#39;]() {
    return &#39;hi&#39;;
  }
};

obj.hello() // hi
</code></pre>
<p>注意，属性名表达式与简洁表示法，不能同时使用，会报错。</p>
<pre><code class="JS">// 报错
const foo = &#39;bar&#39;;
const bar = &#39;abc&#39;;
const baz = { [foo] };

// 正确
const foo = &#39;bar&#39;;
const baz = { [foo]: &#39;abc&#39;};
</code></pre>
<h2 id="3-方法的-name-属性"><a href="#3-方法的-name-属性" class="headerlink" title="3. 方法的 name 属性"></a>3. 方法的 name 属性</h2><h2 id="4-属性的可枚举性和遍历"><a href="#4-属性的可枚举性和遍历" class="headerlink" title="4. 属性的可枚举性和遍历"></a>4. 属性的可枚举性和遍历</h2><h3 id="可枚举性"><a href="#可枚举性" class="headerlink" title="可枚举性"></a>可枚举性</h3><p>对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。Object.getOwnPropertyDescriptor方法可以获取该属性的描述对象。</p>
<pre><code class="JS">let obj = { foo: 123 };
Object.getOwnPropertyDescriptor(obj, &#39;foo&#39;)
//  {
//    value: 123,
//    writable: true,
//    enumerable: true,
//    configurable: true
//  }
</code></pre>
<p>描述对象的enumerable属性，称为“可枚举性”，如果该属性为false，就表示某些操作会忽略当前属性。</p>
<p>目前，有四个操作会忽略enumerable为false的属性。</p>
<ul>
<li>for…in循环：只遍历对象自身的和继承的可枚举的属性。</li>
<li>Object.keys()：返回对象自身的所有可枚举的属性的键名。</li>
<li>JSON.stringify()：只串行化对象自身的可枚举的属性。</li>
<li>Object.assign()： 忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性。<br>这四个操作之中，前三个是 ES5 就有的，最后一个Object.assign()是 ES6 新增的。其中，只有for…in会返回继承的属性，其他三个方法都会忽略继承的属性，只处理对象自身的属性。实际上，引入“可枚举”（enumerable）这个概念的最初目的，就是让某些属性可以规避掉for…in操作，不然所有内部属性和方法都会被遍历到。比如，对象原型的toString方法，以及数组的length属性，就通过“可枚举性”，从而避免被for…in遍历到。<br>```JS<br>Object.getOwnPropertyDescriptor(Object.prototype, ‘toString’).enumerable<br>// false</li>
</ul>
<p>Object.getOwnPropertyDescriptor([], ‘length’).enumerable<br>// false</p>
<pre><code>上面代码中，toString和length属性的enumerable都是false，因此for...in不会遍历到这两个继承自原型的属性。

另外，ES6 规定，所有 Class 的原型的方法都是不可枚举的。
```JS
Object.getOwnPropertyDescriptor(class {foo() {}}.prototype, &#39;foo&#39;).enumerable
// false
</code></pre><p>总的来说，操作中引入继承的属性会让问题复杂化，大多数时候，我们只关心对象自身的属性。所以，尽量不要用for…in循环，而用Object.keys()代替。</p>
<h3 id="属性的遍历"><a href="#属性的遍历" class="headerlink" title="属性的遍历"></a>属性的遍历</h3><p>ES6 一共有 5 种方法可以遍历对象的属性。</p>
<p>（1）for…in</p>
<p>for…in循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。</p>
<p>（2）Object.keys(obj)</p>
<p>Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。</p>
<p>（3）Object.getOwnPropertyNames(obj)</p>
<p>Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。</p>
<p>（4）Object.getOwnPropertySymbols(obj)</p>
<p>Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有 Symbol 属性的键名。</p>
<p>（5）Reflect.ownKeys(obj)</p>
<p>Reflect.ownKeys返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。</p>
<p>以上的 5 种方法遍历对象的键名，都遵守同样的属性遍历的次序规则。</p>
<p>首先遍历所有数值键，按照数值升序排列。<br>其次遍历所有字符串键，按照加入时间升序排列。<br>最后遍历所有 Symbol 键，按照加入时间升序排列。</p>
<pre><code class="JS">Reflect.ownKeys({ [Symbol()]:0, b:0, 10:0, 2:0, a:0 })
// [&#39;2&#39;, &#39;10&#39;, &#39;b&#39;, &#39;a&#39;, Symbol()]
</code></pre>
<p>上面代码中，Reflect.ownKeys方法返回一个数组，包含了参数对象的所有属性。这个数组的属性次序是这样的，首先是数值属性2和10，其次是字符串属性b和a，最后是 Symbol 属性。</p>
<h2 id="5-super-关键字"><a href="#5-super-关键字" class="headerlink" title="5. super 关键字"></a>5. super 关键字</h2><p>我们知道，this关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的关键字super，指向当前对象的原型对象。</p>
<pre><code class="JS">const proto = {
  foo: &#39;hello&#39;
};

const obj = {
  foo: &#39;world&#39;,
  find() {
    return super.foo;
  }
};

Object.setPrototypeOf(obj, proto);
obj.find() // &quot;hello&quot;
</code></pre>
<p>上面代码中，对象obj.find()方法之中，通过super.foo引用了原型对象proto的foo属性。</p>
<p>注意，super关键字表示原型对象时，只能用在对象的方法之中，用在其他地方都会报错。</p>
<pre><code class="JS">// 报错
const obj = {
  foo: super.foo
}

// 报错
const obj = {
  foo: () =&gt; super.foo
}

// 报错
const obj = {
  foo: function () {
    return super.foo
  }
}
</code></pre>
<p>上面三种super的用法都会报错，因为对于 JavaScript 引擎来说，这里的super都没有用在对象的方法之中。第一种写法是super用在属性里面，第二种和第三种写法是super用在一个函数里面，然后赋值给foo属性。目前，只有对象方法的简写法可以让 JavaScript 引擎确认，定义的是对象的方法。</p>
<p>JavaScript 引擎内部，super.foo等同于Object.getPrototypeOf(this).foo（属性）或Object.getPrototypeOf(this).foo.call(this)（方法）。</p>
<pre><code class="JS">const proto = {
  x: &#39;hello&#39;,
  foo() {
    console.log(this.x);
  },
};

const obj = {
  x: &#39;world&#39;,
  foo() {
    super.foo();
  }
}

Object.setPrototypeOf(obj, proto);

obj.foo() // &quot;world&quot;
</code></pre>
<p>上面代码中，super.foo指向原型对象proto的foo方法，但是绑定的this却还是当前对象obj，因此输出的就是world。</p>
<h2 id="6-对象的扩展运算符"><a href="#6-对象的扩展运算符" class="headerlink" title="6. 对象的扩展运算符"></a>6. 对象的扩展运算符</h2><h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><p>对象的解构赋值用于从一个对象取值，相当于将目标对象自身的所有可遍历的（enumerable）、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面。</p>
<pre><code class="JS">let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };
x // 1
y // 2
z // { a: 3, b: 4 }
</code></pre>
<p>扩展运算符的解构赋值，不能复制继承自原型对象的属性。</p>
<pre><code class="JS">let o1 = { a: 1 };
let o2 = { b: 2 };
o2.__proto__ = o1;
let { ...o3 } = o2;
o3 // { b: 2 }
o3.a // undefined
</code></pre>
<p>上面代码中，对象o3复制了o2，但是只复制了o2自身的属性，没有复制它的原型对象o1的属性。</p>
<p>下面是另一个例子。</p>
<pre><code class="JS">const o = Object.create({ x: 1, y: 2 });
o.z = 3;

let { x, ...newObj } = o;
let { y, z } = newObj;
x // 1
y // undefined
z // 3
</code></pre>
<p>上面代码中，变量x是单纯的解构赋值，所以可以读取对象o继承的属性；变量y和z是扩展运算符的解构赋值，只能读取对象o自身的属性，所以变量z可以赋值成功，变量y取不到值。ES6 规定，变量声明语句之中，如果使用解构赋值，扩展运算符后面必须是一个变量名，而不能是一个解构赋值表达式，所以上面代码引入了中间变量newObj，如果写成下面这样会报错。</p>
<pre><code class="JS">let { x, ...{ y, z } } = o;
// SyntaxError: ... must be followed by an identifier in declaration contexts
</code></pre>
<h3 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h3><p>对象的扩展运算符（…）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。</p>
<pre><code class="JS">let z = { a: 3, b: 4 };
let n = { ...z };
n // { a: 3, b: 4 }
</code></pre>
<p>由于数组是特殊的对象，所以对象的扩展运算符也可以用于数组。</p>
<pre><code class="JS">let foo = { ...[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] };
foo
// {0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;}
</code></pre>
<p>对象的扩展运算符等同于使用Object.assign()方法。</p>
<pre><code class="JS">let aClone = { ...a };
// 等同于
let aClone = Object.assign({}, a);
</code></pre>
<p>上面的例子只是拷贝了对象实例的属性，如果想完整克隆一个对象，还拷贝对象原型的属性，可以采用下面的写法。</p>
<pre><code class="JS">// 写法一
const clone1 = {
  __proto__: Object.getPrototypeOf(obj),
  ...obj
};

// 写法二
const clone2 = Object.assign(
  Object.create(Object.getPrototypeOf(obj)),
  obj
);

// 写法三
const clone3 = Object.create(
  Object.getPrototypeOf(obj),
  Object.getOwnPropertyDescriptors(obj)
)
</code></pre>
<p>上面代码中，写法一的<strong>proto</strong>属性在非浏览器的环境不一定部署，因此推荐使用写法二和写法三。</p>
]]></content>
      
        <categories>
            
            <category> ECMAScript 6 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ECMAScript 6 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[数组的扩展]]></title>
      <url>/2019/03/03/ECMAScript6/%E6%95%B0%E7%BB%84%E7%9A%84%E6%89%A9%E5%B1%95/</url>
      <content type="html"><![CDATA[<h2 id="1-扩展运算符"><a href="#1-扩展运算符" class="headerlink" title="1. 扩展运算符"></a>1. 扩展运算符</h2><p>注意，扩展运算符如果放在括号中，JavaScript 引擎就会认为这是函数调用。如果这时不是函数调用，就会报错。</p>
<pre><code class="JS">(...[1, 2])
// Uncaught SyntaxError: Unexpected number

console.log((...[1, 2]))
// Uncaught SyntaxError: Unexpected number

console.log(...[1, 2])
// 1 2
</code></pre>
<p>上面前两种情况都会报错，因为扩展运算符所在的括号不是函数调用，而第三种情况console.log(…[1, 2])就不会报错，因为这时是函数调用。</p>
<h3 id="替代函数的-apply-方法"><a href="#替代函数的-apply-方法" class="headerlink" title="替代函数的 apply 方法"></a>替代函数的 apply 方法</h3><p>由于扩展运算符可以展开数组，所以不再需要apply方法，将数组转为函数的参数了。 </p>
<p>下面是扩展运算符取代apply方法的一个实际的例子，应用Math.max方法，简化求出一个数组最大元素的写法。</p>
<pre><code class="JS">// ES5 的写法
Math.max.apply(null, [14, 3, 77])

// ES6 的写法
Math.max(...[14, 3, 77])

// 等同于
Math.max(14, 3, 77);
</code></pre>
<p>上面代码中，由于 JavaScript 不提供求数组最大元素的函数，所以只能套用Math.max函数，将数组转为一个参数序列，然后求最大值。有了扩展运算符以后，就可以直接用Math.max了。</p>
<h3 id="扩展运算符的应用"><a href="#扩展运算符的应用" class="headerlink" title="扩展运算符的应用"></a>扩展运算符的应用</h3><h4 id="1）复制数组"><a href="#1）复制数组" class="headerlink" title="1）复制数组"></a>1）复制数组</h4><p>数组是复合的数据类型，直接复制的话，只是复制了指向底层数据结构的指针，而不是克隆一个全新的数组。</p>
<pre><code class="JS">const a1 = [1, 2];
const a2 = a1;

a2[0] = 2;
a1 // [2, 2]
</code></pre>
<p>上面代码中，a2并不是a1的克隆，而是指向同一份数据的另一个指针。修改a2，会直接导致a1的变化。</p>
<p>ES5 只能用变通方法来复制数组。</p>
<pre><code class="JS">const a1 = [1, 2];
const a2 = a1.concat();

a2[0] = 2;
a1 // [1, 2]
</code></pre>
<p>上面代码中，a1会返回原数组的克隆，再修改a2就不会对a1产生影响。</p>
<p>扩展运算符提供了复制数组的简便写法。</p>
<pre><code class="JS">const a1 = [1, 2];
// 写法一
const a2 = [...a1];
// 写法二
const [...a2] = a1;
</code></pre>
<p>上面的两种写法，a2都是a1的克隆。</p>
<h4 id="2）合并数组"><a href="#2）合并数组" class="headerlink" title="2）合并数组"></a>2）合并数组</h4><p>扩展运算符提供了数组合并的新写法。</p>
<pre><code class="JS">const arr1 = [&#39;a&#39;, &#39;b&#39;];
const arr2 = [&#39;c&#39;];
const arr3 = [&#39;d&#39;, &#39;e&#39;];

// ES5 的合并数组
arr1.concat(arr2, arr3);
// [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39; ]

// ES6 的合并数组
[...arr1, ...arr2, ...arr3]
// [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39; ]
</code></pre>
<p>不过，这两种方法都是浅拷贝，使用的时候需要注意。</p>
<pre><code class="JS">const a1 = [{ foo: 1 }];
const a2 = [{ bar: 2 }];

const a3 = a1.concat(a2);
const a4 = [...a1, ...a2];

a3[0] === a1[0] // true
a4[0] === a1[0] // true
</code></pre>
<p>上面代码中，a3和a4是用两种不同方法合并而成的新数组，但是它们的成员都是对原数组成员的引用，这就是浅拷贝。如果修改了原数组的成员，会同步反映到新数组。</p>
<h4 id="3）与解构赋值结合"><a href="#3）与解构赋值结合" class="headerlink" title="3）与解构赋值结合"></a>3）与解构赋值结合</h4><p>扩展运算符可以与解构赋值结合起来，用于生成数组。</p>
<pre><code class="JS">// ES5
a = list[0], rest = list.slice(1)
// ES6
[a, ...rest] = list
</code></pre>
<p>如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。</p>
<pre><code class="JS">const [...butLast, last] = [1, 2, 3, 4, 5];
// 报错

const [first, ...middle, last] = [1, 2, 3, 4, 5];
// 报错
</code></pre>
<h4 id="4）字符串"><a href="#4）字符串" class="headerlink" title="4）字符串"></a>4）字符串</h4><p>扩展运算符还可以将字符串转为真正的数组。</p>
<pre><code class="JS">[...&#39;hello&#39;]
// [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]
</code></pre>
<h4 id="5）实现了-Iterator-接口的对象"><a href="#5）实现了-Iterator-接口的对象" class="headerlink" title="5）实现了 Iterator 接口的对象"></a>5）实现了 Iterator 接口的对象</h4><p>任何定义了遍历器（Iterator）接口的对象（参阅 Iterator 一章），都可以用扩展运算符转为真正的数组。</p>
<pre><code class="JS">let nodeList = document.querySelectorAll(&#39;div&#39;);
let array = [...nodeList];
</code></pre>
<p>上面代码中，querySelectorAll方法返回的是一个NodeList对象。它不是数组，而是一个类似数组的对象。这时，扩展运算符可以将其转为真正的数组，原因就在于NodeList对象实现了 Iterator 。</p>
<p>对于那些没有部署 Iterator 接口的类似数组的对象，扩展运算符就无法将其转为真正的数组。</p>
<pre><code class="JS">let arrayLike = {
  &#39;0&#39;: &#39;a&#39;,
  &#39;1&#39;: &#39;b&#39;,
  &#39;2&#39;: &#39;c&#39;,
  length: 3
};

// TypeError: Cannot spread non-iterable object.
let arr = [...arrayLike];
</code></pre>
<p>上面代码中，arrayLike是一个类似数组的对象，但是没有部署 Iterator 接口，扩展运算符就会报错。这时，可以改为使用Array.from方法将arrayLike转为真正的数组。</p>
<h2 id="2-Array-from"><a href="#2-Array-from" class="headerlink" title="2. Array.from()"></a>2. Array.from()</h2><p>Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）。</p>
<p>下面是一个类似数组的对象，Array.from将它转为真正的数组。</p>
<pre><code class="JS">let arrayLike = {
    &#39;0&#39;: &#39;a&#39;,
    &#39;1&#39;: &#39;b&#39;,
    &#39;2&#39;: &#39;c&#39;,
    length: 3
};

// ES5的写法
var arr1 = [].slice.call(arrayLike); // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]

// ES6的写法
let arr2 = Array.from(arrayLike); // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]
</code></pre>
<p>值得提醒的是，扩展运算符（…）也可以将某些数据结构转为数组。</p>
<pre><code class="JS">// arguments对象
function foo() {
  const args = [...arguments];
}

// NodeList对象
[...document.querySelectorAll(&#39;div&#39;)]
</code></pre>
<p>扩展运算符背后调用的是遍历器接口（Symbol.iterator），如果一个对象没有部署这个接口，就无法转换。Array.from方法还支持类似数组的对象。所谓类似数组的对象，本质特征只有一点，即必须有length属性。因此，任何有length属性的对象，都可以通过Array.from方法转为数组，而此时扩展运算符就无法转换。</p>
<pre><code class="JS">Array.from({ length: 3 });
// [ undefined, undefined, undefined ]
</code></pre>
<p>上面代码中，Array.from返回了一个具有三个成员的数组，每个位置的值都是undefined。扩展运算符转换不了这个对象。</p>
<h2 id="3-Array-of"><a href="#3-Array-of" class="headerlink" title="3. Array.of()"></a>3. Array.of()</h2><p>Array.of方法用于将一组值，转换为数组。</p>
<pre><code class="JS">Array.of(3, 11, 8) // [3,11,8]
Array.of(3) // [3]
Array.of(3).length // 1
</code></pre>
<h2 id="4-数组实例的-copyWithin"><a href="#4-数组实例的-copyWithin" class="headerlink" title="4. 数组实例的 copyWithin()"></a>4. 数组实例的 copyWithin()</h2><h2 id="5-数组实例的-find-和-findIndex"><a href="#5-数组实例的-find-和-findIndex" class="headerlink" title="5. 数组实例的 find() 和 findIndex()"></a>5. 数组实例的 find() 和 findIndex()</h2><p>数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。</p>
<pre><code class="JS">[1, 4, -5, 10].find((n) =&gt; n &lt; 0)
// -5
</code></pre>
<p>上面代码找出数组中第一个小于 0 的成员。</p>
<pre><code class="JS">[1, 5, 10, 15].find(function(value, index, arr) {
  return value &gt; 9;
}) // 10
</code></pre>
<p>上面代码中，find方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。</p>
<p>数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。</p>
<pre><code class="JS">[1, 5, 10, 15].findIndex(function(value, index, arr) {
  return value &gt; 9;
}) // 2
</code></pre>
<p>另外，这两个方法都可以发现NaN，弥补了数组的indexOf方法的不足。</p>
<pre><code>[NaN].indexOf(NaN)
// -1

[NaN].findIndex(y =&gt; Object.is(NaN, y))
// 0
</code></pre><p>上面代码中，indexOf方法无法识别数组的NaN成员，但是findIndex方法可以借助Object.is方法做到。</p>
<h2 id="6-数组实例的-fill"><a href="#6-数组实例的-fill" class="headerlink" title="6. 数组实例的 fill()"></a>6. 数组实例的 fill()</h2><p>fill方法使用给定值，填充一个数组。</p>
<pre><code class="JS">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;].fill(7)
// [7, 7, 7]

new Array(3).fill(7)
// [7, 7, 7]
</code></pre>
<p>上面代码表明，fill方法用于空数组的初始化非常方便。数组中已有的元素，会被全部抹去。</p>
<p>fill方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。</p>
<pre><code class="JS">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;].fill(7, 1, 2)
// [&#39;a&#39;, 7, &#39;c&#39;]
</code></pre>
<p>注意，如果填充的类型为对象，那么被赋值的是同一个内存地址的对象，而不是深拷贝对象。</p>
<pre><code class="JS">let arr = new Array(3).fill({name: &quot;Mike&quot;});
arr[0].name = &quot;Ben&quot;;
arr
// [{name: &quot;Ben&quot;}, {name: &quot;Ben&quot;}, {name: &quot;Ben&quot;}]

let arr = new Array(3).fill([]);
arr[0].push(5);
arr
// [[5], [5], [5]]
</code></pre>
<h2 id="7-数组实例的-entries-，keys-和-values"><a href="#7-数组实例的-entries-，keys-和-values" class="headerlink" title="7. 数组实例的 entries()，keys() 和 values()"></a>7. 数组实例的 entries()，keys() 和 values()</h2><p>ES6 提供三个新的方法——entries()，keys()和values()——用于遍历数组。它们都返回一个遍历器对象（详见《Iterator》一章），可以用for…of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。</p>
<pre><code class="JS">for (let index of [&#39;a&#39;, &#39;b&#39;].keys()) {
  console.log(index);
}
// 0
// 1

for (let elem of [&#39;a&#39;, &#39;b&#39;].values()) {
  console.log(elem);
}
// &#39;a&#39;
// &#39;b&#39;

for (let [index, elem] of [&#39;a&#39;, &#39;b&#39;].entries()) {
  console.log(index, elem);
}
// 0 &quot;a&quot;
// 1 &quot;b&quot;
</code></pre>
<h2 id="8-数组实例的-includes"><a href="#8-数组实例的-includes" class="headerlink" title="8. 数组实例的 includes()"></a>8. 数组实例的 includes()</h2><p>Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。ES2016 引入了该方法。</p>
<pre><code class="JS">[1, 2, 3].includes(2)     // true
[1, 2, 3].includes(4)     // false
[1, 2, NaN].includes(NaN) // true
</code></pre>
<p>该方法的第二个参数表示搜索的起始位置，默认为0。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为-4，但数组长度为3），则会重置为从0开始。</p>
<pre><code class="JS">[1, 2, 3].includes(3, 3);  // false
[1, 2, 3].includes(3, -1); // true
</code></pre>
<p>没有该方法之前，我们通常使用数组的indexOf方法，检查是否包含某个值。</p>
<pre><code class="JS">if (arr.indexOf(el) !== -1) {
  // ...
}
</code></pre>
<p>indexOf方法有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于-1，表达起来不够直观。二是，它内部使用严格相等运算符（===）进行判断，这会导致对NaN的误判。</p>
<pre><code class="JS">[NaN].indexOf(NaN)
// -1
</code></pre>
<p>includes使用的是不一样的判断算法，就没有这个问题。</p>
<pre><code class="JS">[NaN].includes(NaN)
// true
</code></pre>
<h2 id="9-数组实例的-flat-，flatMap"><a href="#9-数组实例的-flat-，flatMap" class="headerlink" title="9. 数组实例的 flat()，flatMap()"></a>9. 数组实例的 flat()，flatMap()</h2><p>数组的成员有时还是数组，Array.prototype.flat()用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数据没有影响。</p>
<pre><code class="JS">[1, 2, [3, 4]].flat()
// [1, 2, 3, 4]
</code></pre>
<p>上面代码中，原数组的成员里面有一个数组，flat()方法将子数组的成员取出来，添加在原来的位置。</p>
<p>flat()默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将flat()方法的参数写成一个整数，表示想要拉平的层数，默认为1。</p>
<pre><code class="JS">[1, 2, [3, [4, 5]]].flat()
// [1, 2, 3, [4, 5]]

[1, 2, [3, [4, 5]]].flat(2)
// [1, 2, 3, 4, 5]
</code></pre>
<p>上面代码中，flat()的参数为2，表示要“拉平”两层的嵌套数组。</p>
<p>如果不管有多少层嵌套，都要转成一维数组，可以用Infinity关键字作为参数。</p>
<pre><code class="JS">[1, [2, [3]]].flat(Infinity)
// [1, 2, 3]
</code></pre>
<p>如果原数组有空位，flat()方法会跳过空位。</p>
<pre><code class="JS">[1, 2, , 4, 5].flat()
// [1, 2, 4, 5]
</code></pre>
<h2 id="10-数组的空位"><a href="#10-数组的空位" class="headerlink" title="10. 数组的空位"></a>10. 数组的空位</h2>]]></content>
      
        <categories>
            
            <category> ECMAScript 6 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ECMAScript 6 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript中的this关键字]]></title>
      <url>/2019/03/03/JavaScript/JavaScript%E4%B8%AD%E7%9A%84this%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      <content type="html"><![CDATA[<h2 id="1-涵义"><a href="#1-涵义" class="headerlink" title="1. 涵义"></a>1. 涵义</h2><p>this可以用在构造函数之中，表示实例对象。除此之外，this还可以用在别的场合。但不管是什么场合，this都有一个共同点：它总是返回一个对象。</p>
<p>简单说，this就是属性或方法“当前”所在的对象。</p>
<pre><code class="JS">var person = {
  name: &#39;张三&#39;,
  describe: function () {
    return &#39;姓名：&#39;+ this.name;
  }
};

person.describe()
// &quot;姓名：张三&quot;
</code></pre>
<p>上面代码中，this.name表示name属性所在的那个对象。由于this.name是在describe方法中调用，而describe方法所在的当前对象是person，因此this指向person，this.name就是 person.name。</p>
<p>由于对象的属性可以赋给另一个对象，所以属性所在的当前对象是可变的，即this的指向是可变的。</p>
<pre><code class="JS">var A = {
  name: &#39;张三&#39;,
  describe: function () {
    return &#39;姓名：&#39;+ this.name;
  }
};

var B = {
  name: &#39;李四&#39;
};

B.describe = A.describe;
B.describe()
// &quot;姓名：李四&quot;
</code></pre>
<p>上面代码中，A.describe属性被赋给B，于是B.describe就表示describe方法所在的当前对象是B，所以this.name就指向B.name。</p>
<p>只要函数被赋给另一个变量，this的指向就会变。</p>
<pre><code class="JS">var A = {
  name: &#39;张三&#39;,
  describe: function () {
    return &#39;姓名：&#39;+ this.name;
  }
};

var name = &#39;李四&#39;;
var f = A.describe;
f() // &quot;姓名：李四&quot;
</code></pre>
<p>上面代码中，A.describe被赋值给变量f，内部的this就会指向f运行时所在的对象（本例是顶层对象）。</p>
<p>如果this所在的方法不在对象的第一层，这时this只是指向当前一层的对象，而不会继承更上面的层。</p>
<pre><code class="JS">var a = {
  p: &#39;Hello&#39;,
  b: {
    m: function() {
      console.log(this.p);
    }
  }
};

a.b.m() // undefined
</code></pre>
<p>上面代码中，a.b.m方法在a对象的第二层，该方法内部的this不是指向a，而是指向a.b，因为实际执行的是下面的代码。</p>
<pre><code class="JS">var b = {
  m: function() {
   console.log(this.p);
  }
};

var a = {
  p: &#39;Hello&#39;,
  b: b
};

(a.b).m() // 等同于 b.m()
</code></pre>
<h2 id="2-使用注意点"><a href="#2-使用注意点" class="headerlink" title="2. 使用注意点"></a>2. 使用注意点</h2><h3 id="2-1-避免多层this"><a href="#2-1-避免多层this" class="headerlink" title="2.1 避免多层this"></a>2.1 避免多层this</h3><p>由于this的指向是不确定的，所以切勿在函数中包含多层的this。</p>
<pre><code class="JS">var o = {
  f1: function () {
    console.log(this);
    var f2 = function () {
      console.log(this);
    }();
  }
}

o.f1()
// Object
// Window
</code></pre>
<p>上面代码包含两层this，结果运行后，第一层指向对象o，第二层指向全局对象，因为实际执行的是下面的代码。</p>
<pre><code class="JS">var temp = function () {
  console.log(this);
};

var o = {
  f1: function () {
    console.log(this);
    var f2 = temp();
  }
}
</code></pre>
<p>一个解决方法是在第二层改用一个指向外层this的变量。</p>
<pre><code class="JS">var o = {
  f1: function() {
    console.log(this);
    var that = this;
    var f2 = function() {
      console.log(that);
    }();
  }
}

o.f1()
// Object
// Object
</code></pre>
<p>上面代码定义了变量that，固定指向外层的this，然后在内层使用that，就不会发生this指向的改变。</p>
<h3 id="2-2-避免数组处理方法中的-this"><a href="#2-2-避免数组处理方法中的-this" class="headerlink" title="2.2 避免数组处理方法中的 this"></a>2.2 避免数组处理方法中的 this</h3><p>数组的map和foreach方法，允许提供一个函数作为参数。这个函数内部不应该使用this。</p>
<pre><code class="JS">var o = {
  v: &#39;hello&#39;,
  p: [ &#39;a1&#39;, &#39;a2&#39; ],
  f: function f() {
    this.p.forEach(function (item) {
      console.log(this.v + &#39; &#39; + item);
    });
  }
}

o.f()
// undefined a1
// undefined a2
</code></pre>
<p>上面代码中，foreach方法的回调函数中的this，其实是指向window对象，因此取不到o.v的值。原因跟上一段的多层this是一样的，就是内层的this不指向外部，而指向顶层对象。</p>
<p>解决这个问题的一种方法，就是前面提到的，使用中间变量固定this。</p>
<pre><code class="JS">var o = {
  v: &#39;hello&#39;,
  p: [ &#39;a1&#39;, &#39;a2&#39; ],
  f: function f() {
    var that = this;
    this.p.forEach(function (item) {
      console.log(that.v+&#39; &#39;+item);
    });
  }
}

o.f()
// hello a1
// hello a2
</code></pre>
<p>另一种方法是将this当作foreach方法的第二个参数，固定它的运行环境。</p>
<pre><code class="JS">var o = {
  v: &#39;hello&#39;,
  p: [ &#39;a1&#39;, &#39;a2&#39; ],
  f: function f() {
    this.p.forEach(function (item) {
      console.log(this.v + &#39; &#39; + item);
    }, this);
  }
}

o.f()
// hello a1
// hello a2
</code></pre>
<h3 id="2-3-避免回调函数中的-this"><a href="#2-3-避免回调函数中的-this" class="headerlink" title="2.3 避免回调函数中的 this"></a>2.3 避免回调函数中的 this</h3><p>回调函数中的this往往会改变指向，最好避免使用。</p>
<pre><code class="JS">var o = new Object();
o.f = function () {
  console.log(this === o);
}

// jQuery 的写法
$(&#39;#button&#39;).on(&#39;click&#39;, o.f);
</code></pre>
<p>上面代码中，点击按钮以后，控制台会显示false。原因是此时this不再指向o对象，而是指向按钮的 DOM 对象，因为f方法是在按钮对象的环境中被调用的。这种细微的差别，很容易在编程中忽视，导致难以察觉的错误。</p>
<p>为了解决这个问题，可以采用下面的一些方法对this进行绑定，也就是使得this固定指向某个对象，减少不确定性。</p>
<h2 id="3-绑定this的方法"><a href="#3-绑定this的方法" class="headerlink" title="3. 绑定this的方法"></a>3. 绑定this的方法</h2><h3 id="3-1-Function-prototype-call"><a href="#3-1-Function-prototype-call" class="headerlink" title="3.1 Function.prototype.call()"></a>3.1 Function.prototype.call()</h3><p>函数实例的call方法，可以指定函数内部this的指向（即函数执行时所在的作用域），然后在所指定的作用域中，调用该函数。</p>
<pre><code class="JS">var obj = {};

var f = function () {
  return this;
};

f() === window // true
f.call(obj) === obj // true
</code></pre>
<p>上面代码中，全局环境运行函数f时，this指向全局环境（浏览器为window对象）；call方法可以改变this的指向，指定this指向对象obj，然后在对象obj的作用域中运行函数f。</p>
<p>call方法的参数，应该是一个对象。如果参数为空、null和undefined，则默认传入全局对象。</p>
<p>call方法还可以接受多个参数。</p>
<pre><code class="JS">func.call(thisValue, arg1, arg2, ...)
</code></pre>
<p>call的第一个参数就是this所要指向的那个对象，后面的参数则是函数调用时所需的参数。</p>
<pre><code class="JS">function add(a, b) {
  return a + b;
}

add.call(this, 1, 2) // 3
</code></pre>
<p>上面代码中，call方法指定函数add内部的this绑定当前环境（对象），并且参数为1和2，因此函数add运行后得到3。</p>
<h3 id="3-2-Function-prototype-apply"><a href="#3-2-Function-prototype-apply" class="headerlink" title="3.2 Function.prototype.apply()"></a>3.2 Function.prototype.apply()</h3><p>apply方法的作用与call方法类似，也是改变this指向，然后再调用该函数。唯一的区别就是，它接收一个数组作为函数执行时的参数，使用格式如下。</p>
<pre><code class="JS">func.apply(thisValue, [arg1, arg2, ...])
</code></pre>
<p>apply方法的第一个参数也是this所要指向的那个对象，如果设为null或undefined，则等同于指定全局对象。第二个参数则是一个数组，该数组的所有成员依次作为参数，传入原函数。原函数的参数，在call方法中必须一个个添加，但是在apply方法中，必须以数组形式添加。</p>
<h3 id="3-3-Function-prototype-bind"><a href="#3-3-Function-prototype-bind" class="headerlink" title="3.3 Function.prototype.bind()"></a>3.3 Function.prototype.bind()</h3><p>bind方法用于将函数体内的this绑定到某个对象，然后返回一个新函数。</p>
<pre><code class="JS">var d = new Date();
d.getTime() // 1481869925657

var print = d.getTime;
print() // Uncaught TypeError: this is not a Date object.
</code></pre>
<p>上面代码中，我们将d.getTime方法赋给变量print，然后调用print就报错了。这是因为getTime方法内部的this，绑定Date对象的实例，赋给变量print以后，内部的this已经不指向Date对象的实例了。</p>
<p>bind方法可以解决这个问题。</p>
<pre><code class="JS">var print = d.getTime.bind(d);
print() // 1481869925657
</code></pre>
<p>上面代码中，bind方法将getTime方法内部的this绑定到d对象，这时就可以安全地将这个方法赋值给其他变量了。</p>
<h4 id="bind的注意事项"><a href="#bind的注意事项" class="headerlink" title="bind的注意事项"></a>bind的注意事项</h4><h5 id="1）每一次返回一个新函数"><a href="#1）每一次返回一个新函数" class="headerlink" title="1）每一次返回一个新函数"></a>1）每一次返回一个新函数</h5><p>bind方法每运行一次，就返回一个新函数，这会产生一些问题。比如，监听事件的时候，不能写成下面这样。</p>
<pre><code class="JS">element.addEventListener(&#39;click&#39;, o.m.bind(o));
</code></pre>
<p>上面代码中，click事件绑定bind方法生成的一个匿名函数。这样会导致无法取消绑定，所以，下面的代码是无效的。</p>
<pre><code class="JS">element.removeEventListener(&#39;click&#39;, o.m.bind(o));
</code></pre>
<p>正确的方法是写成下面这样：</p>
<pre><code class="JS">var listener = o.m.bind(o);
element.addEventListener(&#39;click&#39;, listener);
//  ...
element.removeEventListener(&#39;click&#39;, listener);
</code></pre>
<h5 id="（2）结合回调函数使用"><a href="#（2）结合回调函数使用" class="headerlink" title="（2）结合回调函数使用"></a>（2）结合回调函数使用</h5><p>回调函数是 JavaScript 最常用的模式之一，但是一个常见的错误是，将包含this的方法直接当作回调函数。解决方法就是使用bind方法，将counter.inc绑定counter。</p>
<pre><code class="JS">var counter = {
  count: 0,
  inc: function () {
    &#39;use strict&#39;;
    this.count++;
  }
};

function callIt(callback) {
  callback();
}

callIt(counter.inc.bind(counter));
counter.count // 1
</code></pre>
<p>上面代码中，callIt方法会调用回调函数。这时如果直接把counter.inc传入，调用时counter.inc内部的this就会指向全局对象。使用bind方法将counter.inc绑定counter以后，就不会有这个问题，this总是指向counter。</p>
<p>还有一种情况比较隐蔽，就是某些数组方法可以接受一个函数当作参数。这些函数内部的this指向，很可能也会出错。</p>
<pre><code class="JS">var obj = {
  name: &#39;张三&#39;,
  times: [1, 2, 3],
  print: function () {
    this.times.forEach(function (n) {
      console.log(this.name);
    });
  }
};

obj.print()
// 没有任何输出
</code></pre>
<p>上面代码中，obj.print内部this.times的this是指向obj的，这个没有问题。但是，forEach方法的回调函数内部的this.name却是指向全局对象，导致没有办法取到值。稍微改动一下，就可以看得更清楚。</p>
<pre><code class="JS">obj.print = function () {
  this.times.forEach(function (n) {
    console.log(this === window);
  });
};

obj.print()
// true
// true
// true
</code></pre>
<p>解决这个问题，也是通过bind方法绑定this。</p>
<pre><code class="JS">obj.print = function () {
  this.times.forEach(function (n) {
    console.log(this.name);
  }.bind(this));
};

obj.print()
// 张三
// 张三
// 张三
</code></pre>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[函数的扩展]]></title>
      <url>/2019/03/03/ECMAScript6/%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95/</url>
      <content type="html"><![CDATA[<h2 id="1-函数参数的默认值"><a href="#1-函数参数的默认值" class="headerlink" title="1. 函数参数的默认值"></a>1. 函数参数的默认值</h2><pre><code class="JS">// 写法一
function m1({x = 0, y = 0} = {}) {
  return [x, y];
}

// 写法二
function m2({x, y} = { x: 0, y: 0 }) {
  return [x, y];
}
</code></pre>
<p>上面两种写法都对函数的参数设定了默认值，区别是写法一函数参数的默认值是空对象，但是设置了对象解构赋值的默认值；写法二函数参数的默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值。</p>
<pre><code class="JS">// 函数没有参数的情况
m1() // [0, 0]
m2() // [0, 0]

// x 和 y 都有值的情况
m1({x: 3, y: 8}) // [3, 8]
m2({x: 3, y: 8}) // [3, 8]

// x 有值，y 无值的情况
m1({x: 3}) // [3, 0]
m2({x: 3}) // [3, undefined]

// x 和 y 都无值的情况
m1({}) // [0, 0];
m2({}) // [undefined, undefined]

m1({z: 3}) // [0, 0]
m2({z: 3}) // [undefined, undefined]
</code></pre>
<h3 id="函数的-length-属性"><a href="#函数的-length-属性" class="headerlink" title="函数的 length 属性"></a>函数的 length 属性</h3><p>指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length属性将失真。</p>
<pre><code class="JS">(function (a) {}).length // 1
(function (a = 5) {}).length // 0
(function (a, b, c = 5) {}).length // 2
</code></pre>
<p>上面代码中，length属性的返回值，等于函数的参数个数减去指定了默认值的参数个数。比如，上面最后一个函数，定义了 3个参数，其中有一个参数c指定了默认值，因此length属性等于3减去1，最后得到2。</p>
<p>这是因为length属性的含义是，该函数预期传入的参数个数。某个参数指定默认值以后，预期传入的参数个数就不包括这个参数了。同理，后文的rest参数也不会计入length属性。</p>
<pre><code class="JS">(function(...args) {}).length // 0
</code></pre>
<p>如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了。</p>
<pre><code class="JS">(function (a = 0, b, c) {}).length // 0
(function (a, b = 1, c) {}).length // 1
</code></pre>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。</p>
<pre><code class="JS">var x = 1;

function foo(x = x) {
  // ...
}

foo() // ReferenceError: x is not defined
</code></pre>
<p>上面代码中，参数x=x形成一个单独作用域。实际执行的是let x = x，由于暂时性死区的原因，这行代码会报错”x 未定义“。</p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误。</p>
<pre><code class="JS">function throwIfMissing() {
  throw new Error(&#39;Missing parameter&#39;);
}

function foo(mustBeProvided = throwIfMissing()) {
  return mustBeProvided;
}

foo()
// Error: Missing parameter
</code></pre>
<p>上面代码的foo函数，如果调用的时候没有参数，就会调用默认值throwIfMissing函数，从而抛出一个错误。</p>
<p>从上面代码还可以看到，参数mustBeProvided的默认值等于throwIfMissing函数的运行结果（注意函数名throwIfMissing之后有一对圆括号），这表明参数的默认值不是在定义时执行，而是在运行时执行。如果参数已经赋值，默认值中的函数就不会运行。</p>
<h2 id="2-rest-参数"><a href="#2-rest-参数" class="headerlink" title="2. rest 参数"></a>2. rest 参数</h2><p>ES6 引入 rest 参数（形式为…变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。</p>
<pre><code class="JS">function add(...values) {
  let sum = 0;

  for (var val of values) {
    sum += val;
  }

  return sum;
}

add(2, 5, 3) // 10
</code></pre>
<p>上面代码的add函数是一个求和函数，利用 rest 参数，可以向该函数传入任意数目的参数。</p>
<h2 id="3-严格模式"><a href="#3-严格模式" class="headerlink" title="3. 严格模式"></a>3. 严格模式</h2><h2 id="4-name-属性"><a href="#4-name-属性" class="headerlink" title="4. name 属性"></a>4. name 属性</h2><h2 id="5-箭头函数"><a href="#5-箭头函数" class="headerlink" title="5. 箭头函数"></a>5. 箭头函数</h2><p>箭头函数有几个使用注意点。</p>
<p>（1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。</p>
<p>（2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。</p>
<p>（3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</p>
<p>（4）不可以使用yield命令，因此箭头函数不能用作 Generator 函数。<br>this对象的指向是可变的，但是在箭头函数中，它是固定的。 </p>
<p>箭头函数可以让setTimeout里面的this，绑定定义时所在的作用域，而不是指向运行时所在的作用域。下面是另一个例子。</p>
<pre><code class="JS">function Timer() {
  this.s1 = 0;
  this.s2 = 0;
  // 箭头函数
  setInterval(() =&gt; this.s1++, 1000);
  // 普通函数
  setInterval(function () {
    this.s2++;
  }, 1000);
}

var timer = new Timer();

setTimeout(() =&gt; console.log(&#39;s1: &#39;, timer.s1), 3100);
setTimeout(() =&gt; console.log(&#39;s2: &#39;, timer.s2), 3100);
// s1: 3
// s2: 0
</code></pre>
<p>上面代码中，Timer函数内部设置了两个定时器，分别使用了箭头函数和普通函数。前者的this绑定定义时所在的作用域（即Timer函数），后者的this指向运行时所在的作用域（即全局对象）。所以，3100 毫秒之后，timer.s1被更新了3次，而timer.s2一次都没更新。</p>
<p>this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。</p>
<p>所以，箭头函数转成 ES5 的代码如下。</p>
<pre><code class="JS">// ES6
function foo() {
  setTimeout(() =&gt; {
    console.log(&#39;id:&#39;, this.id);
  }, 100);
}

// ES5
function foo() {
  var _this = this;

  setTimeout(function () {
    console.log(&#39;id:&#39;, _this.id);
  }, 100);
}
</code></pre>
<p>上面代码中，转换后的 ES5 版本清楚地说明了，箭头函数里面根本没有自己的this，而是引用外层的this。</p>
<h3 id="不适用场合"><a href="#不适用场合" class="headerlink" title="不适用场合"></a>不适用场合</h3><p>由于箭头函数使得this从“动态”变成“静态”，下面两个场合不应该使用箭头函数。</p>
<p>第一个场合是定义函数的方法，且该方法内部包括this。</p>
<pre><code class="JS">const cat = {
  lives: 9,
  jumps: () =&gt; {
    this.lives--;
  }
}
</code></pre>
<p>上面代码中，cat.jumps()方法是一个箭头函数，这是错误的。调用cat.jumps()时，如果是普通函数，该方法内部的this指向cat；如果写成上面那样的箭头函数，使得this指向全局对象，因此不会得到预期结果。</p>
<p>第二个场合是需要动态this的时候，也不应使用箭头函数。</p>
<pre><code class="JS">var button = document.getElementById(&#39;press&#39;);
button.addEventListener(&#39;click&#39;, () =&gt; {
  this.classList.toggle(&#39;on&#39;);
});
</code></pre>
<p>上面代码运行时，点击按钮会报错，因为button的监听函数是一个箭头函数，导致里面的this就是全局对象。如果改成普通函数，this就会动态指向被点击的按钮对象。</p>
<h2 id="6-双冒号运算符"><a href="#6-双冒号运算符" class="headerlink" title="6. 双冒号运算符"></a>6. 双冒号运算符</h2><p>函数绑定运算符是并排的两个冒号（::），双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（即this对象），绑定到右边的函数上面。</p>
<pre><code class="JS">foo::bar;
// 等同于
bar.bind(foo);

foo::bar(...arguments);
// 等同于
bar.apply(foo, arguments);

const hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwn(obj, key) {
  return obj::hasOwnProperty(key);
}
</code></pre>
<p>如果双冒号左边为空，右边是一个对象的方法，则等于将该方法绑定在该对象上面。</p>
<pre><code class="JS">var method = obj::obj.foo;
// 等同于
var method = ::obj.foo;

let log = ::console.log;
// 等同于
var log = console.log.bind(console);
</code></pre>
<p>如果双冒号运算符的运算结果，还是一个对象，就可以采用链式写法。</p>
<pre><code class="JS">import { map, takeWhile, forEach } from &quot;iterlib&quot;;

getPlayers()
::map(x =&gt; x.character())
::takeWhile(x =&gt; x.strength &gt; 100)
::forEach(x =&gt; console.log(x));
</code></pre>
<h2 id="7-尾调用优化"><a href="#7-尾调用优化" class="headerlink" title="7. 尾调用优化"></a>7. 尾调用优化</h2><h3 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h3><p>函数调用自身，称为递归。如果尾调用自身，就称为尾递归。</p>
<p>递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。</p>
<pre><code class="JS">function factorial(n) {
  if (n === 1) return 1;
  return n * factorial(n - 1);
}

factorial(5) // 120
</code></pre>
<p>上面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n) 。</p>
<p>如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。</p>
<pre><code class="JS">function factorial(n, total) {
  if (n === 1) return total;
  return factorial(n - 1, n * total);
}

factorial(5, 1) // 120
</code></pre>
<p>还有一个比较著名的例子，就是计算 Fibonacci 数列，也能充分说明尾递归优化的重要性。</p>
<p>非尾递归的 Fibonacci 数列实现如下。</p>
<pre><code class="JS">function Fibonacci (n) {
  if ( n &lt;= 1 ) {return 1};

  return Fibonacci(n - 1) + Fibonacci(n - 2);
}

Fibonacci(10) // 89
Fibonacci(100) // 堆栈溢出
Fibonacci(500) // 堆栈溢出
</code></pre>
<p>尾递归优化过的 Fibonacci 数列实现如下。</p>
<pre><code class="JS">function Fibonacci2 (n , ac1 = 1 , ac2 = 1) {
  if( n &lt;= 1 ) {return ac2};

  return Fibonacci2 (n - 1, ac2, ac1 + ac2);
}

Fibonacci2(100) // 573147844013817200000
Fibonacci2(1000) // 7.0330367711422765e+208
Fibonacci2(10000) // Infinity
</code></pre>
]]></content>
      
        <categories>
            
            <category> ECMAScript 6 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ECMAScript 6 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[变量的解构赋值]]></title>
      <url>/2019/02/25/ECMAScript6/%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/</url>
      <content type="html"><![CDATA[<h2 id="1-数组的解构赋值"><a href="#1-数组的解构赋值" class="headerlink" title="1.数组的解构赋值"></a>1.数组的解构赋值</h2><h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><p>解构赋值允许指定默认值。<br>注意，ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，只有当一个数组成员严格等于undefined，默认值才会生效。</p>
<pre><code class="JS">let [x = 1] = [undefined];
x // 1

let [x = 1] = [null];
x // null
</code></pre>
<p>上面代码中，如果一个数组成员是null，默认值就不会生效，因为null不严格等于undefined。</p>
<h2 id="2-对象的解构赋值"><a href="#2-对象的解构赋值" class="headerlink" title="2.对象的解构赋值"></a>2.对象的解构赋值</h2><p>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</p>
<pre><code class="JS">let { bar, foo } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; };
foo // &quot;aaa&quot;
bar // &quot;bbb&quot;

let { baz } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; };
baz // undefined
</code></pre>
<p>上面代码的第一个例子，等号左边的两个变量的次序，与等号右边两个同名属性的次序不一致，但是对取值完全没有影响。第二个例子的变量没有对应的同名属性，导致取不到值，最后等于undefined。</p>
<p>如果变量名与属性名不一致，必须写成下面这样。</p>
<pre><code class="JS">let { foo: baz } = { foo: &#39;aaa&#39;, bar: &#39;bbb&#39; };
baz // &quot;aaa&quot;

let obj = { first: &#39;hello&#39;, last: &#39;world&#39; };
let { first: f, last: l } = obj;
f // &#39;hello&#39;
l // &#39;world&#39;
</code></pre>
<p>这实际上说明，对象的解构赋值是下面形式的简写（参见《对象的扩展》一章）。</p>
<pre><code class="JS">let { foo: foo, bar: bar } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; };
</code></pre>
<p>也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。</p>
<pre><code class="JS">let { foo: baz } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; };
baz // &quot;aaa&quot;
foo // error: foo is not defined
</code></pre>
<p>上面代码中，foo是匹配的模式，baz才是变量。真正被赋值的是变量baz，而不是模式foo。</p>
<h2 id="3-字符串的解构赋值"><a href="#3-字符串的解构赋值" class="headerlink" title="3.字符串的解构赋值"></a>3.字符串的解构赋值</h2><h2 id="4-数值和布尔值的解构赋值"><a href="#4-数值和布尔值的解构赋值" class="headerlink" title="4.数值和布尔值的解构赋值"></a>4.数值和布尔值的解构赋值</h2><h2 id="5-函数参数的解构赋值"><a href="#5-函数参数的解构赋值" class="headerlink" title="5.函数参数的解构赋值"></a>5.函数参数的解构赋值</h2><p>函数参数的解构也可以使用默认值。</p>
<pre><code class="JS">function move({x = 0, y = 0} = {}) {
  return [x, y];
}

move({x: 3, y: 8}); // [3, 8]
move({x: 3}); // [3, 0]
move({}); // [0, 0]
move(); // [0, 0]
</code></pre>
<p>上面代码中，函数move的参数是一个对象，通过对这个对象进行解构，得到变量x和y的值。如果解构失败，x和y等于默认值。</p>
<p>注意，下面的写法会得到不一样的结果。</p>
<pre><code class="JS">function move({x, y} = { x: 0, y: 0 }) {
  return [x, y];
}

move({x: 3, y: 8}); // [3, 8]
move({x: 3}); // [3, undefined]
move({}); // [undefined, undefined]
move(); // [0, 0]
</code></pre>
<p>上面代码是为函数move的参数指定默认值，而不是为变量x和y指定默认值，所以会得到与前一种写法不同的结果。</p>
<p>undefined就会触发函数参数的默认值。</p>
<pre><code class="JS">[1, undefined, 3].map((x = &#39;yes&#39;) =&gt; x);
// [ 1, &#39;yes&#39;, 3 ]
</code></pre>
<h2 id="6-圆括号问题"><a href="#6-圆括号问题" class="headerlink" title="6.圆括号问题"></a>6.圆括号问题</h2><h2 id="7-用途"><a href="#7-用途" class="headerlink" title="7.用途"></a>7.用途</h2><h3 id="（1）交换变量的值"><a href="#（1）交换变量的值" class="headerlink" title="（1）交换变量的值"></a>（1）交换变量的值</h3><h3 id="（2）从函数返回多个值"><a href="#（2）从函数返回多个值" class="headerlink" title="（2）从函数返回多个值"></a>（2）从函数返回多个值</h3><h3 id="（3）函数参数的定义"><a href="#（3）函数参数的定义" class="headerlink" title="（3）函数参数的定义"></a>（3）函数参数的定义</h3><h3 id="（4）提取-JSON-数据"><a href="#（4）提取-JSON-数据" class="headerlink" title="（4）提取 JSON 数据"></a>（4）提取 JSON 数据</h3><h3 id="（5）函数参数的默认值"><a href="#（5）函数参数的默认值" class="headerlink" title="（5）函数参数的默认值"></a>（5）函数参数的默认值</h3><pre><code class="JS">jQuery.ajax = function (url, {
  async = true,
  beforeSend = function () {},
  cache = true,
  complete = function () {},
  crossDomain = false,
  global = true,
  // ... more config
} = {}) {
  // ... do stuff
};
</code></pre>
<p>指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || ‘default foo’;这样的语句。</p>
<h3 id="（6）遍历-Map-结构"><a href="#（6）遍历-Map-结构" class="headerlink" title="（6）遍历 Map 结构"></a>（6）遍历 Map 结构</h3><pre><code class="JS">const map = new Map();
map.set(&#39;first&#39;, &#39;hello&#39;);
map.set(&#39;second&#39;, &#39;world&#39;);

for (let [key, value] of map) {
  console.log(key + &quot; is &quot; + value);
}
// first is hello
// second is world
</code></pre>
<p>如果只想获取键名，或者只想获取键值，可以写成下面这样。</p>
<pre><code class="JS">// 获取键名
for (let [key] of map) {
  // ...
}

// 获取键值
for (let [,value] of map) {
  // ...
}
</code></pre>
]]></content>
      
        <categories>
            
            <category> ECMAScript 6 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ECMAScript 6 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[let和const命令]]></title>
      <url>/2019/02/24/ECMAScript6/let%E5%92%8Cconst%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<h2 id="一、let与var的区别"><a href="#一、let与var的区别" class="headerlink" title="一、let与var的区别"></a>一、let与var的区别</h2><h3 id="1-作用域不同"><a href="#1-作用域不同" class="headerlink" title="1.作用域不同"></a>1.作用域不同</h3><p>ES6 新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。</p>
<pre><code class="JavaScript">{
  let a = 10;
  var b = 1;
}

a // ReferenceError: a is not defined.
b // 1
</code></pre>
<p>上面代码在代码块之中，分别用let和var声明了两个变量。然后在代码块之外调用这两个变量，结果let声明的变量报错，var声明的变量返回了正确的值。这表明，let声明的变量只在它所在的代码块有效。</p>
<p>下面的代码如果使用var，最后输出的是10。</p>
<pre><code class="JS">var a = [];
for (var i = 0; i &lt; 10; i++) {
  a[i] = function () {
    console.log(i);
  };
}
a[6](); // 10
</code></pre>
<p>上面代码中，变量i是var命令声明的，在全局范围内都有效，所以全局只有一个变量i。每一次循环，变量i的值都会发生改变，而循环内被赋给数组a的函数内部的console.log(i)，里面的i指向的就是全局的i。也就是说，所有数组a的成员里面的i，指向的都是同一个i，导致运行时输出的是最后一轮的i的值，也就是 10。</p>
<p>如果使用let，声明的变量仅在块级作用域内有效，最后输出的是 6。</p>
<pre><code class="JS">var a = [];
for (let i = 0; i &lt; 10; i++) {
  a[i] = function () {
    console.log(i);
  };
}
a[6](); // 6
</code></pre>
<p>上面代码中，变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是6。你可能会问，如果每一轮循环的变量i都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。</p>
<p>另外，for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。</p>
<pre><code class="JS">for (let i = 0; i &lt; 3; i++) {
  let i = &#39;abc&#39;;
  console.log(i);
}
// abc
// abc
// abc
</code></pre>
<p>上面代码正确运行，输出了 3 次abc。这表明函数内部的变量i与循环变量i不在同一个作用域，有各自单独的作用域。</p>
<h3 id="2-变量提升"><a href="#2-变量提升" class="headerlink" title="2.变量提升"></a>2.变量提升</h3><p>var命令会发生“变量提升”现象，即变量可以在声明之前使用，值为undefined。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。</p>
<p>为了纠正这种现象，let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。</p>
<pre><code class="JS">// var 的情况
console.log(foo); // 输出undefined
var foo = 2;

// let 的情况
console.log(bar); // 报错ReferenceError
let bar = 2;
</code></pre>
<h3 id="3-暂时性死区"><a href="#3-暂时性死区" class="headerlink" title="3.暂时性死区"></a>3.暂时性死区</h3><pre><code class="JS">var tmp = 123;

if (true) {
  tmp = &#39;abc&#39;; // ReferenceError
  let tmp;
}
</code></pre>
<h3 id="4-不允许重复声明"><a href="#4-不允许重复声明" class="headerlink" title="4.不允许重复声明"></a>4.不允许重复声明</h3><p>let在一个代码块中只能声明一次，var可多次声明。</p>
<ul>
<li>为什么需要块级作用域<blockquote>
<p>ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>第一种场景，内层变量可能会覆盖外层变量。</p>
</blockquote>
<pre><code class="JS">var tmp = new Date();

function f() {
  console.log(tmp);
  if (false) {
    var tmp = &#39;hello world&#39;;
  }
}

f(); // undefined
</code></pre>
<blockquote>
<p>上面代码的原意是，if代码块的外部使用外层的tmp变量，内部使用内层的tmp变量。但是，函数f执行后，输出结果为undefined，原因在于变量提升，导致内层的tmp变量覆盖了外层的tmp变量。</p>
<p>第二种场景，用来计数的循环变量泄露为全局变量。</p>
</blockquote>
<pre><code class="JS">var s = &#39;hello&#39;;

for (var i = 0; i &lt; s.length; i++) {
  console.log(s[i]);
}

console.log(i); // 5
</code></pre>
<blockquote>
<p>上面代码中，变量i只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。</p>
</blockquote>
<h2 id="二、块级作用域与函数声明"><a href="#二、块级作用域与函数声明" class="headerlink" title="二、块级作用域与函数声明"></a>二、块级作用域与函数声明</h2><p>ES6 的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错。</p>
<pre><code class="JS">// 不报错
&#39;use strict&#39;;
if (true) {
  function f() {}
}

// 报错
&#39;use strict&#39;;
if (true)
  function f() {}
</code></pre>
<h2 id="三、const"><a href="#三、const" class="headerlink" title="三、const"></a>三、const</h2><p>const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。</p>
<pre><code class="JS">const foo;
// SyntaxError: Missing initializer in const declaration
</code></pre>
<p>上面代码表示，对于const来说，只声明不赋值，就会报错。</p>
<ul>
<li>const的作用域与let命令相同：只在声明所在的块级作用域内有效。</li>
<li>const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。</li>
<li>const声明的常量，也与let一样不可重复声明。</li>
<li>const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。</li>
</ul>
<p>如果真的想将对象冻结，应该使用Object.freeze方法。</p>
<pre><code class="JS">const foo = Object.freeze({});

// 常规模式时，下面一行不起作用；
// 严格模式时，该行会报错
foo.prop = 123;
</code></pre>
<p>上面代码中，常量foo指向一个冻结的对象，所以添加新属性不起作用，严格模式时还会报错。</p>
<p>除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。</p>
<pre><code class="JS">var constantize = (obj) =&gt; {
  Object.freeze(obj);
  Object.keys(obj).forEach( (key, i) =&gt; {
    if ( typeof obj[key] === &#39;object&#39; ) {
      constantize( obj[key] );
    }
  });
};
</code></pre>
<ul>
<li>ES6 声明变量的六种方法</li>
</ul>
<p>ES5 只有两种声明变量的方法：var命令和function命令。ES6 除了添加let和const命令，后面章节还会提到，另外两种声明变量的方法：import命令和class命令。所以，ES6 一共有 6 种声明变量的方法。</p>
<h2 id="四、顶层对象的属性"><a href="#四、顶层对象的属性" class="headerlink" title="四、顶层对象的属性"></a>四、顶层对象的属性</h2><h2 id="五、global对象"><a href="#五、global对象" class="headerlink" title="五、global对象"></a>五、global对象</h2>]]></content>
      
        <categories>
            
            <category> ECMAScript 6 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ECMAScript 6 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[2018年终总结]]></title>
      <url>/2019/01/15/%E6%9D%82%E9%A1%B9/2018%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>前些日子忙考试，拖到现在才开始写2018年终总结。写个总结还是很有必要的，要不然总觉得一年就这么迷迷糊糊地过去了，总该有点仪式感的。<br>今年最大的成就应该就是考上研究生了，也算不枉费去年下半年在图书馆勤奋学习的日子，学习生涯又延长了三年。<br>考完研之后，做了个毕设，WebAR方向的，虽然很水，但还是学到了很多东西。对AR比较感兴趣，不知道以后有没有机会搞这方面的工作。<br>暑期做了个港口绩效的项目，算是数据可视化的工作，期间学习了react、material-ui、echarts、express、mysql，还有一些react组件。通过这个项目我了解了前后端的结构，数据的传输方式。开学后，接手港口地图的项目，说实话，体验不是很好。由于是两个人负责，缺少明确的分工，没有总体设计，代码过于冗杂。最难受的是，几乎所有功能全部写在同一个文件里，似乎有几千行？不但逻辑复杂，看起来难受，而且不利于模块化（高耦合），挺无语的。最终效果也很差，性能太差。其实很多方面都有不合理的设计，如果能够重构一下，肯定可以有很大提升空间的，但老师也不给时间，每周都有额外的需求，没办法，只能走一步看一步。希望这个项目快快结束。<br>研一上半年，主要还是上课，其他课都挺水，只有数据挖掘这门课学到了些东西。算是最简单的机器学习入门，做了个百万数据集的文本分类实验。下学期似乎也有两门机器学习的课，尽量入门机器视觉吧。<br>其他方面，办了健身卡，刚开始热情高昂，后面去的次数也不多，下学期还是要多健身的。感情方面，依旧单身。。。无所谓了，挣钱要紧。<br>明年只有三门课，应该会有大量空闲时间。准备找个前端实习，目前也只会前端。然后多学点后端的知识，尽量向后端迁移吧。另外，认真学英语。</p>
]]></content>
      
        <categories>
            
            <category> 杂项 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript异步机制]]></title>
      <url>/2018/12/15/JavaScript/JavaScript%E5%BC%82%E6%AD%A5%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<h2 id="JavaScript单线程"><a href="#JavaScript单线程" class="headerlink" title="JavaScript单线程"></a>JavaScript单线程</h2><p>在浏览器的一个页面中，该页面的JS程序只有一个线程，故曰单线程。因为是单线程，所以程序的执行顺序就是从上到下依次执行，同一时间内只能有一段代码被执行。  </p>
<p>虽然JavaScript是单线程的，可是浏览器内部不是单线程的。你的一些I/O操作、定时器的计时和事件监听（click, keydown…）等都是由浏览器提供的其他线程来完成的。</p>
<p>如果想利用多线程处理一些耗时较长的任务，可以使用HTML5提出的Web Worker。</p>
<h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><p>一个js程序的单线程用来执行栈中的同步任务，当所有同步任务执行完毕后，栈被清空，然后读取任务队列中的一个待处理任务，并把相关回调函数压入栈中，单线程开始执行新的同步任务，执行完毕。</p>
<p>单线程从任务队列中读取任务是不断循环的，每次栈被清空后，都会在任务队列中读取新的任务，如果没有新的任务，就会等待，直到有新的任务，这就叫任务循环。因为每个任务都由一个事件所触发，所以也叫事件循环。</p>
<h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p>setTimeout的作用是在间隔一定的时间后，将回调函数插入任务队列中，等栈中的同步任务都执行完毕后，再执行。因为栈中的同步任务也会耗时，所以间隔的时间一般会大于等于指定的时间。  </p>
<p>setTimeout(fn, 0)的意思是，将回调函数fn立刻插入任务队列，等待执行，而不是立即执行。看一个例子：  </p>
<pre><code class="JaveScript">setTimeout(function() {
    console.log(&quot;a&quot;)
}, 0)
for(let i=0; i&lt;10000; i++) {}
console.log(&quot;b&quot;)
// 结果：b  a
</code></pre>
<p>打印结果表明回调函数并没有立刻执行，而是等待栈中的任务执行完毕后才执行的。栈中的任务执行多久，它就得等多久。</p>
<h2 id="第一个例子（async-await）"><a href="#第一个例子（async-await）" class="headerlink" title="第一个例子（async/await）"></a>第一个例子（async/await）</h2><pre><code class="JavaScript">function resolveAfter2Seconds() {
    console.log(&#39;resolve start&#39;);
    return new Promise(resolve =&gt; {
        setTimeout(() =&gt; {
        resolve(&#39;resolved&#39;);
        }, 2000);
    });
}

async function asyncCall() {
    console.log(&#39;calling&#39;);
    var result = await resolveAfter2Seconds();
    console.log(result);
    // expected output: &#39;resolved&#39;
}

asyncCall();
console.log(&#39;end&#39;);
</code></pre>
<p>执行结果如下：</p>
<pre><code>calling
resolve start
end
resolved
</code></pre><p>只有async function（异步函数）中才可以使用关键字await。 </p>
<p>异步函数asyncCall()执行时首先输出’calling’，遇到await会执行await紧跟着的函数resolveAfter2Seconds()（一般是异步函数）,将resolveAfter2Seconds()中的函数先执行一遍，输出’resolve start’，然后等待Promise的结束。此时跟await处于同一级的之后的函数不会执行，而是跳出整个async函数，接着往后执行，输出’end’。整个程序执行完会返回async函数内部，等待await的结果，并继续执行await后面的函数，输出’resolved’。</p>
<blockquote>
<p>很多人以为await会一直等待之后的表达式执行完之后才会继续执行后面的代码，实际上await是一个让出线程的标志。await后面的函数会先执行一遍，然后就会跳出整个async函数来执行后面js栈（后面会详述）的代码。等本轮事件循环执行完了之后又会跳回到async函数中等待await。<br>后面表达式的返回值，如果返回值为非promise则继续执行async函数后面的代码，否则将返回的promise放入promise队列（Promise的Job Queue）</p>
</blockquote>
<h2 id="第二个例子（await-promise）"><a href="#第二个例子（await-promise）" class="headerlink" title="第二个例子（await/promise）"></a>第二个例子（await/promise）</h2><pre><code class="JavaScript">function testSometing() {
    console.log(&quot;执行testSometing&quot;);
    return &quot;testSometing&quot;;
}

async function testAsync() {
    console.log(&quot;执行testAsync&quot;);
    return Promise.resolve(&quot;hello async&quot;);
}

async function test() {
    console.log(&quot;test start...&quot;);
    const v1 = await testSometing();//关键点1
    console.log(v1);
    const v2 = await testAsync();
    console.log(v2);
    console.log(v1, v2);
}

test();

var promise = new Promise((resolve)=&gt; { console.log(&quot;promise start..&quot;); resolve(&quot;promise&quot;);});//关键点2
promise.then((val)=&gt; console.log(val));

console.log(&quot;test end...&quot;)
</code></pre>
<p>输出结果如下：</p>
<pre><code>test start...
执行testSometing
promise start..
test end...
testSometing
执行testAsync
promise
hello async
testSometing hello async
</code></pre><h2 id="第三个例子（最完整详细）"><a href="#第三个例子（最完整详细）" class="headerlink" title="第三个例子（最完整详细）"></a>第三个例子（最完整详细）</h2><pre><code class="JavaScript">var resolveAfter2Seconds = function() {
    console.log(&quot;starting slow promise&quot;);
    return new Promise(resolve =&gt; {
        console.log(&#39;set timer20&#39;);
        setTimeout(function() {
            resolve(20);
            console.log(&quot;slow promise is done&quot;);
        }, 2000);
    });
};

var resolveAfter1Second = function() {
    console.log(&quot;starting fast promise&quot;);
    return new Promise(resolve =&gt; {
        console.log(&#39;set timer10&#39;);
        setTimeout(function() {
            resolve(10);
            console.log(&quot;fast promise is done&quot;);
        }, 1000);
    });
};

var no = function () {
    console.log(&#39;==nothing==&#39;)
    const slow = resolveAfter2Seconds();
    const fast = resolveAfter1Second();
    console.log(slow);
    console.log(fast);
}

var sequentialStart = async function() {
    console.log(&#39;==SEQUENTIAL START==&#39;);

    // If the value of the expression following the await operator is not a Promise, it&#39;s converted to a resolved Promise.
    const slow = await resolveAfter2Seconds();

    const fast = await resolveAfter1Second();
    console.log(slow);
    console.log(fast);
}

var concurrentStart = async function() {
    console.log(&#39;==CONCURRENT START with await==&#39;);
    const slow = resolveAfter2Seconds(); // starts timer immediately
    const fast = resolveAfter1Second();
    console.log(&#39;waitting...&#39;);
    console.log(await slow);
    console.log(await fast); // waits for slow to finish, even though fast is already done!
}

var stillConcurrent = function() {
    console.log(&#39;==CONCURRENT START with Promise.all==&#39;);
    Promise.all([resolveAfter2Seconds(), resolveAfter1Second()]).then((messages) =&gt; {
        console.log(messages[0]); // slow
        console.log(messages[1]); // fast
    });
}

var parallel = function() {
    console.log(&#39;==PARALLEL with Promise.then==&#39;);
    resolveAfter2Seconds().then(function (){console.log(&#39;1&#39;)});
    resolveAfter1Second().then(function (){console.log(&#39;2&#39;)});
}

sequentialStart(); // after 2 seconds, logs &quot;slow&quot;, then after 1 more second, &quot;fast&quot;
// wait above to finish
setTimeout(concurrentStart, 4000); // after 2 seconds, logs &quot;slow&quot; and then &quot;fast&quot;
// wait again
setTimeout(stillConcurrent, 7000); // same as concurrentStart
// wait again
setTimeout(parallel, 10000); // trully parallel: after 1 second, logs &quot;fast&quot;, then after 1 more second, &quot;slow&quot;

setTimeout(no, 13000);
</code></pre>
<p>结果如下：</p>
<pre><code>==SEQUENTIAL START==
starting slow promise
set timer20
slow promise is done
starting fast promise
set timer10
fast promise is done
20
10
==CONCURRENT START with await==
starting slow promise
set timer20
starting fast promise
set timer10
waitting...
fast promise is done
slow promise is done
20
10
==CONCURRENT START with Promise.all==
starting slow promise
set timer20
starting fast promise
set timer10
fast promise is done
slow promise is done
20
10
==PARALLEL with Promise.then==
starting slow promise
set timer20
starting fast promise
set timer10
fast promise is done
2
slow promise is done
1
==nothing==
starting slow promise
set timer20
starting fast promise
set timer10
Promise { &lt;pending&gt; }
Promise { &lt;pending&gt; }
fast promise is done
slow promise is done
sunyangdeMacBook-Pro:~ sunyang$ node test.js
==SEQUENTIAL START==
starting slow promise
set timer20
slow promise is done
starting fast promise
set timer10
fast promise is done
20
10
==CONCURRENT START with await==
starting slow promise
set timer20
starting fast promise
set timer10
waitting...
fast promise is done
slow promise is done
20
10
==CONCURRENT START with Promise.all==
starting slow promise
set timer20
starting fast promise
set timer10
fast promise is done
slow promise is done
20
10
==PARALLEL with Promise.then==
starting slow promise
set timer20
starting fast promise
set timer10
fast promise is done
2
slow promise is done
1
==nothing==
starting slow promise
set timer20
starting fast promise
set timer10
Promise { &lt;pending&gt; }
Promise { &lt;pending&gt; }
fast promise is done
slow promise is done
</code></pre><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><blockquote>
<ol>
<li><a href="https://segmentfault.com/a/1190000011296839" target="_blank" rel="external">async/await 执行顺序详解</a>  </li>
<li><a href="https://juejin.im/entry/57b2827f165abd005434c59e" target="_blank" rel="external">JavaScript 单线程和异步机制</a>  </li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function" target="_blank" rel="external">async function MDN</a></li>
</ol>
</blockquote>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python学习笔记之函数]]></title>
      <url>/2018/11/15/Python/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<h2 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h2><p>Python内置的常用函数还包括数据类型转换函数，比如int()函数可以把其他数据类型转换为整数： </p>
<pre><code class="python">&gt;&gt;&gt; int(&#39;123&#39;) 
123 
&gt;&gt;&gt; int(12.34) 
12 
&gt;&gt;&gt; float(&#39;12.34&#39;) 
12.34 
&gt;&gt;&gt; str(1.23) 
&#39;1.23&#39; 
&gt;&gt;&gt; str(100) 
&#39;100&#39; 
&gt;&gt;&gt; bool(1) 
True 
&gt;&gt;&gt; bool(&#39;&#39;) 
False
</code></pre>
<p>函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”： </p>
<pre><code class="python">&gt;&gt;&gt; a = abs # 变量a指向abs函数 
&gt;&gt;&gt; a(-1) # 所以也可以通过a调用abs函数 
1
</code></pre>
<h2 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h2><p>在Python中，定义一个函数要使用def语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用return语句返回。<br>如果你已经把my_abs()的函数定义保存为abstest.py文件了，那么，可以在该文件的当前目录下启动Python解释器，用from abstest import my_abs来导入my_abs()函数，注意abstest是文件名（不含.py扩展名）。  </p>
<h3 id="空函数"><a href="#空函数" class="headerlink" title="空函数"></a>空函数</h3><p>如果想定义一个什么事也不做的空函数，可以用pass语句： </p>
<pre><code class="python">def nop(): 
    pass
</code></pre>
<p>pass语句什么都不做，那有什么用？实际上pass可以用来作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个pass，让代码能运行起来。<br>pass还可以用在其他语句里，比如： </p>
<pre><code class="python">if age &gt;= 18: 
    pass
</code></pre>
<p>缺少了pass，代码运行就会有语法错误。<br>对参数类型做检查，只允许整数和浮点数类型的参数。数据类型检查可以用内置函数isinstance()实现： </p>
<pre><code class="python">def my_abs(x): 
    if not isinstance(x, (int, float)): 
        raise TypeError(&#39;bad operand type&#39;) 
    if x &gt;= 0: 
        return x 
    else: 
        return -x
</code></pre>
<h3 id="返回多个值"><a href="#返回多个值" class="headerlink" title="返回多个值"></a>返回多个值</h3><p>函数可以返回多个值吗？答案是肯定的。 比如在游戏中经常需要从一个点移动到另一个点，给出坐标、位移和角度，就可以计算出新的新的坐标： </p>
<pre><code class="python">import math 
def move(x, y, step, angle=0): 
    nx = x + step * math.cos(angle) 
    ny = y - step * math.sin(angle) 
    return nx, ny
</code></pre>
<p>import math语句表示导入math包，并允许后续代码引用math包里的sin、cos等函数。 然后，我们就可以同时获得返回值： </p>
<pre><code class="python">&gt;&gt;&gt; x, y = move(100, 100, 60, math.pi / 6) 
&gt;&gt;&gt; print(x, y) 
151.96152422706632 70.0
</code></pre>
<p>但其实这只是一种假象，Python函数返回的仍然是单一值： </p>
<pre><code class="python">&gt;&gt;&gt; r = move(100, 100, 60, math.pi / 6) 
&gt;&gt;&gt; print(r) 
(151.96152422706632, 70.0)
</code></pre>
<p>原来返回值是一个tuple！但是，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。</p>
<h2 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h2><p><strong>非常重要！！！</strong></p>
<p><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431752945034eb82ac80a3e64b9bb4929b16eeed1eb9000" target="_blank" rel="external">https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431752945034eb82ac80a3e64b9bb4929b16eeed1eb9000</a></p>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[macos快捷键]]></title>
      <url>/2018/11/12/%E6%9D%82%E9%A1%B9/macos%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      <content type="html"><![CDATA[<h2 id="macos"><a href="#macos" class="headerlink" title="macos"></a>macos</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>复制文件路径</td>
<td>command + option + c</td>
</tr>
<tr>
<td>剪切(将文件移动到这里)</td>
<td>command + option + v</td>
</tr>
<tr>
<td>左右切换窗口</td>
<td>control + 左右箭头</td>
</tr>
<tr>
<td>强制退出</td>
<td>command + option + esc</td>
</tr>
<tr>
<td>查看文件属性（显示简介）</td>
<td>command + i</td>
</tr>
<tr>
<td>emoji 表情</td>
<td>control + command + 空格</td>
</tr>
<tr>
<td>打开访达</td>
<td>command + option + 空格</td>
</tr>
<tr>
<td>显示隐藏文件</td>
<td>command + shift + .</td>
</tr>
<tr>
<td>删除光标后的内容</td>
<td>fn + delete</td>
</tr>
</tbody>
</table>
<h2 id="chrome"><a href="#chrome" class="headerlink" title="chrome"></a>chrome</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>切换标签页</td>
<td>command + option + 左右箭头</td>
</tr>
<tr>
<td>打开开发者工具</td>
<td>command + option + i</td>
</tr>
<tr>
<td>重新加载当前网页</td>
<td>command + shift + r</td>
</tr>
<tr>
<td>在新标签页中打开链接，并跳转到该标签页</td>
<td>按住 command + shift 键的同时点击链接</td>
</tr>
</tbody>
</table>
<h2 id="terminal"><a href="#terminal" class="headerlink" title="terminal"></a>terminal</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>brew outdated</td>
<td>查看需要更新的应用</td>
</tr>
<tr>
<td>brew update (应用名)</td>
<td>更新所有（某个）应用</td>
</tr>
<tr>
<td>brew home (应用名)</td>
<td>访问应用官网</td>
</tr>
</tbody>
</table>
<h2 id="cmd-h-与-cmd-m-的区别"><a href="#cmd-h-与-cmd-m-的区别" class="headerlink" title="cmd + h 与 cmd + m 的区别"></a>cmd + h 与 cmd + m 的区别</h2><p>cmd+m最小化当前窗口<br>cmd+h隐藏当前程序<br>cmd+h后用cmd+tab可以快速切换回来，但是cmd+m不能快速呈现，需要cmd+tab选取好相应的应用程序 在按住cmd的同时 按option然后松开cmd和option才能恢复窗口。</p>
<h2 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>光标左移</td>
<td>ctrl + b</td>
</tr>
<tr>
<td>光标右移</td>
<td>ctrl + f</td>
</tr>
<tr>
<td>光标移到行首</td>
<td>ctrl + a</td>
</tr>
<tr>
<td>光标移到行尾</td>
<td>ctrl + e</td>
</tr>
<tr>
<td>光标上移</td>
<td>ctrl + p</td>
</tr>
<tr>
<td>光标下移</td>
<td>ctrl + n</td>
</tr>
</tbody>
</table>
]]></content>
      
        <categories>
            
            <category> 杂项 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> macos </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python学习笔记之Python基础]]></title>
      <url>/2018/11/10/Python/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BPython%E5%9F%BA%E7%A1%80/</url>
      <content type="html"><![CDATA[<h2 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h2><p>print()函数也可以接受多个字符串，用逗号“,”隔开，就可以连成一串输出。<br>print()会依次打印每个字符串，遇到逗号“,”会输出一个空格。<br>name = input()<br>input()可以让你显示一个字符串来提示用户。  </p>
<h2 id="数据类型和变量"><a href="#数据类型和变量" class="headerlink" title="数据类型和变量"></a>数据类型和变量</h2><p>字符串是以单引号’或双引号”括起来的任意文本。<br>如果字符串内部既包含’又包含”怎么办？可以用转义字符\来标识。<br>Python还允许用r’’表示’’内部的字符串默认不转义。<br>Python允许用’’’…’’’的格式表示多行内容 。 </p>
<pre><code class="python">print(&#39;&#39;&#39;line1 
line2 
line3&#39;&#39;&#39;)
</code></pre>
<p>空值是Python里一个特殊的值，用None表示。<br>这种变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。例如Java是静态语言。<br>/除法计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数。<br>//除法只取结果的整数部分。<br>Python的整数没有大小限制，而某些语言的整数根据其存储长度是有大小限制的，例如Java对32位整数的范围限制在-2147483648-2147483647  </p>
<h2 id="字符串和编码"><a href="#字符串和编码" class="headerlink" title="字符串和编码"></a>字符串和编码</h2><p>ASCII编码是1个字节，而Unicode编码通常是2个字节。<br>如果把ASCII编码的A用Unicode编码，只需要在前面补0就可以，因此，A的Unicode编码是00000000 01000001<br>如果你写的文本基本上全部是英文的话，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。<br>又出现了把Unicode编码转化为“可变长编码”的UTF-8编码。<br>UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节。<br>大量只支持ASCII编码的历史遗留软件可以在UTF-8编码下继续工作。<br>Python 3版本中，字符串是以Unicode编码的。<br>ord()函数获取字符的整数表示，chr()函数把编码转换为对应的字符。<br>如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的bytes。<br>以Unicode表示的str通过encode()方法可以编码为指定的bytes。<br>Python对bytes类型的数据用带b前缀的单引号或双引号表示。<br>反过来，如果我们从网络或磁盘上读取了字节流，那么读到的数据就是bytes。要把bytes变为str，就需要用decode()方法：<br>要注意区分’ABC’和b’ABC’，前者是str，后者虽然内容显示得和前者一样，但bytes的每个字符都只占用一个字节。<br>如果bytes中只有一小部分无效的字节，可以传入errors=’ignore’忽略错误的字节。<br>纯英文的str可以用ASCII编码为bytes，内容是一样的，含有中文的str可以用UTF-8编码为bytes。含有中文的str无法用ASCII编码，因为中文编码的范围超过了ASCII编码的范围，Python会报错。<br>要计算str包含多少个字符，可以用len()函数。<br>len()函数计算的是str的字符数，如果换成bytes，len()函数就计算字节数。<br>如果.py文件本身使用UTF-8编码，并且也申明了# -<em>- coding: utf-8 -</em>-，打开命令提示符测试就可以正常显示中文。<br>在Python中，采用的格式化方式和C语言是一致的，用%实现。<br>如果只有一个%?，括号可以省略。<br>占位符 替换内容 %d 整数 %f 浮点数 %s 字符串 %x 十六进制整数。<br>如果你不太确定应该用什么，%s永远起作用，它会把任何数据类型转换为字符串。<br>有些时候，字符串里面的%是一个普通字符怎么办？这个时候就需要转义，用%%来表示一个% 。 </p>
<h2 id="使用list和tuple"><a href="#使用list和tuple" class="headerlink" title="使用list和tuple"></a>使用list和tuple</h2><p>list是一种有序的集合。<br>用len()函数可以获得list元素的个数。<br>如果要取最后一个元素，除了计算索引位置外，还可以用-1做索引，直接获取最后一个元素。<br>以此类推，可以获取倒数第2个、倒数第3个  </p>
<pre><code class="python">&gt;&gt;&gt; classmates[-2] 
&#39;Bob&#39;
</code></pre>
<p>可以往list中追加元素到末尾  </p>
<pre><code class="python">classmates.append(&#39;Adam&#39;)
</code></pre>
<p>可以把元素插入到指定的位置，比如索引号为1的位置  </p>
<pre><code class="python">classmates.insert(1, &#39;Jack&#39;)
</code></pre>
<p>要删除list末尾的元素，用pop()方法  </p>
<pre><code class="python">classmates.pop()
</code></pre>
<p>要删除指定位置的元素，用pop(i)方法，其中i是索引位置<br>要把某个元素替换成别的元素，可以直接赋值给对应的索引位置<br>list里面的元素的数据类型也可以不同<br>另一种有序列表叫元组：tuple。tuple和list非常类似，但是tuple一旦初始化就不能修改<br>它也没有append()，insert()这样的方法。其他获取元素的方法和list是一样的，你可以正常地使用classmates[0]，classmates[-1]，但不能赋值成另外的元素。<br>要定义一个只有1个元素的tuple，如果你这么定义：  </p>
<pre><code class="python">&gt;&gt;&gt; t = (1) 
&gt;&gt;&gt; t 
1
</code></pre>
<p>定义的不是tuple，是1这个数！这是因为括号()既可以表示tuple，又可以表示数学公式中的小括号，这就产生了歧义，因此，Python规定，这种情况下，按小括号进行计算，计算结果自然是1。 所以，只有1个元素的tuple定义时必须加一个逗号,，来消除歧义： </p>
<pre><code class="python">&gt;&gt;&gt; t = (1,) 
&gt;&gt;&gt; t 
(1,)
</code></pre>
<p>tuple所谓的“不变”是说，tuple的每个元素，指向永远不变。即指向’a’，就不能改成指向’b’，指向一个list，就不能改成指向其他对象，但指向的这个list本身是可变的！</p>
<h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><p>elif是else if的缩写，完全可以有多个elif，所以if语句的完整形式就是： </p>
<pre><code class="python">if &lt;条件判断1&gt;: 
    &lt;执行1&gt; 
elif &lt;条件判断2&gt;: 
    &lt;执行2&gt; 
elif &lt;条件判断3&gt;: 
    &lt;执行3&gt; 
else: 
    &lt;执行4&gt;
</code></pre>
<p>input()返回的数据类型是str，str不能直接和整数比较，必须先把str转换成整数</p>
<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p>for…in循环，依次把list或tuple中的每个元素迭代出来，看例子： </p>
<pre><code class="python">names = [&#39;Michael&#39;, &#39;Bob&#39;, &#39;Tracy&#39;] 
for name in names: 
    print(name)
</code></pre>
<p>如果要计算1-100的整数之和，从1写到100有点困难，幸好Python提供一个range()函数，可以生成一个整数序列，再通过list()函数可以转换为list。比如range(5)生成的序列是从0开始小于5的整数： </p>
<pre><code class="python">&gt;&gt;&gt; list(range(5)) 
[0, 1, 2, 3, 4]
</code></pre>
<p>在循环过程中，也可以通过continue语句，跳过当前的这次循环，直接开始下一次循环。</p>
<h2 id="使用dict和set"><a href="#使用dict和set" class="headerlink" title="使用dict和set"></a>使用dict和set</h2><p>Python内置了字典：dict的支持，dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。<br>由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉： </p>
<pre><code class="python">&gt;&gt;&gt; d[&#39;Jack&#39;] = 90 
&gt;&gt;&gt; d[&#39;Jack&#39;] 
90 
&gt;&gt;&gt; d[&#39;Jack&#39;] = 88 
&gt;&gt;&gt; d[&#39;Jack&#39;] 
88
</code></pre>
<p>如果key不存在，dict就会报错： </p>
<pre><code class="python">&gt;&gt;&gt; d[&#39;Thomas&#39;] 
Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; KeyError: &#39;Thomas&#39;
</code></pre>
<p>要避免key不存在的错误，有两种办法，一是通过in判断key是否存在： </p>
<pre><code class="python">&gt;&gt;&gt; &#39;Thomas&#39; in d 
False
</code></pre>
<p>二是通过dict提供的get()方法，如果key不存在，可以返回None，或者自己指定的value：</p>
<pre><code class="python"> &gt;&gt;&gt; d.get(&#39;Thomas&#39;) 
 &gt;&gt;&gt; d.get(&#39;Thomas&#39;, -1) 
 -1
</code></pre>
<p>要删除一个key，用pop(key)方法，对应的value也会从dict中删除<br>dict的key必须是不可变对象。<br>在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而list是可变的，就不能作为key。<br>set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。<br>要创建一个set，需要提供一个list作为输入集合： </p>
<pre><code class="python">&gt;&gt;&gt; s = set([1, 2, 3]) 
&gt;&gt;&gt; s 
{1, 2, 3}
</code></pre>
<p>注意，传入的参数[1, 2, 3]是一个list，而显示的{1, 2, 3}只是告诉你这个set内部有1，2，3这3个元素，显示的顺序也不表示set是有序的。<br>重复元素在set中自动被过滤： </p>
<pre><code class="python">&gt;&gt;&gt; s = set([1, 1, 2, 2, 3, 3]) 
&gt;&gt;&gt; s 
{1, 2, 3}
</code></pre>
<p>通过add(key)方法可以添加元素到set中，可以重复添加，但不会有效果。<br>通过remove(key)方法可以删除元素。<br>set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作： </p>
<pre><code class="python">&gt;&gt;&gt; s1 = set([1, 2, 3]) 
&gt;&gt;&gt; s2 = set([2, 3, 4]) 
&gt;&gt;&gt; s1 &amp; s2 
{2, 3} 
&gt;&gt;&gt; s1 | s2 
{1, 2, 3, 4}
</code></pre>
<p>set和dict的唯一区别仅在于没有存储对应的value，但是，set的原理和dict一样，所以，同样不可以放入可变对象，因为无法判断两个可变对象是否相等，也就无法保证set内部“不会有重复元素”。<br>对于可变对象，比如list，对list进行操作，list内部的内容是会变化的，比如： </p>
<pre><code class="python">&gt;&gt;&gt; a = [&#39;c&#39;, &#39;b&#39;, &#39;a&#39;] 
&gt;&gt;&gt; a.sort() 
&gt;&gt;&gt; a 
[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]
</code></pre>
<p>而对于不可变对象，比如str，对str进行操作呢： </p>
<pre><code class="python">&gt;&gt;&gt; a = &#39;abc&#39; 
&gt;&gt;&gt; a.replace(&#39;a&#39;, &#39;A&#39;) 
&#39;Abc&#39; 
&gt;&gt;&gt; a 
&#39;abc&#39;
</code></pre>
<p>虽然字符串有个replace()方法，也确实变出了’Abc’，但变量a最后仍是’abc’，应该怎么理解呢？<br>我们先把代码改成下面这样： </p>
<pre><code class="python">&gt;&gt;&gt; a = &#39;abc&#39; 
&gt;&gt;&gt; b = a.replace(&#39;a&#39;, &#39;A&#39;) 
&gt;&gt;&gt; b 
&#39;Abc&#39; 
&gt;&gt;&gt; a 
&#39;abc&#39;
</code></pre>
<p>要始终牢记的是，a是变量，而’abc’才是字符串对象！有些时候，我们经常说，对象a的内容是’abc’，但其实是指，a本身是一个变量，它指向的对象的内容才是’abc’。<br>当我们调用a.replace(‘a’, ‘A’)时，实际上调用方法replace是作用在字符串对象’abc’上的，而这个方法虽然名字叫replace，但却没有改变字符串’abc’的内容。相反，replace方法创建了一个新字符串’Abc’并返回，如果我们用变量b指向该新字符串，就容易理解了，变量a仍指向原有的字符串’abc’，但变量b却指向新字符串’Abc’了。<br>所以，对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容。相反，这些方法会创建新的对象并返回，这样，就保证了不可变对象本身永远是不可变的。</p>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[2018北邮网研复试机试试题]]></title>
      <url>/2018/03/29/%E6%9D%82%E9%A1%B9/2018%E5%8C%97%E9%82%AE%E7%BD%91%E7%A0%94%E5%A4%8D%E8%AF%95%E6%9C%BA%E8%AF%95%E8%AF%95%E9%A2%98/</url>
      <content type="html"><![CDATA[<h1 id="2018北邮网研复试机试试题"><a href="#2018北邮网研复试机试试题" class="headerlink" title="2018北邮网研复试机试试题"></a>2018北邮网研复试机试试题</h1><h2 id="1-计算商品价格"><a href="#1-计算商品价格" class="headerlink" title="1. 计算商品价格"></a>1. 计算商品价格</h2><p>每组数据输入整数n，代表共有n种商品。<br>然后输入n行数据，每行两个数a,b,分别代表商品单价及数量。<br>对于每组数据，输出总价。</p>
<h2 id="2-V形结构"><a href="#2-V形结构" class="headerlink" title="2. V形结构"></a>2. V形结构</h2><p>一个字符串a中若存在三元组（x,y,z）满足x<y<z,a[x]>a[y],a[y]&lt;a[z]。则称三元组为一个V形结构。<br>输入整数T,代表一共T个字符串。<br>输入T个字符串。<br>输出每个字符串含有的V形结构个数。</y<z,a[x]></p>
<h2 id="3-24点游戏"><a href="#3-24点游戏" class="headerlink" title="3. 24点游戏"></a>3. 24点游戏</h2><p>输入四个实数a,b,c,d,若a^ b ^ c^d=24,则输出YES，否则输出NO。<br>^代表+、-、*、/的任意一种。</p>
<h2 id="4-忘了题目"><a href="#4-忘了题目" class="headerlink" title="4. 忘了题目"></a>4. 忘了题目</h2><p>每种零件都有最适宜温度区间[li,ri]，0<li<ri<10^9 当温度低于li，得分为x；当温度高于ri，得分为z；当温度在适宜区间内，得分y;="" y="">x,y&gt;z。<br>输入n种零件的适宜温度区间，输出n种零件的得分总和的最大值。(1&lt;n&lt;20000)</li<ri<10^9></p>
]]></content>
      
        <categories>
            
            <category> 杂项 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Markdown语法]]></title>
      <url>/2017/10/01/%E6%9D%82%E9%A1%B9/Markdown%E8%AF%AD%E6%B3%95/</url>
      <content type="html"><![CDATA[<h2 id="1-标题"><a href="#1-标题" class="headerlink" title="1. 标题"></a>1. 标题</h2><p>两种形式：<br>1）使用<code>=</code>和<code>-</code>标记一级和二级标题。</p>
<blockquote>
<p>一级标题<br><code>=========</code><br>二级标题<br><code>---------</code></p>
</blockquote>
<p>效果：</p>
<blockquote>
<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题   "></a>一级标题   </h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2></blockquote>
<p>2）使用<code>#</code>，可表示1-6级标题。</p>
<blockquote>
<p># 一级标题<br>## 二级标题<br>### 三级标题<br>#### 四级标题<br>##### 五级标题<br>###### 六级标题    </p>
</blockquote>
<p>效果：</p>
<blockquote>
<h1 id="一级标题-1"><a href="#一级标题-1" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题-1"><a href="#二级标题-1" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6></blockquote>
<h2 id="2-段落"><a href="#2-段落" class="headerlink" title="2. 段落"></a>2. 段落</h2><p>段落的前后要有空行，所谓的空行是指没有文字内容。若想在段内强制换行的方式是使用<strong>两个以上</strong>空格加上回车（引用中换行省略回车）。</p>
<h2 id="3-区块引用"><a href="#3-区块引用" class="headerlink" title="3. 区块引用"></a>3. 区块引用</h2><p>在段落的每行或者只在第一行使用符号<code>&gt;</code>,还可使用多个嵌套引用，如：</p>
<blockquote>
<p>> 区块引用<br>>&gt; 嵌套引用  </p>
</blockquote>
<p>效果：</p>
<blockquote>
<p>区块引用  </p>
<blockquote>
<p>嵌套引用</p>
</blockquote>
</blockquote>
<h2 id="4-代码区块"><a href="#4-代码区块" class="headerlink" title="4. 代码区块"></a>4. 代码区块</h2><p>代码区块的建立是在每行加上4个空格或者一个制表符（如同写代码一样）。如<br>普通段落：</p>
<p>void main()<br>{<br>    printf(“Hello, Markdown.”);<br>}    </p>
<p>代码区块：</p>
<pre><code>void main()
{
    printf(&quot;Hello, Markdown.&quot;);
}
</code></pre><p><strong>注意</strong>:需要和普通段落之间存在空行。</p>
<h2 id="5-强调"><a href="#5-强调" class="headerlink" title="5. 强调"></a>5. 强调</h2><p>在强调内容两侧分别加上<code>*</code>或者<code>_</code>，如：</p>
<blockquote>
<p>*斜体*，_斜体_<br>**粗体**，__粗体__</p>
</blockquote>
<p>效果：</p>
<blockquote>
<p><em>斜体</em>，<em>斜体</em><br><strong>粗体</strong>，<strong>粗体</strong></p>
</blockquote>
<h2 id="6-列表"><a href="#6-列表" class="headerlink" title="6. 列表"></a>6. 列表</h2><p>使用<code>·</code>、<code>+</code>、或<code>-</code>标记无序列表，如：</p>
<blockquote>
<p>-（+*） 第一项<br>-（+*） 第二项<br>- （+*）第三项</p>
</blockquote>
<p><strong>注意</strong>：标记后面最少有一个<em>空格</em>或<em>制表符</em>。若不在引用区块中，必须和前方段落之间存在空行。</p>
<p>效果：</p>
<blockquote>
<ul>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ul>
</blockquote>
<p>有序列表的标记方式是将上述的符号换成数字,并辅以<code>.</code>，如：</p>
<blockquote>
<p>1 . 第一项<br>2 . 第二项<br>3 . 第三项    </p>
</blockquote>
<p>效果：</p>
<blockquote>
<ol>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ol>
</blockquote>
<h2 id="7-分割线"><a href="#7-分割线" class="headerlink" title="7. 分割线"></a>7. 分割线</h2><p>分割线最常使用就是三个或以上<code>*</code>，还可以使用<code>-</code>和<code>_</code>。</p>
<p>效果：</p>
<blockquote>
<hr>
</blockquote>
<h2 id="8-链接"><a href="#8-链接" class="headerlink" title="8. 链接"></a>8. 链接</h2><p>链接可以由两种形式生成：<strong>行内式</strong>和<strong>参考式</strong>。<br><strong>行内式</strong>：</p>
<blockquote>
<p>[轩箫的博客](<a href="https://sunyang.xyz">https://sunyang.xyz</a> “轩箫”)。</p>
</blockquote>
<p>效果：</p>
<blockquote>
<p><a href="https://sunyang.xyz" title="轩箫">轩箫的博客</a>。</p>
</blockquote>
<p><strong>参考式</strong>：</p>
<blockquote>
<p>[轩箫的博客1][1]<br>[轩箫的博客2][2]<br>[1]:<a href="https://sunyang.xyz">https://sunyang.xyz</a> “轩箫”<br>[2]:<a href="https://sunyang.xyz">https://sunyang.xyz</a> “轩箫”</p>
</blockquote>
<p>效果：</p>
<blockquote>
<p><a href="https://sunyang.xyz" title="轩箫">轩箫的博客1</a><br><a href="https://sunyang.xyz" title="轩箫">轩箫的博客2</a></p>
</blockquote>
<p><strong>注意</strong>：上述的<code>[1]:https://sunyang.xyz &quot;轩箫&quot;</code>不出现在区块中。</p>
<h2 id="9-图片"><a href="#9-图片" class="headerlink" title="9. 图片"></a>9. 图片</h2><p>添加图片的形式和链接相似，只需在链接的基础上前方加一个<code>！</code>。</p>
<h2 id="10-反斜杠"><a href="#10-反斜杠" class="headerlink" title="10. 反斜杠\"></a>10. 反斜杠<code>\</code></h2><p>相当于<strong>反转义</strong>作用。使符号成为普通符号。</p>
<h2 id="11-符号’-’"><a href="#11-符号’-’" class="headerlink" title="11. 符号’`’"></a>11. 符号’`’</h2><p>起到标记作用。如：</p>
<blockquote>
<p>`ctrl+a`</p>
</blockquote>
<p>效果：</p>
<blockquote>
<p><code>ctrl+a</code>    </p>
</blockquote>
<p>以上基本是所有traditonal markdown的语法。</p>
<h3 id="其它："><a href="#其它：" class="headerlink" title="其它："></a>其它：</h3><p>列表的使用(非traditonal markdown)：</p>
<p>用<code>|</code>表示表格纵向边界，表头和表内容用<code>-</code>隔开，并可用<code>:</code>进行对齐设置，两边都有<code>:</code>则表示居中，若不加<code>:</code>则默认左对齐。</p>
<table>
<thead>
<tr>
<th style="text-align:center">代码库</th>
<th>链接</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">MarkDown</td>
<td><a href="https://github.com/younghz/Markdown" title="Markdown" target="_blank" rel="external">https://github.com/younghz/Markdown</a></td>
</tr>
<tr>
<td style="text-align:center">MarkDownCopy</td>
<td><a href="https://github.com/younghz/Markdown" title="Markdown" target="_blank" rel="external">https://github.com/younghz/Markdown</a></td>
</tr>
</tbody>
</table>
<p>关于其它扩展语法可参见具体工具的使用说明。</p>
]]></content>
      
        <categories>
            
            <category> 杂项 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
